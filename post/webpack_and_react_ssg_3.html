<!DOCTYPE html><html lang="ko-KR"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><link rel="canonical" href="https://blog.litehell.info/post/webpack_and_react_ssg_3"/><link rel="alternate" type="application/rss+xml" title="RSS 2.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/rss"/><link rel="alternate" type=" application/atom+xml" title="Atom 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/atom"/><link rel="alternate" type="application/feed+json" title="Json 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/json"/><meta property="og:title" content="Webpack과 React를 이용한 정적 웹사이트 만들기 (3)"/><meta property="og:description" content="... + MiniCssExtractPlugin = TA-DA!"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="article"/><meta property="og:site_name" content="LiteHell의 블로그"/><meta property="og:url" content="https://blog.litehell.info/post/webpack_and_react_ssg_3"/><meta property="og:image" content="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><title>LiteHell의 블로그 - <!-- -->Webpack과 React를 이용한 정적 웹사이트 만들기 (3)</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/vs2015.min.css"/><meta name="next-head-count" content="16"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CZL0E8YDPW"></script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5916984077364289" crossorigin="anonymous"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-CZL0E8YDPW', { page_path: window.location.pathname });
            </script><link rel="preload" href="/_next/static/css/27d177a30947857b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27d177a30947857b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/088d29430e0ecbdb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/088d29430e0ecbdb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-ad45764ecfcae9e5.js" defer=""></script><script src="/_next/static/chunks/main-ee0cf4b7f81d7c24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a96cacb95f41a3ef.js" defer=""></script><script src="/_next/static/chunks/996-c5e5aa4c30f33066.js" defer=""></script><script src="/_next/static/chunks/503-25bfb158f613fce4.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-c55bde140ab34b85.js" defer=""></script><script src="/_next/static/C4IygSzdus1WQT9k-jkf-/_buildManifest.js" defer=""></script><script src="/_next/static/C4IygSzdus1WQT9k-jkf-/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_body__O2_kC"><header class="Layout_header__M_IZ8"><div class="Layout_container__z4qWC"><h1><a href="/">LiteHell의 블로그</a></h1><div class="Layout_outLinks__XBNs_">외부고리 : <a href="https://litehell.info">Homepage</a><a href="https://github.com/LiteHell">GitHub</a><a href="https://linkedin.com/in/LiteHell">LinkedIn</a><a href="https://keybase.io/LiteHell">Keybase</a><a href="mailto:litehell@litehell.info">Email</a></div><div class="Layout_inLinks__f7gmD">내부고리 : <a href="/category">카테고리</a><a href="/tag">태그</a></div></div></header><main class="Layout_mainContainer__5WZfx"><div class="Layout_container__z4qWC"><div class="Blog_header__r4wcZ"><div class="Blog_title___OFu6"><h1>Webpack과 React를 이용한 정적 웹사이트 만들기 (3)</h1><h2>... + MiniCssExtractPlugin = TA-DA!</h2></div><p>7/23/2023, 5:25:47 PM<!-- -->에 <!-- -->LiteHell<!-- -->이(가) 작성<!-- -->함<br/><span>카테고리 : <a href="/category/Dev">Dev</a><br/></span><span>태그 : <span class="Blog_tag__RW5VK"><a href="/tag/React">React</a></span><br/></span></p></div><div class="Blog_seriesContainer__ii8Fj"><div class="Blog_seriesTitle__DCd_w">(시리즈) <!-- -->Webpack과 React를 이용한 정적 웹사이트 만들기</div><ul><li><a href="/post/webpack_and_react_ssg_1">Webpack과 React를 이용한 정적 웹사이트 만들기 (1)</a></li><li><a href="/post/webpack_and_react_ssg_2">Webpack과 React를 이용한 정적 웹사이트 만들기 (2)</a></li><li class="Blog_now__E4xgg"><a href="/post/webpack_and_react_ssg_3">Webpack과 React를 이용한 정적 웹사이트 만들기 (3)</a></li></ul></div><section class="Blog_article__WZp3G"><p>전 글까지 <a href="https://webpack.js.org/loaders/style-loader/">style-loader</a>를 썼다. style-loader는 style 태그를 동적으로 생성하여 CSS를 DOM 안에 주입하는 로더이다. 즉, style-loader를 쓰면 js 스크립트가 실행되면서 style 태그가 동적으로 생성되고, 그 태그 내에 css가 동적으로 삽입되면서 스타일이 적용된다.</p>
<p>하지만 정적 페이지로 빌드후 속도가 느린 서버로 게시하거나 스크립트 용량이 비대하면, 스크립트가 완전히 다 실행되기 전까지의 찰나동안 스타일이 적용되지 않은 깨진 페이지가 나타난다. 이런 버그를 막기 위해서는 <a href="https://webpack.js.org/plugins/mini-css-extract-plugin/">MiniCssExtractPlugin</a>을 이용하면 된다.</p>
<p>MiniCssExtractPlugin은 CSS를 스크립트를 통해 DOM에 주입하지 않고 별도의 CSS 파일에 저장한 뒤, 빌드시에 해당 CSS 파일을 삽입하는 link 태그를 HTML에 삽입한다. 즉 동적으로 CSS를 주입하지 않는다. 따라서 이를 이용하면 스크립트가 완전히 다 실행되기 전까지 페이지 스타일이 적용되지 않는 현상을 해결할 수 있다.</p>
<p>MiniCssExtractPlugin을 이용하기 위해서는 먼저 해당 패키지를 설치해야 한다. 다음 명령어로 해당 패키지를 설치한다.</p>
<pre><code class="hljs language-bash">yarn add --dev mini-css-extract-plugin</code></pre>
<p>그 다음 <code>webpack.config.js</code> 파일에서 다음 부분을 다음과 같이 수정한다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 수정 전</span>
<span class="hljs-attr">module</span>: {
        ...commons.module,
        <span class="hljs-attr">rules</span>: [
            ...commons.module.rules,
            <span class="hljs-comment">// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)</span>
            <span class="hljs-comment">// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 </span>
            <span class="hljs-comment">// src/index.tsx Webpack 설정에만 추가한다.</span>
            {
                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
                use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>]
            },
        ]
    },
    <span class="hljs-attr">plugins</span>: [
        ...commons.plugins,
        <span class="hljs-keyword">new</span> HtmlWebpackPlugin({
        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;index.html&#x27;</span>,
        <span class="hljs-comment">// template 속성을 추가한다.</span>
        <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span>
    })],</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// 수정 후</span>
<span class="hljs-attr">module</span>: {
        ...commons.module,
        <span class="hljs-attr">rules</span>: [
            ...commons.module.rules,
            <span class="hljs-comment">// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)</span>
            <span class="hljs-comment">// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 </span>
            <span class="hljs-comment">// src/index.tsx Webpack 설정에만 추가한다.</span>
            <span class="hljs-comment">// 그리고 프로덕션 빌드시에는 MiniCssExtractPlugin을 이용하여 js가 다 로드되기 전에는</span>
            <span class="hljs-comment">// 스타일이 적용되지 않는 버그를 해결한다.</span>
            {
                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
                use: [dev ? <span class="hljs-string">&#x27;style-loader&#x27;</span> : MiniCssExtractPlugin.loader, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>]
            },
        ]
    },
    <span class="hljs-attr">plugins</span>: [
        ...commons.plugins,
        <span class="hljs-keyword">new</span> MiniCssExtractPlugin(),
        <span class="hljs-keyword">new</span> HtmlWebpackPlugin({
        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;index.html&#x27;</span>,
        <span class="hljs-comment">// template 속성을 추가한다.</span>
        <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span>
    })],</code></pre>
<p>위와 같이 수정한 후 정적 웹페이지를 빌드하면 이제 스크립트가 불러와지는동안 스타일이 적용되지 않는 문제가 해결된다.</p>
</section><div class="Comments_blogComments__GRWmY"></div><nav class="Blog_postNav__ivy8_ Blog_hasBoth__3MRPr"><div class="Blog_leftAnchor__HhzIP"><a href="/post/creating_mastodon_instance"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">Mastodon 서버 구축하기</div><div class="Blog_subtitle__RRFh7">6$짜리 VPS와 CloudFlare를 이용한 인스턴스 구축</div></div></a></div><div class="Blog_rightAnchor__B9n7B"><a href="/post/fcitx5_for_101_key_keyboard_kde_laptop"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">한글 입력을 위한 fcitx5 설치</div><div class="Blog_subtitle__RRFh7">KDE 노트북에서의 버그없는 한글 입력을 위한 삽질기</div></div></a></div></nav></div></main><footer class="Layout_footer__bKkxe"><div class="Layout_container__z4qWC"><a href="https://www.gnu.org/licenses/agpl-3.0.en.html"><img alt="GNU Affero General License Version 3" src="https://www.gnu.org/graphics/agplv3-with-text-100x42.png" style="height:31px"/></a> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a><br/>Copyrights (C) 2020 ~ 2024 LiteHell, All rights reserved.<br/><div class="Layout_visibleOnPrintOnly__UK6Yl">LiteHell&#x27;s Blog - <a href="https://blog.litehell.info">https://blog.litehell.info</a><br/>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.<br/><br/>Url of this article: <a href="https://blog.litehell.info/post/webpack_and_react_ssg_3">https://blog.litehell.info/post/webpack_and_react_ssg_3</a><br/></div><div class="Layout_invisibleOnPrint__rdrDv">Fox Image : Copyrights (C) 2004 Shiretoko-Shari Torurist Association<br/><a href="/license">This blog is free software; For source code and more informations on license and copyrights, Click here.</a><br/><br/>Feeds : <a href="/feed/rss">RSS 2.0</a>,<!-- --> <a href="/feed/atom">Atom 1.0</a>, <a href="/feed/json">Json 1.0</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"metadata":{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (3)","subtitle":"... + MiniCssExtractPlugin = TA-DA!","author":"LiteHell","date":"2023-07-23T17:25:47.907Z","series":"webpack_and_react_ssg","seriesName":"Webpack과 React를 이용한 정적 웹사이트 만들기","category":"Dev","tags":["React"]},"rendered":"\u003cp\u003e전 글까지 \u003ca href=\"https://webpack.js.org/loaders/style-loader/\"\u003estyle-loader\u003c/a\u003e를 썼다. style-loader는 style 태그를 동적으로 생성하여 CSS를 DOM 안에 주입하는 로더이다. 즉, style-loader를 쓰면 js 스크립트가 실행되면서 style 태그가 동적으로 생성되고, 그 태그 내에 css가 동적으로 삽입되면서 스타일이 적용된다.\u003c/p\u003e\n\u003cp\u003e하지만 정적 페이지로 빌드후 속도가 느린 서버로 게시하거나 스크립트 용량이 비대하면, 스크립트가 완전히 다 실행되기 전까지의 찰나동안 스타일이 적용되지 않은 깨진 페이지가 나타난다. 이런 버그를 막기 위해서는 \u003ca href=\"https://webpack.js.org/plugins/mini-css-extract-plugin/\"\u003eMiniCssExtractPlugin\u003c/a\u003e을 이용하면 된다.\u003c/p\u003e\n\u003cp\u003eMiniCssExtractPlugin은 CSS를 스크립트를 통해 DOM에 주입하지 않고 별도의 CSS 파일에 저장한 뒤, 빌드시에 해당 CSS 파일을 삽입하는 link 태그를 HTML에 삽입한다. 즉 동적으로 CSS를 주입하지 않는다. 따라서 이를 이용하면 스크립트가 완전히 다 실행되기 전까지 페이지 스타일이 적용되지 않는 현상을 해결할 수 있다.\u003c/p\u003e\n\u003cp\u003eMiniCssExtractPlugin을 이용하기 위해서는 먼저 해당 패키지를 설치해야 한다. 다음 명령어로 해당 패키지를 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eyarn add --dev mini-css-extract-plugin\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 다음 \u003ccode\u003ewebpack.config.js\u003c/code\u003e 파일에서 다음 부분을 다음과 같이 수정한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 수정 전\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: {\n        ...commons.module,\n        \u003cspan class=\"hljs-attr\"\u003erules\u003c/span\u003e: [\n            ...commons.module.rules,\n            \u003cspan class=\"hljs-comment\"\u003e// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 \u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// src/index.tsx Webpack 설정에만 추가한다.\u003c/span\u003e\n            {\n                \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/\\.css$/\u003c/span\u003e,\n                use: [\u003cspan class=\"hljs-string\"\u003e\u0026#x27;style-loader\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;css-loader\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;postcss-loader\u0026#x27;\u003c/span\u003e]\n            },\n        ]\n    },\n    \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n        ...commons.plugins,\n        \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e HtmlWebpackPlugin({\n        \u003cspan class=\"hljs-attr\"\u003efilename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;index.html\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-comment\"\u003e// template 속성을 추가한다.\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/index.html\u0026#x27;\u003c/span\u003e\n    })],\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 수정 후\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: {\n        ...commons.module,\n        \u003cspan class=\"hljs-attr\"\u003erules\u003c/span\u003e: [\n            ...commons.module.rules,\n            \u003cspan class=\"hljs-comment\"\u003e// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 \u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// src/index.tsx Webpack 설정에만 추가한다.\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 그리고 프로덕션 빌드시에는 MiniCssExtractPlugin을 이용하여 js가 다 로드되기 전에는\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 스타일이 적용되지 않는 버그를 해결한다.\u003c/span\u003e\n            {\n                \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/\\.css$/\u003c/span\u003e,\n                use: [dev ? \u003cspan class=\"hljs-string\"\u003e\u0026#x27;style-loader\u0026#x27;\u003c/span\u003e : MiniCssExtractPlugin.loader, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;css-loader\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;postcss-loader\u0026#x27;\u003c/span\u003e]\n            },\n        ]\n    },\n    \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n        ...commons.plugins,\n        \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MiniCssExtractPlugin(),\n        \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e HtmlWebpackPlugin({\n        \u003cspan class=\"hljs-attr\"\u003efilename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;index.html\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-comment\"\u003e// template 속성을 추가한다.\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/index.html\u0026#x27;\u003c/span\u003e\n    })],\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같이 수정한 후 정적 웹페이지를 빌드하면 이제 스크립트가 불러와지는동안 스타일이 적용되지 않는 문제가 해결된다.\u003c/p\u003e\n"},"articleId":"webpack_and_react_ssg_3","series":[{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (1)","articleId":"webpack_and_react_ssg_1"},{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (2)","articleId":"webpack_and_react_ssg_2"},{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (3)","articleId":"webpack_and_react_ssg_3"}],"seriesName":"Webpack과 React를 이용한 정적 웹사이트 만들기","previousPost":{"name":"creating_mastodon_instance","metadata":{"title":"Mastodon 서버 구축하기","subtitle":"6$짜리 VPS와 CloudFlare를 이용한 인스턴스 구축","author":"LiteHell","date":"2023-07-22T15:55:38.110Z","category":"Dev","tags":["Mastodon","ActivityPub"]},"rendered":"\u003ch1 id=\"트위터와-페디버스\"\u003e트위터와 페디버스\u003c/h1\u003e\n\u003cp\u003e확실히 요즘 트위터는 달라졌다. 일론 머스크가 인수한 이후의 트위터는 확실히 뭔가 달라졌다. 뭔가 보여주겠다는 의지의 표출인가?\u003c/p\u003e\n\u003cp\u003e이런 새로워진 트위터에 적응하지 못한 사람들은 \u003ca href=\"https://joinmastodon.org\"\u003e마스토돈\u003c/a\u003e이나 \u003ca href=\"https://misskey-hub.net/\"\u003e미스키\u003c/a\u003e 등의 \u003ca href=\"https://www.w3.org/TR/activitypub/\"\u003eActivityPub\u003c/a\u003e를 구현한 분산형 SNS 인스턴스로 이주하고 있다. 국내의 이런 분산형 SNS는 대표적으로 다음과 같다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://twingyeo.kr/\"\u003e트잉여\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://planet.moe/\"\u003e플래닛\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://qdon.space/\"\u003e큐돈\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ani.work/\"\u003e애니워크\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://social.silicon.moe\"\u003eSifNet Mastodon\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://hoto.moe\"\u003ehotomoe\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위와 같이 서로 AcitivtyPub 등의 프로토콜을 이용해 통신하는 SNS 서비스들의 집합을 \u003cstrong\u003eFediverse\u003c/strong\u003e(페디버스)라 일컬는다. 페디버스는 서버간에 서로 통신할 수 있기 때문에 다른 서버에 있는 사용자와도 소통할 수 있다. 즉, 서버 A에서 서버 B에 있는 사람을 팔로우할 수도 있다.\u003c/p\u003e\n\u003ch1 id=\"mastodon-설치\"\u003eMastodon 설치\u003c/h1\u003e\n\u003cp\u003e분산형 SNS이니 당연히 본인이 직접 서버를 구축하는 것도 가능하다. 따라서 직접 VPS에 마스토돈을 설치했다. VPS 운영체제로는 데비안을 택했고, 사양은 Vultr $6 VPS로 했다.\u003c/p\u003e\n\u003cp\u003e설치 자체는 \u003ca href=\"https://docs.joinmastodon.org/admin/install/\"\u003e공식 홈페이지의 문서\u003c/a\u003e를 따르는 식으로 진행했으나 중간중간 삽질을 약간 했다.\u003c/p\u003e\n\u003ch2 id=\"root-계정-전환\"\u003eroot 계정 전환\u003c/h2\u003e\n\u003cp\u003e마스토돈을 설치하기 위해서는 먼저 root 계정으로 전환한다. \u003ccode\u003esu\u003c/code\u003e 명령어를 이용하면 된다.\u003c/p\u003e\n\u003ch2 id=\"의존성-설치\"\u003e의존성 설치\u003c/h2\u003e\n\u003cp\u003e그 다음, 의존성을 설치해야 한다. 의존성 설치 자체는 공식 홈페이지에 있는 명령어를 복사-붙여넣기하면 끝난다.\u003c/p\u003e\n\u003cp\u003e첫번째로 다음 명령어를 실행해 node.js v16을 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecurl -sL https://deb.nodesource.com/setup_16.x | bash -\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 다음 명령어를 실행해 PostgreSQL와 기타 다른 의존성들을 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eapt install -y curl wget gnupg apt-transport-https lsb-release ca-certificates\nwget -O /usr/share/keyrings/postgresql.asc https://www.postgresql.org/media/keys/ACCC4CF8.asc\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;deb [signed-by=/usr/share/keyrings/postgresql.asc] http://apt.postgresql.org/pub/repos/apt \u003cspan class=\"hljs-subst\"\u003e$(lsb_release -cs)\u003c/span\u003e-pgdg main\u0026quot;\u003c/span\u003e \u0026gt; /etc/apt/sources.list.d/postgresql.list\napt update\napt install -y \\\n  imagemagick ffmpeg libpq-dev libxml2-dev libxslt1-dev file git-core \\\n  g++ libprotobuf-dev protobuf-compiler pkg-config nodejs gcc autoconf \\\n  bison build-essential libssl-dev libyaml-dev libreadline6-dev \\\n  zlib1g-dev libncurses5-dev libffi-dev libgdbm-dev \\\n  nginx redis-server redis-tools postgresql postgresql-contrib \\\n  certbot python3-certbot-nginx libidn11-dev libicu-dev libjemalloc-dev\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"nodejs-버전-확인\"\u003enodejs 버전 확인\u003c/h3\u003e\n\u003cp\u003e다만 여기서 주의해야 하는 것이 있다. 시스템에 따라서 nodejs 16버전이 아닌 그보다 더 최신 버전이 설치됐었을 수도 있다.\n상관없지 않냐고? 상관있다, nodejs v16 버전이 아니면 나중에 webpack precompile 과정에서 오류가 난다.\u003c/p\u003e\n\u003cp\u003e설치된 nodejs의 버전은 \u003ccode\u003enode --version\u003c/code\u003e 명령어로 확인할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ node --version\nv18.13.0\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 데비안 apt 레포지토리에 있는 \u003ccode\u003enodejs\u003c/code\u003e 패키지 버전이 16보다 더 최신이기 때문에 발생한 문제이다. 이를 해결하기 위해서는 먼저 \u003ccode\u003esudo apt-cache policy nodejs\u003c/code\u003e를 실행해 어떤 버전이 설치 가능한지 확인해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ sudo apt-cache policy nodejs\nnodejs:\n  Installed: 18.13.0+dfsg1-1\n  Candidate: 18.13.0+dfsg1-1\n  Version table:\n *** 18.13.0+dfsg1-1 500\n        500 https://deb.debian.org/debian bookworm/main amd64 Packages\n        500 https://debian.mirror.constant.com bookworm/main amd64 Packages\n     16.20.1-deb-1nodesource1 500\n        500 https://deb.nodesource.com/node_16.x bookworm/main amd64 Packages\n        100 /var/lib/dpkg/status\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예시에서는 \u003ccode\u003e18.13.0+dfsg1-1\u003c/code\u003e과 \u003ccode\u003e16.20.1-deb-1nodesource1\u003c/code\u003e 버전이 설치 가능하다. 우리가 필요한 것은 nodejs v16대 버전이니 \u003ccode\u003e16.20.1-deb-1nodesource1\u003c/code\u003e을 설치할 것이다.\u003c/p\u003e\n\u003cp\u003eapt에서 특정한 버전을 지정해 설치하기 위해서는 다음과 같이 명령어를 실행하면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ sudo apt install nodejs=16.20.1-deb-1nodesource1\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 nodejs v16이 정상적으로 설치된 것을 확인할 수 있다.\u003c/p\u003e\n\u003ch3 id=\"yarn-설치\"\u003eYarn 설치\u003c/h3\u003e\n\u003cp\u003e위에서 nodejs, PostregreSQL 등의 의존성을 다 설치했으면 \u003ca href=\"https://yarnpkg.com\"\u003eYarn\u003c/a\u003e을 설치해야 한다. Yarn은 다음 명령어로 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecorepack \u003cspan class=\"hljs-built_in\"\u003eenable\u003c/span\u003e\nyarn \u003cspan class=\"hljs-built_in\"\u003eset\u003c/span\u003e version classic\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e혹시 위 명령어가 작동하지 않는다면 다음과 같이 npm을 이용해 설치할 수도 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo npm i -g yarn\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 위 npm을 이용한 명령어가 npm이 설치되어 있지 않아 실행되지 않는다면 아래 명령어로 npm을 실치할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecurl -qL https://www.npmjs.com/install.sh | sh\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ruby-설치\"\u003eRuby 설치\u003c/h2\u003e\n\u003cp\u003e이제 Ruby를 설치해야 한다. 먼저 \u003ccode\u003emastodon\u003c/code\u003e이라는 이름의 리눅스 계정을 생성한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eadduser --disabled-login mastodon\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 쉘을 지정한다. (안 하면 \u003ccode\u003esudo su - mastodon\u003c/code\u003e 명령어가 오류날 수 있다.) 아래 명령어에서는 쉘을 bash로 지정했는데, 쉘이 무조건 bash여야 할 필요는 없다. 선호하는 쉘이 있다면 그 쉘로 지정해도 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003echsh -s /bin/bash mastodon\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 mastodon으로 계정을 전환하자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo su - mastodon\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 명령어를 모두 실행해 Ruby를 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003egit \u003cspan class=\"hljs-built_in\"\u003eclone\u003c/span\u003e https://github.com/rbenv/rbenv.git ~/.rbenv\n\u003cspan class=\"hljs-built_in\"\u003ecd\u003c/span\u003e ~/.rbenv \u0026amp;\u0026amp; src/configure \u0026amp;\u0026amp; make -C src\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;export PATH=\u0026quot;$HOME/.rbenv/bin:$PATH\u0026quot;\u0026#x27;\u003c/span\u003e \u0026gt;\u0026gt; ~/.bashrc\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;eval \u0026quot;$(rbenv init -)\u0026quot;\u0026#x27;\u003c/span\u003e \u0026gt;\u0026gt; ~/.bashrc\n\u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e bash\ngit \u003cspan class=\"hljs-built_in\"\u003eclone\u003c/span\u003e https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build\nRUBY_CONFIGURE_OPTS=--with-jemalloc rbenv install 3.0.6\nrbenv global 3.0.6\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRuby 설치가 완료됐다면 bundler도 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003egem install bundler --no-document\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRuby와 bundler 설치를 마쳤다면 root 유저로 되돌아간다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexit\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"postgresql-설정\"\u003ePostgreSQL 설정\u003c/h2\u003e\n\u003cp\u003e공식 문서에서 pgTune을 쓰고 싶으면 쓰라고 나와있는데 필자는 귀찮아서 건너뛰었다.\u003c/p\u003e\n\u003cp\u003ePostgreSQL 설정을 위해 다음 명령어로 PostgreSQL 쉘을 띄운다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo -u postgres psql\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePostgreSQL 쉘이 띄워졌으면 다음 쿼리를 실행해서 SQL 계정을 생성한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eUSER\u003c/span\u003e mastodon CREATEDB;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e계정이 생성됐으면 다음 명령을 쳐서 쉘을 빠져나온다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\\q\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"마스토돈-다운로드\"\u003e마스토돈 다운로드\u003c/h2\u003e\n\u003cp\u003e이제 마스토돈을 다운로드하고 설정할 때가 왔다. 먼저 mastodon 계정으로 전환한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo su - mastodon\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 명령어를 실행해 최신 stable 버전의 mastodon을 다운로드한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003egit \u003cspan class=\"hljs-built_in\"\u003eclone\u003c/span\u003e https://github.com/mastodon/mastodon.git live \u0026amp;\u0026amp; \u003cspan class=\"hljs-built_in\"\u003ecd\u003c/span\u003e live\ngit checkout $(git tag -l | grep -v \u003cspan class=\"hljs-string\"\u003e\u0026#x27;rc[0-9]*$\u0026#x27;\u003c/span\u003e | sort -V | tail -n 1)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 Ruby 의존성과 JavaScript 의존성을 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ebundle config deployment \u003cspan class=\"hljs-string\"\u003e\u0026#x27;true\u0026#x27;\u003c/span\u003e\nbundle config without \u003cspan class=\"hljs-string\"\u003e\u0026#x27;development test\u0026#x27;\u003c/span\u003e\nbundle install -j$(getconf _NPROCESSORS_ONLN)\nyarn install --pure-lockfile\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"서버-swap-설정-및-nodejs-heap-용량-설정\"\u003e서버 swap 설정 및 nodejs heap 용량 설정\u003c/h2\u003e\n\u003cp\u003e마스토돈 설정(바로 다음 문단)을 하는 과정에서 Javascript heap out of memory 오류가 발생할 수 있다. 이는 서버에 RAM이 부족하기 때문이다. 이를 해결하기 위해서는 RAM을 더 꽂거나 swap 파일을 형성하고, 그 다음 node 설정을 수정해야 한다.\u003c/p\u003e\n\u003cp\u003e먼저 swap파일을 생성하는 방법은 다음과 같다. 용량은 적절하게 바꾸면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo fallocate -l 2G /tmp-swapfile\nsudo chmod 600 /tmp-swapfile\nsudo mkswap /tmp-swapfile\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e생성된 swap파일은 다음과 같이 적용할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo swapon /tmp-swapfile\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 명령어로 적용된 swap파일은 재부팅이 될 시 다시 적용되지 않으므로 재부팅을 하면 위 명령어를 다시 쳐줘야 한다. 따라서 swap 파일을 영구적으로 적용하기 위해서는 \u003ccode\u003e/etc/fstab\u003c/code\u003e 파일을 수정해야 하나, 본 글에서는 마스토돈을 설정하는 동안에만 임시적으로 이용할 swap 파일을 생성하는 것이므로 이 파일을 수정하는 방법에 대해서 언급하지 않는다.\u003c/p\u003e\n\u003cp\u003e이제 node 설정을 바꾸어야 한다. 먼저 현재 할당한 힙 용량을 다음 명령어로 확인한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003enode -e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;console.log(v8.getHeapStatistics().heap_size_limit/(1024*1024))\u0026#x27;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e실행하면 다음과 같이 뜰 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ node -e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;console.log(v8.getHeapStatistics().heap_size_limit/(1024*1024))\u0026#x27;\u003c/span\u003e\n495.75\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 용량을 참고해서 위 용량보다 적당히 더 큰 용량으로 힙 용량을 설정하면 된다. 힙 용량의 설정은 다음 명령어를 마스토돈 설정 명령어 실행 직전에 실행함으로써 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e NODE_OPTIONS=--max_old_space_size=800\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"마스토돈-설정\"\u003e마스토돈 설정\u003c/h2\u003e\n\u003cp\u003e다음 명령어를 실행해 마스토돈 서버를 설정한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eRAILS_ENV=production bundle \u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e rake mastodon:setup\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 Javascript heap out of memory 오류가 떴다면 바로 윗 문단에 따라 힙 용량 및 swap 설정을 하고 다음 명령어를 실행하면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eRAILS_ENV=production bundle \u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e rails assets:precompile\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e성공적으로 실행됐을 시 마스토돈 관리자 비밀번호가 표시될 것이다. 잊지 말고 메모하도록 하자.\u003c/p\u003e\n\u003ch2 id=\"nginx-설정\"\u003enginx 설정\u003c/h2\u003e\n\u003cp\u003e다음 명령어를 실행한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecp /home/mastodon/live/dist/nginx.conf /etc/nginx/sites-available/mastodon\nln -s /etc/nginx/sites-available/mastodon /etc/nginx/sites-enabled/mastodon\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e/etc/nginx/sites-available/mastodon\u003c/code\u003e 파일에서 \u003ccode\u003eexample.com\u003c/code\u003e을 모두 자신의 마스토돈 도메인(내 경우에는 \u003ccode\u003esocial.litehell.info\u003c/code\u003e)로 바꾼다. 그리고 다음 명령어를 실행한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esystemctl reload nginx\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"cloudflare-origin-certificate-설정\"\u003eCloudFlare Origin Certificate 설정\u003c/h2\u003e\n\u003cp\u003e필자는 CloudFlare Origin Certificate를 쓴다. CloudFlare에서 Origin Certificate를 생성한 뒤 서버에 저장하고, \u003ccode\u003e/etc/nginx/sites-available/mastodon\u003c/code\u003e 파일에서 \u003ccode\u003essl_certificate\u003c/code\u003e 속성과 \u003ccode\u003essl_certificate_key\u003c/code\u003e를 다운받은 서버/서버 개인키 경로로 수정하면 된다.\u003c/p\u003e\n\u003ch2 id=\"systemd-설정\"\u003esystemd 설정\u003c/h2\u003e\n\u003cp\u003e아래 명령어를 실행한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecp /home/mastodon/live/dist/mastodon-*.service /etc/systemd/system/\nsystemctl daemon-reload\nsystemctl \u003cspan class=\"hljs-built_in\"\u003eenable\u003c/span\u003e --now mastodon-web mastodon-sidekiq mastodon-streaming\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 마스토돈이 실행될 것이다. 이제 즐기면 된다.\u003c/p\u003e\n\u003ch2 id=\"cloudflare-최적화로-인한-사이트-깨짐-문제-해결\"\u003eCloudFlare 최적화로 인한 사이트 깨짐 문제 해결\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/img/broken_css_mastodon.png\" alt=\"CSS가 정상적으로 불러와지지 않은 마스토돈 인스턴스의 스크린샷\"\u003e\u003c/p\u003e\n\u003cp\u003eCloudFlare를 쓰면 위와 같이 마스토돈이 깨지는 문제를 겪을 수 있다.\n이는, 무결성을 위해 HTML 내에 CSS 파일의 해시가 포함되어있는데, CloudFlare가 CSS를 자동 최적화하면서 CSS 파일이 변경되고, 이로 인해 해시가 불일치됨에 따라 웹브라우저가 CSS를 불러오지 않음으로써 발생하는 문제이다.\u003c/p\u003e\n\u003cp\u003e이 문제는 CloudFlare에서 Auto Minify를 비활성화하고 모든 캐시를 삭제하여 해결할 수 있다.\u003c/p\u003e\n\u003ch2 id=\"릴레이-연결\"\u003e릴레이 연결\u003c/h2\u003e\n\u003cp\u003e마스토돈에 혼자 있으면 외롭다. 이를 극복하기 위해서는 릴레이를 연결해야 한다. 페디버스 내에서 인스턴스는 기본적으로 게시물을 팔로워가 있는 서버에만 전송한다. 따라서 타 서버의 팔로워가 없는 인스턴스는 외로울 수 밖에 없다. 이를 극복하기 위해 릴레이가 있다.\u003c/p\u003e\n\u003cp\u003e릴레이는 구독하는 서버들간에 게시물을 나눈다. 릴레이에 구독된 인스턴스가 게시물을 릴레이로 보내면, 릴레이가 구독된 모든 서버들에게 게시물을 전송하는 방식이다. 따라서 릴레이내에 있는 서버간에는 팔로워가 있는지의 여부와 상관없이 게시물이 서로 공유된다.\u003c/p\u003e\n\u003cp\u003e한국어권 릴레이는 다음 세가지 릴레이가 있다. 이 릴레이는 모두 화이트리스트이다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://relay.mastodon.kr\"\u003e한국 Mastodon 인스턴스 연합(가칭) 릴레이\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://interstellar.flights\"\u003e인터스텔라 릴레이 커뮤니티\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://relay.musubi.moe\"\u003emusubi.moe\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 릴레이에 가입하기 위해서는 각 릴레이에서 요구하는 조건을 모두 만족시킨 뒤 릴레이측에 가입 신청을 하면 된다. 가입 신청 방법 및 조건은 릴레이마다 다르다. 가입 신청이 받아들여지면 릴레이 관리 페이지(\u003ccode\u003e/admin/relays\u003c/code\u003e)에서 해당 릴레이에서 안내하는 주소를 추가하면 된다. 참고로 내 경험상 개인 인스턴스라고 딱히 안 받아주진 않았다. 조건만 맞으면 받아주는 것 같으니 조건이 맞는다면 부담없이 신청해보자.\u003c/p\u003e\n\u003cp\u003e모든 릴레이가 화이트리스트인 것은 아니다. \u003ca href=\"https://relaylist.com\"\u003eRelayList\u003c/a\u003e에서 Registeration이 open으로 되어있는 릴레이는 가입신청을 하지 않아도 되는 릴레이들이다. 다만 대규모 릴레이는 구독이 처리되는 데 시간이 좀 오래 걸릴 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://relay.fedi.buzz/\"\u003e#FediBuzz Relay\u003c/a\u003e 서비스를 이용하면 특정 마스토돈 인스턴스의 타임라인을 릴레이를 통해 구독할 수도 있다. 해당 사이트의 안내를 따르면 특정 인스턴스의 타임라인을 구독할 수 있다.\u003c/p\u003e\n\u003ch2 id=\"publicsystem-용량-문제\"\u003epublic/system 용량 문제\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003epublic/system\u003c/code\u003e 디렉토리는 용량을 많이 잡아먹는다. 다음 두 가지 방법 중 하나를 택하여 해결하면 된다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eS3-Compatible Object Storage 쓰기\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.joinmastodon.org/admin/setup/#cleanup\"\u003e마스토돈 공식 홈페이지의 Running periodic cleanup tasks 문단\u003c/a\u003e에 따라 crontab을 생성하고 마스토돈이 설치된 디렉토리에서 다음 명령어 모두 실행하기\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eRAILS_ENV=production ./bin/tootctl accounts prune\nRAILS_ENV=production ./bin/tootctl cache clear\nRAILS_ENV=production ./bin/tootctl media remove --days=0\nRAILS_ENV=production ./bin/tootctl media remove --prune-profiles --days=0\nRAILS_ENV=production ./bin/tootctl preview_cards remove --days=0\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ecrontab과 위 명령어만으로 부족하면 그냥 대용량 하드디스크 하나 꽂고 \u003ccode\u003e/etc/fstab\u003c/code\u003e 파일 수정해서 \u003ccode\u003epublic/system\u003c/code\u003e 디렉토리에 영구 마운트해버리기 (좀 무식하게 보일 수도 있지만 간단하고 직빵이다)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마음에 드는 방법을 택하도록 하자.\u003c/p\u003e\n"},"nextPost":{"name":"fcitx5_for_101_key_keyboard_kde_laptop","metadata":{"title":"한글 입력을 위한 fcitx5 설치","subtitle":"KDE 노트북에서의 버그없는 한글 입력을 위한 삽질기","author":"LiteHell","date":"2023-10-17T12:34:16.790Z","category":"Linux","tags":["Linux","Korean","Hangul","IM","KDE"],"last_modified_at":"2023-10-17T14:32:47.687Z"},"rendered":"\u003ch1 id=\"서론\"\u003e서론\u003c/h1\u003e\n\u003cp\u003e필자는 초창기에 \u003ca href=\"https://github.com/ibus/ibus\"\u003eibus\u003c/a\u003e를 썼었다. ibus는 웬만한 프로그램에서 아무 버그없이 잘 작동한다. 딱 한가지, 리브레오피스에서 공백 입력이 안 된다는 치명적인 버그만 빼면 말이다.\u003c/p\u003e\n\u003cp\u003e그래서 ibus 다음으로 \u003ca href=\"https://github.com/hamonikr/nimf\"\u003e하모니카에서 유지보수하는 nimf\u003c/a\u003e를 썼었다. nimf는 리브레오피스에서의 치명적인 버그는 없었지만, 엔터키를 누르면 텍스트가 사라지는 버그가 있었다. 근데 이 버그, 처음에만 짜증나지 좀 지나면 적응된다. 그래서 적응해서 쓰다가 생각해보니 \u0026#39;이건 좀 아닌 것 같다\u0026#39;싶어서 다른 입력기를 설치했다.\u003c/p\u003e\n\u003cp\u003e본 블로그 글은 \u003ca href=\"https://archlinux.org/\"\u003eArch Linux\u003c/a\u003e를 기준으로 설명한다.\u003c/p\u003e\n\u003ch2 id=\"kde에서의-키보드-레이아웃\"\u003eKDE에서의 키보드 레이아웃\u003c/h2\u003e\n\u003cp\u003e입력기를 바꾸기 위해 삽질하는 과정에서 한글키가 오른쪽 Alt키로 인식되는 현상을 확인했다. 분명히 아치 리눅스 설치 초기에 매핑을 했었는데, 시스템 업데이트를 하는 과정에서 원상복구가 된 것 같다. 그래서 이번에는 KDE 설정 프로그램을 이용해 한글키와 한자키를 매핑했다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/kde_keyboard_settings.png\" alt=\"KDE 키보드 설정 프로그램\"\u003e\u003c/p\u003e\n\u003cp\u003e위와 같이 시스템 설정 프로그램의 \u003cstrong\u003e입력 장치 🠞 키보드\u003c/strong\u003e 화면에서 \u003cstrong\u003e오른쪽 Alt 키를 한/영 키로 만들기\u003c/strong\u003e, \u003cstrong\u003e오른쪽 Ctrl 키를 한자 키로 만들기\u003c/strong\u003e 항목을 체크하면 된다. (키보드 레이아웃에 따라 약간 다를 수 있다.) 노트북 등의 101/104키 호환 레이아웃이라면 위 과정을 반드시 거쳐야 한다.\u003c/p\u003e\n\u003ch3 id=\"한영-한자키-인식여부-확인방법\"\u003e한/영, 한자키 인식여부 확인방법\u003c/h3\u003e\n\u003cp\u003e본인 키보드가 101/104키인지 106키인지 헷갈린다면 \u003cdel\u003e키보드 키 갯수 세지말고\u003c/del\u003e 먼저 \u003ccode\u003exev\u003c/code\u003e 프로그램을 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo pacman -S xorg-xev\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 콘솔 창에서 xev 프로그램을 실행한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003exev\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003exev 프로그램 창을 활성화하고 한글키랑 한자키를 눌러본다. 다음과 같이 콘솔 창에 \u003cem\u003eHangul\u003c/em\u003e이나 \u003cem\u003eHangul_Hanja\u003c/em\u003e키가 인식된 메세지가 출력되면 한/영 키, 한자 키가 정상적으로 인식되는 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eKeyRelease event, serial 39, synthetic NO, window 0x9000001,\n    root 0x79b, subw 0x0, time 1234567, (-10, 10), root:(10, 10),\n    state 0x0, keycode 108 (keysym 0xff31, Hangul), same_screen YES,\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eKeyPress event, serial 39, synthetic NO, window 0x9000001,\n    root 0x79b, subw 0x0, time 1234567, (10, 10), root:(10, 10),\n    state 0x0, keycode 105 (keysym 0xff34, Hangul_Hanja), same_screen YES,\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 위와 같은 메세지가 안 뜨고 Alt_R이나 Control_R이 인식된다면 \u003ca href=\"#kde에서의-키보드-레이아웃\"\u003e위에 써진 내용\u003c/a\u003e에 따라 매핑하면 된다.\u003c/p\u003e\n\u003ch2 id=\"fcitx5-설치-방법\"\u003efcitx5 설치 방법\u003c/h2\u003e\n\u003cp\u003e먼저, 다음 명령어를 실행해 fcitx5를 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo pacman -S fcitx5-im fcitx-hangul\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e/etc/environment\u003c/code\u003e 파일에 다음 내용을 추가한다. 입력기로 fcitx를 쓰도록 지정하는 작업이다.\u003c/p\u003e\n\u003c!-- ini파일이 아니지만 syntax highlighting을 위해 형식을 ini으로 지정함 ---\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ini\"\u003e\u003cspan class=\"hljs-attr\"\u003eGTK_IM_MODULE\u003c/span\u003e=fcitx\n\u003cspan class=\"hljs-attr\"\u003eQT_IM_MODULE\u003c/span\u003e=fcitx\n\u003cspan class=\"hljs-attr\"\u003eQT4_IM_MODULE\u003c/span\u003e=fcitx\n\u003cspan class=\"hljs-attr\"\u003eQT5_IM_MODULE\u003c/span\u003e=fcitx\n\u003cspan class=\"hljs-attr\"\u003eXMODIFIERS\u003c/span\u003e=@im=fcitx\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 다음에 \u003ccode\u003e~/.xprofile\u003c/code\u003e 파일에 다음 내용을 추가한다. 부팅시에 fcitx5가 실행되도록 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003efcitx5 -d\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e재부팅하고 \u003ccode\u003eenv | grep fcitx\u003c/code\u003e 명령어를 실행해 환경변수가 제대로 변경됐는지 확인해보자. 제대로 변경됐다면 다음과 같이 뜰 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eGTK_IM_MODULE=fcitx\nQT4_IM_MODULE=fcitx\nXMODIFIERS=@im=fcitx\nQT5_IM_MODULE=fcitx\nQT_IM_MODULE=fcitx\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 환경변수가 제대로 변경되지 않았다면 \u003ccode\u003e~/.xprofile\u003c/code\u003e 파일에서 \u003ccode\u003efcitx5 -d\u003c/code\u003e 위에 다음 내용을 추가하고 재부팅한다. 그러면 환경변수가 정상적으로 변경될 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e $(/usr/lib/systemd/user-environment-generators/30-systemd-environment-d-generator)\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"fcitx5-설정\"\u003efcitx5 설정\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efcitx5-configtool\u003c/code\u003e 명령어를 실행하면 다음 창이 뜬다.\n\u003cimg src=\"/img/fcitx5_settings_first_screen.png\" alt=\"fcitx5 KDE 설정 창\"\u003e\u003c/p\u003e\n\u003cp\u003e위 화면에서 한국어가 안 보이면 \u003cstrong\u003e입력기 추가\u003c/strong\u003e버튼을 눌러서 추가한다. (입력기 추가 화면에서 한국어가 안 보이면 \u003cstrong\u003e현재 언어만 표시\u003c/strong\u003e 옵션을 해제하면 된다.)\u003c/p\u003e\n\u003cp\u003e밑에서 \u003cstrong\u003e전역 옵션 구성하기...\u003c/strong\u003e 버튼을 누르면 다음 화면이 뜬다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/fcitx5_global_settings.png\" alt=\"fcitx5 KDE 설정 창\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTrigger Input Method\u003c/strong\u003e가 한/영을 전환하는 단축키 설정이다. 오른쪽의 \u003cstrong\u003e+\u003c/strong\u003e 버튼을 눌러 한글 키를 추가하면 된다.\u003c/p\u003e\n\u003cp\u003efcitx5는 기본적으로 한/영을 전환할때 작은 툴팁을 표시한다. 거슬리면 위 화면에서 \u003cstrong\u003eShow Input Method Information when switch input method\u003c/strong\u003e를 체크 해제하면 된다.\u003c/p\u003e\n\u003cp\u003e이제 한글 입력을 버그없이 잘 할 수 있게 됐다. 끝!\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"webpack_and_react_ssg_3"},"buildId":"C4IygSzdus1WQT9k-jkf-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>