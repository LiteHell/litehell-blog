<!DOCTYPE html><html lang="ko-KR"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><link rel="canonical" href="https://blog.litehell.info/post/caucalendar_1"/><link rel="alternate" type="application/rss+xml" title="RSS 2.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/rss"/><link rel="alternate" type=" application/atom+xml" title="Atom 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/atom"/><link rel="alternate" type="application/feed+json" title="Json 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/json"/><meta property="og:title" content="학사일정 ICS 서비스 개발기 (上)"/><meta property="og:description" content="Javascript랑 함께 Docker로"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="article"/><meta property="og:site_name" content="LiteHell의 블로그"/><meta property="og:url" content="https://blog.litehell.info/post/caucalendar_1"/><meta property="og:image" content="https://blog.litehell.info/img/puang_network/caucalendar_first_commit_html.png"/><title>LiteHell의 블로그 - <!-- -->학사일정 ICS 서비스 개발기 (上)</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/vs2015.min.css"/><meta name="next-head-count" content="16"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CZL0E8YDPW"></script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5916984077364289" crossorigin="anonymous"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-CZL0E8YDPW', { page_path: window.location.pathname });
            </script><link rel="preload" href="/_next/static/css/27d177a30947857b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27d177a30947857b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/088d29430e0ecbdb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/088d29430e0ecbdb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-ad45764ecfcae9e5.js" defer=""></script><script src="/_next/static/chunks/main-ee0cf4b7f81d7c24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a96cacb95f41a3ef.js" defer=""></script><script src="/_next/static/chunks/996-c5e5aa4c30f33066.js" defer=""></script><script src="/_next/static/chunks/503-25bfb158f613fce4.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-b722ca2857677f7b.js" defer=""></script><script src="/_next/static/ceNNFcdZkyahVzhygnwwc/_buildManifest.js" defer=""></script><script src="/_next/static/ceNNFcdZkyahVzhygnwwc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_body__O2_kC"><header class="Layout_header__M_IZ8"><div class="Layout_container__z4qWC"><h1><a href="/">LiteHell의 블로그</a></h1><div class="Layout_outLinks__XBNs_">외부고리 : <a href="https://litehell.info">Homepage</a><a href="https://github.com/LiteHell">GitHub</a><a href="https://linkedin.com/in/LiteHell">LinkedIn</a><a href="https://keybase.io/LiteHell">Keybase</a><a href="mailto:litehell@litehell.info">Email</a></div><div class="Layout_inLinks__f7gmD">내부고리 : <a href="/category">카테고리</a><a href="/tag">태그</a></div></div></header><main class="Layout_mainContainer__5WZfx"><div class="Layout_container__z4qWC"><div class="Blog_header__r4wcZ"><div class="Blog_title___OFu6"><h1>학사일정 ICS 서비스 개발기 (上)</h1><h2>Javascript랑 함께 Docker로</h2></div><p>9/15/2024, 1:06:50 PM<!-- -->에 <!-- -->LiteHell<!-- -->이(가) 작성<!-- -->함<br/><span>카테고리 : <a href="/category/Dev">Dev</a><br/></span></p></div><div class="Blog_seriesContainer__ii8Fj"><div class="Blog_seriesTitle__DCd_w">(시리즈) <!-- -->학사일정/RSS/시간표 미리보기 서비스 개발기</div><ul><li class="Blog_now__E4xgg"><a href="/post/caucalendar_1">학사일정 ICS 서비스 개발기 (上)</a></li></ul></div><section class="Blog_article__WZp3G"><h1 id="들어가는-글">들어가는 글</h1>
<p>나는 캘린더 앱을 적극적으로 활용한다. 시간이나 약속을 머릿속으로만 관리하면 잘 잊어버리기 때문에 캘린더 앱을 적극적으로 활용하고 있다.</p>
<p>그렇게 캘린더 앱을 적극적으로 쓰다가 대학교에 입학했다. 시험기간이나 수강정정기간 같은 것도 캘린더 앱에 뜨면 좋겠는데 이걸 직접 추가하는 건 귀찮았다. 그래서 <a href="https://www.cau.ac.kr/cms/FR_CON/index.do?MENU_ID=590">중앙대학교 학사일정 페이지</a>를 크롤링하는 어플리케이션을 작성했다. 그리고 캘린더 앱과 내 어플리케이션을 연동하는 데에는 iCalendar 파일 포맷을 이용했다.</p>
<h2 id="icalendar">iCalendar</h2>
<p><a href="https://calendar.google.com">Google Calendar</a>나 <a href="https://outlook.com">MS Outlook</a>, 혹은 필자가 이용하는 <a href="https://www.fastmail.com">FastMail</a>에서는 캘린더 기능을 제공한다. 이 캘린더 서비스들은 기본적으로 특정한 iCalendar 주소를 구독하는 기능을 지원한다. 즉, 다시 말해 필자가 구글 캘린더나 아웃룩에 iCalendar 파일 주소를 추가하면, 구글 캘린더나 아웃룩 서버가 주기적으로 iCalendar 주소에 접속해 동기화한다.</p>
<p>iCalendar 파일은 다음과 같은 형식으로 되어있다.</p>
<pre><code>BEGIN:VCALENDAR
VERSION:2.0
TIMEZONE-ID:Asia/Seoul
X-WR-TIMEZONE:Asia/Seoul
X-WR-CALNAME:중앙대학교 학사일정
X-WR-CALDESC:calendar.puang.network에서 제공하는 중앙대학교 학사일정
CALSCALE:GREGORIAN
PRODID:adamgibbons/ics
METHOD:PUBLISH
X-PUBLISHED-TTL:PT1H
BEGIN:VTIMEZONE
TZID:Asia/Seoul
TZURL:http://tzurl.org/zoneinfo-outlook/Asia/Seoul
X-LIC-LOCATION:Asia/Seoul
BEGIN:STANDARD
TZOFFSETFROM:+0900
TZOFFSETTO:+0900
TZNAME:KST
DTSTART:19700101T000000
END:STANDARD
END:VTIMEZONE
BEGIN:VEVENT
UID:552361268d864ef42fff1bee5d295e073f7ab2b2@calendar.puang.network
SUMMARY:신정(공휴일)
DTSTAMP:20240825T081930Z
DTSTART;TZID=Asia/Seoul;VALUE=DATE:20220101
END:VEVENT
BEGIN:VEVENT
UID:eb57cfcaf7345c4ad83d1e7537dd81016db2d8a7@calendar.puang.network
SUMMARY:2022년 1학기 재입학 원서접수
DTSTAMP:20240825T081930Z
DTSTART;TZID=Asia/Seoul;VALUE=DATE:20220103
DTEND;TZID=Asia/Seoul;VALUE=DATE:20220107
END:VEVENT
END:VCALENDAR</code></pre>
<p>위와 같은 식으로 iCalendar 아이템(<code>VCALENDAR</code>) 속에 여러 일정(<code>VEVENT</code>)들이 나열되어 있다. iCalendar 형식은 할일(<code>VTODO</code>)이나 일기(<code>VJOURNAL</code>)도 지원하지만 이 글에서는 다루지 않는다.</p>
<h2 id="koajs를-이용한-첫-버전"><a href="https://koajs.com/">Koa.js</a>를 이용한 첫 버전</h2>
<p>첫 버전은 <a href="https://koajs.com/">Koa 프레임워크</a>를 이용하여 간단하게 작성했다. 원래 이전에는 <a href="https://expressjs.com/">express</a>를 썼었는데, express는 <code>async</code> 함수 핸들러가 바로 지원되지 않아서 약간 귀찮다는 단점이 있었기에 Koa 프레임워크를 이용했다.</p>
<p>이 프로그램에서 중요한 것은 iCalendar 파일을 제공하는 것이다. 따라서 그 외의 요소는 모두 부수적인 것이다. 그렇기에 프론트엔드는 다음과 같이 디자인이 극단적으로 되어있어도 상관없었다. (사진은 첫 커밋 버전의 메인 페이지이다.)</p>
<p><img src="/img/puang_network/caucalendar_first_commit_html.png" alt="첫 커밋 버전의 caucalendar.online 프로젝트 프론트엔드"></p>
<p>다만 그래도 위처럼 만드는 건 좀 심하니 <a href="https://bulma.io">bulma CSS 프레임워크</a>를 이용해 아래와 같이 간단히 꾸몄다.</p>
<p><img src="/img/puang_network/caucalendar_bulma_frontend.png" alt="bulma 프레임워크를 이용한 caucalendar.online 프로젝트 프론트엔드"></p>
<p>이때가 2019년 5~6월쯤이였다. 이때의 구조도는 다음과 같다.</p>
<p><img src="/img/puang_network/caucalendar_vps_nodejs.png" alt="서비스 구조도"></p>
<p>당시 가상서버에서는 여러 웹서비스가 구동되고 있었기에, Host를 확인하여 알맞은 웹서비스로 트래픽을 전달해야 했다. 따라서 Nginx로 리버스 프록시가 동작하고 있었다.</p>
<p>위 사진에서 <a href="https://pm2.io">PM2</a>는 프로세스가 꺼지면 다시 켜주는 역할을 한다. <a href="https://github.com/librewiki/liberty-engine">리브레위키의 리버티엔진</a>에서 쓰길래 써봤다.</p>
<h2 id="크롤링-스크립트-분리">크롤링 스크립트 분리</h2>
<p>초기에는 크롤링을 분리하기 귀찮아서, 그냥 요청이 들어올 때마다 학교 홈페이지에 접속해 학사일정 iCalendar 파일(이하 &quot;ics 파일&quot;)을 제공했다. 그랬더니 어느순간 학교에서 서버 ip를 차단했다. 이게 2019년 11월 쯤의 일이였다.</p>
<p>그래서 크롤링하는 코드를 별도의 파일로 분리하고, crontab을 이용해 크롤링 스크립트가 주기적으로 실행되게 했다. 크롤링된 데이터는 <a href="https://sequelize.org/">Sequelize</a> ORM을 이용해 저장했다.</p>
<h2 id="github-action">GitHub Action</h2>
<p>학사일정 서비스에 버그가 생겼다고 캘린더 앱에서 잘 보이던 일정이 갑자기 사라지진 않는다. 그래서 동작에 이상이 생겨도 기존에 쓰던 사람들은 티가 잘 안난다.</p>
<p>그래서 동작이 정상적으로 이루어지는 지 주기적으로 확인하기 위해 다음과 같이 GitHub Action을 추가했다.
푸시나 커밋시가 아닌 특정 주기에 따라 반복되는 GitHub CI로 테스트가 주기적으로 이루어지도록 했다.</p>
<p>따라서 이를 통해 학교 홈페이지의 갑작스런 디자인/API 변경에도 대응할 수 있었다. </p>
<pre><code class="hljs language-yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">and</span> <span class="hljs-string">test</span>

<span class="hljs-attr">on:</span>
  <span class="hljs-attr">schedule:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&#x27;0 19 * * *&#x27;</span>
  <span class="hljs-attr">push:</span>

<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">build:</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span>

      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">docker</span> <span class="hljs-string">build</span> <span class="hljs-string">--target</span> <span class="hljs-string">test</span> <span class="hljs-string">.</span></code></pre>
<p>푸시나 커밋시가 아닌 cron으로 GitHub CI를 추가하여 학교 홈페이지의 갑작스런 디자인/API 변경에도 대응할 수 있도록 했다.</p>
<h2 id="도커라이징">도커라이징</h2>
<p>개인서버에서 돌아가던 서비스들을 다 도커 컨테이너에 감싸는 작업을 했었다. 그때 학사일정 ics 서비스도 도커 컨테이너로 감쌌다. crontab을 이용해 따로 돌아가던 크롤링 스크립트는 어플리케이션에 다시 집어넣어서, 어플리케이션 실행시 크롤링이 자동으로 주기적으로 실행되도록 수정했다. Docker에서 crontab을 쓰려면 약간 귀찮기 때문이다.</p>
<p>처음에는 <code>node:14</code> 도커 이미지를 기반으로 썼는데 값싼 가상서버에서 쓰기에는 디스크를 너무 많이 차지했다. 그래서 나중에 Alpine Linux 기반 도커를 기반으로 바꿨다. Alpine Linux 기반 이미지를 쓰니 디스크 소비량을 줄일 수 있었다. 이때가 2021년 2~3월인가 그랬을 것이다.</p>
<h2 id="go-언어로의-재작성">Go 언어로의 재작성</h2>
<p>그렇게 Javascript로 작성해서 잘 쓰다가 문득 이런 생각이 들었다. &#39;Go를 쓰면 더 빠르지 않을까?&#39; Javascript는 인터프리터 언어이고, Go는 컴파일 언어이니, 알고리즘의 효율성이 유사하다는 가정하에 Go가 더 빠를 수도 있지 않을까란 생각이 들었다. 물론 Go 언어를 한 번 써보고 싶은 생각도 없진 않았다.</p>
<p>그래서 Go 언어로 학사일정 서비스를 재작성했다. 크롤러는 다음과 같이 고루틴을 이용하여 비동기적으로 동시에 구동되도록 했다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawlWorker</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">for</span> {
        time.Sleep(time.Hour * <span class="hljs-number">1</span>)
        fetchAllYears()
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupCrawller</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">go</span> crawlWorker()
}</code></pre>
<h2 id="docker를-이용한-테스팅">Docker를 이용한 테스팅</h2>
<p>DigiCert CA 인증서와 관련된 문제가 있어 해당 CA 인증서를 추가하여 문제를 해결했었다. 물론 HTTP 요청시 인증서 오류를 모두 무시하도록 하는 방법도 있지만, 그 방법은 보안이 취약해지기에 채택하지 않았다.</p>
<p>다만 이렇게 CA 인증서를 추가하는 식으로 해결할 시에는 <code>go test -v</code> 명령어만으로 테스트를 할 수 없다는 문제점이 있었다. 그래서 <a href="/post/docker_for_testing">Docker를 테스트에도 활용할 수 있도록 다음과 같이 Dockerfile을 수정했다.</a></p>
<pre><code class="hljs language-dockerfile"><span class="hljs-keyword">FROM</span> golang:alpine AS base

<span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span>

<span class="hljs-comment"># To avoid tls error from swedu.cau.ac.kr</span>
<span class="hljs-keyword">COPY</span><span class="bash"> digicert-ca.pem /usr/<span class="hljs-built_in">local</span>/share/ca-certificates/digicert-ca.crt</span>
<span class="hljs-keyword">RUN</span><span class="bash"> cat /usr/<span class="hljs-built_in">local</span>/share/ca-certificates/digicert-ca.crt &gt;&gt; /etc/ssl/certs/ca-certificates.crt</span>

<span class="hljs-keyword">COPY</span><span class="bash"> go.mod go.sum ./</span>
<span class="hljs-keyword">RUN</span><span class="bash"> go mod download &amp;&amp; go mod verify</span>

<span class="hljs-keyword">COPY</span><span class="bash"> static ./static</span>
<span class="hljs-keyword">COPY</span><span class="bash"> *.go ./</span>

<span class="hljs-keyword">FROM</span> base AS deployment
<span class="hljs-keyword">RUN</span><span class="bash"> go build -v -o /app/app</span>
<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/app/app&quot;</span>]</span>

<span class="hljs-keyword">FROM</span> base As test

<span class="hljs-keyword">RUN</span><span class="bash"> go <span class="hljs-built_in">test</span> -v ./...</span></code></pre>
<h2 id="서버리스">서버리스</h2>
<p>위와 같이 만들어서 굴리다가 추후 AWS Lambda 함수를 이용한 서버리스로 재작성했다. 이에 대해선 다음 글에서 이어서 작성하도록 하겠다.</p>
</section><div class="Comments_blogComments__GRWmY"></div><nav class="Blog_postNav__ivy8_ Blog_hasBoth__3MRPr"><div class="Blog_leftAnchor__HhzIP"><a href="/post/bidrum_on_rust"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">Rust와 SDL2</div><div class="Blog_subtitle__RRFh7">게임 개발에 Rust를 써보셨나요?</div></div></a></div><div class="Blog_rightAnchor__B9n7B"><a href="/post/retrospective_of_2024"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">2024년의 회고</div><div class="Blog_subtitle__RRFh7">졸업과 취업</div></div></a></div></nav></div></main><footer class="Layout_footer__bKkxe"><div class="Layout_container__z4qWC"><a href="https://www.gnu.org/licenses/agpl-3.0.en.html"><img alt="GNU Affero General License Version 3" src="https://www.gnu.org/graphics/agplv3-with-text-100x42.png" style="height:31px"/></a> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a><br/>Copyrights (C) 2020 LiteHell, All rights reserved.<br/><div class="Layout_visibleOnPrintOnly__UK6Yl">LiteHell&#x27;s Blog - <a href="https://blog.litehell.info">https://blog.litehell.info</a><br/>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.<br/><br/>Url of this article: <a href="https://blog.litehell.info/post/caucalendar_1">https://blog.litehell.info/post/caucalendar_1</a><br/></div><div class="Layout_invisibleOnPrint__rdrDv">Fox Image : Copyrights (C) 2004 Shiretoko-Shari Torurist Association<br/><a href="/license">This blog is free software; For source code and more informations on license and copyrights, Click here.</a><br/><br/>Feeds : <a href="/feed/rss">RSS 2.0</a>,<!-- --> <a href="/feed/atom">Atom 1.0</a>, <a href="/feed/json">Json 1.0</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"metadata":{"title":"학사일정 ICS 서비스 개발기 (上)","subtitle":"Javascript랑 함께 Docker로","author":"LiteHell","date":"2024-09-15T13:06:50.914Z","category":"Dev","series":"puang_network","seriesName":"학사일정/RSS/시간표 미리보기 서비스 개발기"},"rendered":"\u003ch1 id=\"들어가는-글\"\u003e들어가는 글\u003c/h1\u003e\n\u003cp\u003e나는 캘린더 앱을 적극적으로 활용한다. 시간이나 약속을 머릿속으로만 관리하면 잘 잊어버리기 때문에 캘린더 앱을 적극적으로 활용하고 있다.\u003c/p\u003e\n\u003cp\u003e그렇게 캘린더 앱을 적극적으로 쓰다가 대학교에 입학했다. 시험기간이나 수강정정기간 같은 것도 캘린더 앱에 뜨면 좋겠는데 이걸 직접 추가하는 건 귀찮았다. 그래서 \u003ca href=\"https://www.cau.ac.kr/cms/FR_CON/index.do?MENU_ID=590\"\u003e중앙대학교 학사일정 페이지\u003c/a\u003e를 크롤링하는 어플리케이션을 작성했다. 그리고 캘린더 앱과 내 어플리케이션을 연동하는 데에는 iCalendar 파일 포맷을 이용했다.\u003c/p\u003e\n\u003ch2 id=\"icalendar\"\u003eiCalendar\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://calendar.google.com\"\u003eGoogle Calendar\u003c/a\u003e나 \u003ca href=\"https://outlook.com\"\u003eMS Outlook\u003c/a\u003e, 혹은 필자가 이용하는 \u003ca href=\"https://www.fastmail.com\"\u003eFastMail\u003c/a\u003e에서는 캘린더 기능을 제공한다. 이 캘린더 서비스들은 기본적으로 특정한 iCalendar 주소를 구독하는 기능을 지원한다. 즉, 다시 말해 필자가 구글 캘린더나 아웃룩에 iCalendar 파일 주소를 추가하면, 구글 캘린더나 아웃룩 서버가 주기적으로 iCalendar 주소에 접속해 동기화한다.\u003c/p\u003e\n\u003cp\u003eiCalendar 파일은 다음과 같은 형식으로 되어있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBEGIN:VCALENDAR\nVERSION:2.0\nTIMEZONE-ID:Asia/Seoul\nX-WR-TIMEZONE:Asia/Seoul\nX-WR-CALNAME:중앙대학교 학사일정\nX-WR-CALDESC:calendar.puang.network에서 제공하는 중앙대학교 학사일정\nCALSCALE:GREGORIAN\nPRODID:adamgibbons/ics\nMETHOD:PUBLISH\nX-PUBLISHED-TTL:PT1H\nBEGIN:VTIMEZONE\nTZID:Asia/Seoul\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Seoul\nX-LIC-LOCATION:Asia/Seoul\nBEGIN:STANDARD\nTZOFFSETFROM:+0900\nTZOFFSETTO:+0900\nTZNAME:KST\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\nBEGIN:VEVENT\nUID:552361268d864ef42fff1bee5d295e073f7ab2b2@calendar.puang.network\nSUMMARY:신정(공휴일)\nDTSTAMP:20240825T081930Z\nDTSTART;TZID=Asia/Seoul;VALUE=DATE:20220101\nEND:VEVENT\nBEGIN:VEVENT\nUID:eb57cfcaf7345c4ad83d1e7537dd81016db2d8a7@calendar.puang.network\nSUMMARY:2022년 1학기 재입학 원서접수\nDTSTAMP:20240825T081930Z\nDTSTART;TZID=Asia/Seoul;VALUE=DATE:20220103\nDTEND;TZID=Asia/Seoul;VALUE=DATE:20220107\nEND:VEVENT\nEND:VCALENDAR\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같은 식으로 iCalendar 아이템(\u003ccode\u003eVCALENDAR\u003c/code\u003e) 속에 여러 일정(\u003ccode\u003eVEVENT\u003c/code\u003e)들이 나열되어 있다. iCalendar 형식은 할일(\u003ccode\u003eVTODO\u003c/code\u003e)이나 일기(\u003ccode\u003eVJOURNAL\u003c/code\u003e)도 지원하지만 이 글에서는 다루지 않는다.\u003c/p\u003e\n\u003ch2 id=\"koajs를-이용한-첫-버전\"\u003e\u003ca href=\"https://koajs.com/\"\u003eKoa.js\u003c/a\u003e를 이용한 첫 버전\u003c/h2\u003e\n\u003cp\u003e첫 버전은 \u003ca href=\"https://koajs.com/\"\u003eKoa 프레임워크\u003c/a\u003e를 이용하여 간단하게 작성했다. 원래 이전에는 \u003ca href=\"https://expressjs.com/\"\u003eexpress\u003c/a\u003e를 썼었는데, express는 \u003ccode\u003easync\u003c/code\u003e 함수 핸들러가 바로 지원되지 않아서 약간 귀찮다는 단점이 있었기에 Koa 프레임워크를 이용했다.\u003c/p\u003e\n\u003cp\u003e이 프로그램에서 중요한 것은 iCalendar 파일을 제공하는 것이다. 따라서 그 외의 요소는 모두 부수적인 것이다. 그렇기에 프론트엔드는 다음과 같이 디자인이 극단적으로 되어있어도 상관없었다. (사진은 첫 커밋 버전의 메인 페이지이다.)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/puang_network/caucalendar_first_commit_html.png\" alt=\"첫 커밋 버전의 caucalendar.online 프로젝트 프론트엔드\"\u003e\u003c/p\u003e\n\u003cp\u003e다만 그래도 위처럼 만드는 건 좀 심하니 \u003ca href=\"https://bulma.io\"\u003ebulma CSS 프레임워크\u003c/a\u003e를 이용해 아래와 같이 간단히 꾸몄다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/puang_network/caucalendar_bulma_frontend.png\" alt=\"bulma 프레임워크를 이용한 caucalendar.online 프로젝트 프론트엔드\"\u003e\u003c/p\u003e\n\u003cp\u003e이때가 2019년 5~6월쯤이였다. 이때의 구조도는 다음과 같다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/puang_network/caucalendar_vps_nodejs.png\" alt=\"서비스 구조도\"\u003e\u003c/p\u003e\n\u003cp\u003e당시 가상서버에서는 여러 웹서비스가 구동되고 있었기에, Host를 확인하여 알맞은 웹서비스로 트래픽을 전달해야 했다. 따라서 Nginx로 리버스 프록시가 동작하고 있었다.\u003c/p\u003e\n\u003cp\u003e위 사진에서 \u003ca href=\"https://pm2.io\"\u003ePM2\u003c/a\u003e는 프로세스가 꺼지면 다시 켜주는 역할을 한다. \u003ca href=\"https://github.com/librewiki/liberty-engine\"\u003e리브레위키의 리버티엔진\u003c/a\u003e에서 쓰길래 써봤다.\u003c/p\u003e\n\u003ch2 id=\"크롤링-스크립트-분리\"\u003e크롤링 스크립트 분리\u003c/h2\u003e\n\u003cp\u003e초기에는 크롤링을 분리하기 귀찮아서, 그냥 요청이 들어올 때마다 학교 홈페이지에 접속해 학사일정 iCalendar 파일(이하 \u0026quot;ics 파일\u0026quot;)을 제공했다. 그랬더니 어느순간 학교에서 서버 ip를 차단했다. 이게 2019년 11월 쯤의 일이였다.\u003c/p\u003e\n\u003cp\u003e그래서 크롤링하는 코드를 별도의 파일로 분리하고, crontab을 이용해 크롤링 스크립트가 주기적으로 실행되게 했다. 크롤링된 데이터는 \u003ca href=\"https://sequelize.org/\"\u003eSequelize\u003c/a\u003e ORM을 이용해 저장했다.\u003c/p\u003e\n\u003ch2 id=\"github-action\"\u003eGitHub Action\u003c/h2\u003e\n\u003cp\u003e학사일정 서비스에 버그가 생겼다고 캘린더 앱에서 잘 보이던 일정이 갑자기 사라지진 않는다. 그래서 동작에 이상이 생겨도 기존에 쓰던 사람들은 티가 잘 안난다.\u003c/p\u003e\n\u003cp\u003e그래서 동작이 정상적으로 이루어지는 지 주기적으로 확인하기 위해 다음과 같이 GitHub Action을 추가했다.\n푸시나 커밋시가 아닌 특정 주기에 따라 반복되는 GitHub CI로 테스트가 주기적으로 이루어지도록 했다.\u003c/p\u003e\n\u003cp\u003e따라서 이를 통해 학교 홈페이지의 갑작스런 디자인/API 변경에도 대응할 수 있었다. \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yml\"\u003e\u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eand\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etest\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003eon:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eschedule:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecron:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;0 19 * * *\u0026#x27;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003epush:\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003ejobs:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ebuild:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eruns-on:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu-latest\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003esteps:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eactions/checkout@v3\u003c/span\u003e\n\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuild\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edocker\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ebuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--target\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etest\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e푸시나 커밋시가 아닌 cron으로 GitHub CI를 추가하여 학교 홈페이지의 갑작스런 디자인/API 변경에도 대응할 수 있도록 했다.\u003c/p\u003e\n\u003ch2 id=\"도커라이징\"\u003e도커라이징\u003c/h2\u003e\n\u003cp\u003e개인서버에서 돌아가던 서비스들을 다 도커 컨테이너에 감싸는 작업을 했었다. 그때 학사일정 ics 서비스도 도커 컨테이너로 감쌌다. crontab을 이용해 따로 돌아가던 크롤링 스크립트는 어플리케이션에 다시 집어넣어서, 어플리케이션 실행시 크롤링이 자동으로 주기적으로 실행되도록 수정했다. Docker에서 crontab을 쓰려면 약간 귀찮기 때문이다.\u003c/p\u003e\n\u003cp\u003e처음에는 \u003ccode\u003enode:14\u003c/code\u003e 도커 이미지를 기반으로 썼는데 값싼 가상서버에서 쓰기에는 디스크를 너무 많이 차지했다. 그래서 나중에 Alpine Linux 기반 도커를 기반으로 바꿨다. Alpine Linux 기반 이미지를 쓰니 디스크 소비량을 줄일 수 있었다. 이때가 2021년 2~3월인가 그랬을 것이다.\u003c/p\u003e\n\u003ch2 id=\"go-언어로의-재작성\"\u003eGo 언어로의 재작성\u003c/h2\u003e\n\u003cp\u003e그렇게 Javascript로 작성해서 잘 쓰다가 문득 이런 생각이 들었다. \u0026#39;Go를 쓰면 더 빠르지 않을까?\u0026#39; Javascript는 인터프리터 언어이고, Go는 컴파일 언어이니, 알고리즘의 효율성이 유사하다는 가정하에 Go가 더 빠를 수도 있지 않을까란 생각이 들었다. 물론 Go 언어를 한 번 써보고 싶은 생각도 없진 않았다.\u003c/p\u003e\n\u003cp\u003e그래서 Go 언어로 학사일정 서비스를 재작성했다. 크롤러는 다음과 같이 고루틴을 이용하여 비동기적으로 동시에 구동되도록 했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;time\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecrawlWorker\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e {\n        time.Sleep(time.Hour * \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n        fetchAllYears()\n    }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003esetupCrawller\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ego\u003c/span\u003e crawlWorker()\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"docker를-이용한-테스팅\"\u003eDocker를 이용한 테스팅\u003c/h2\u003e\n\u003cp\u003eDigiCert CA 인증서와 관련된 문제가 있어 해당 CA 인증서를 추가하여 문제를 해결했었다. 물론 HTTP 요청시 인증서 오류를 모두 무시하도록 하는 방법도 있지만, 그 방법은 보안이 취약해지기에 채택하지 않았다.\u003c/p\u003e\n\u003cp\u003e다만 이렇게 CA 인증서를 추가하는 식으로 해결할 시에는 \u003ccode\u003ego test -v\u003c/code\u003e 명령어만으로 테스트를 할 수 없다는 문제점이 있었다. 그래서 \u003ca href=\"/post/docker_for_testing\"\u003eDocker를 테스트에도 활용할 수 있도록 다음과 같이 Dockerfile을 수정했다.\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dockerfile\"\u003e\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e golang:alpine AS base\n\n\u003cspan class=\"hljs-keyword\"\u003eWORKDIR\u003c/span\u003e\u003cspan class=\"bash\"\u003e /app\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# To avoid tls error from swedu.cau.ac.kr\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e digicert-ca.pem /usr/\u003cspan class=\"hljs-built_in\"\u003elocal\u003c/span\u003e/share/ca-certificates/digicert-ca.crt\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e cat /usr/\u003cspan class=\"hljs-built_in\"\u003elocal\u003c/span\u003e/share/ca-certificates/digicert-ca.crt \u0026gt;\u0026gt; /etc/ssl/certs/ca-certificates.crt\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e go.mod go.sum ./\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e go mod download \u0026amp;\u0026amp; go mod verify\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e static ./static\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e *.go ./\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e base AS deployment\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e go build -v -o /app/app\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;/app/app\u0026quot;\u003c/span\u003e]\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e base As test\n\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e go \u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e -v ./...\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"서버리스\"\u003e서버리스\u003c/h2\u003e\n\u003cp\u003e위와 같이 만들어서 굴리다가 추후 AWS Lambda 함수를 이용한 서버리스로 재작성했다. 이에 대해선 다음 글에서 이어서 작성하도록 하겠다.\u003c/p\u003e\n"},"articleId":"caucalendar_1","series":[{"title":"학사일정 ICS 서비스 개발기 (上)","articleId":"caucalendar_1"}],"seriesName":"학사일정/RSS/시간표 미리보기 서비스 개발기","previousPost":{"name":"bidrum_on_rust","metadata":{"title":"Rust와 SDL2","subtitle":"게임 개발에 Rust를 써보셨나요?","author":"LiteHell","date":"2024-08-11T14:35:24.968Z","category":"Dev","series":"bidrum","tags":["Game"]},"rendered":"\u003ch1 id=\"들어가는-글\"\u003e들어가는 글\u003c/h1\u003e\n\u003cp\u003e\u003cem\u003e※ 참고: 이 시리즈의 글은 시간순 작성을 최대한 목표하고 있으나, 글의 짜임새나 가독성을 위해 미리시점이나 과거시점의 이야기가 섞이거나 순서가 일부 달라질 수 있습니다.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e내가 만들고 싶은 게임은 아케이드 리듬게임이였다. 마침 내 방에 라즈베리 파이(4B Rev 1.2)가 있어서, 라즈베리 파이로 게임을 구동하고 싶었다. Unity나 Unreal Engine으로 만든 게임이 라즈베리 파이 위에서 돌아갈까? 아마도 돌아가지 않을 것이다. 실제로 돌려본 적은 없지만 라즈베리 파이가 성능이 좋은 편은 아니니까.\u003c/p\u003e\n\u003cp\u003e그래서 필자는 마침 \u003ca href=\"https://www.rust-lang.org/\"\u003eRust\u003c/a\u003e 프로그래밍 언어를 한 번 써보고 싶은 생각도 있었기에, Rust로 직접 게임을 만들어보기로 결심했다. 게임 엔진을 쓰면 나중에 게임이 유명해졌을 때 라이선스비를 내야 한다는 것도 하나의 이유였다. (좀 과한 김칫국이긴 하지만...) 그래서 유니티니 언리얼이니 하는 게임 엔진을 쓰지 않고 Rust로 기초부터 쌓아올리기 시작했다.\u003c/p\u003e\n\u003ch1 id=\"sdl2를-이용한-게임-프로그래밍\"\u003eSDL2를 이용한 게임 프로그래밍\u003c/h1\u003e\n\u003cp\u003eRust에는 \u003ca href=\"https://github.com/Rust-SDL2/rust-sdl2\"\u003erust-sdl2\u003c/a\u003e라는 라이브러리 바인딩이 있다. SDL2는 오디오, 키보드, 마우스, 그래픽, 조이스틱을 다를 수 있게 하는 크로스플랫폼 라이브러리이다. 즉, 그래픽이나 마우스 등에 대한 Direct3D/OpenGL 등의 운영체제/플랫폼 종속적인 API를 추상화하고 단일한 인터페이스로 통일하여 크로스 플랫폼으로 개발할 수 있게 하는 라이브러리이다.\u003c/p\u003e\n\u003cp\u003e따라서 SDL2를 이용하면 Mac OS X/Windows/Linux에서 크로스플랫폼으로 실행할 수 있고, 라이브러리도 별로 무겁지 않다. 그래서 SDL2를 이용하게 됐다.\u003c/p\u003e\n\u003ch2 id=\"sdl2\"\u003eSDL2\u003c/h2\u003e\n\u003cp\u003eSDL2는 rust-sdl 레포 내의 예제 코드를 보면서 따라하면 사용하기 쉽다. SDL2는 먼저 Window(창)을 만든 뒤, Window의 Canvas에 원하는 것을 그리고 렌더링하고 클리어하는 것을 반복한다. 이를 순서대로 나타내면 다음과 같다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e(A) Window 생성 → (B) Window의 Canvas를 Clear한다 → (C) Canvas에 뭔가를 그린다. → (D) Window의 Canvas를 Present한다. → (E) 화면이 표시한다. → (F) B로 되돌아간다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e학부 수준의 컴퓨터그래픽스 수업을 들었거나 OpenGL 프로그래밍을 조금이라도 맛보았다면 매우 이해하기 쉬울 것이다.\u003c/p\u003e\n\u003cp\u003eSDL2는 키보드나 조이스틱 인식을 위한 EventPump 기능을 제공한다. 키보드 인풋이 들어오면 EventPump에 Event가 생성된다. 게임은 이 EventPump에 Event가 있는지 확인하여 만약 Event가 있다면 해당 Event의 데이터를 활용해 키보드 인풋을 처리할 수 있다. 게임 특성상 이 EventPump은 디버깅 용으로만 주로 이용됐다.\u003c/p\u003e\n\u003ch2 id=\"gamecommoncontext\"\u003eGameCommonContext\u003c/h2\u003e\n\u003cp\u003e위에서 언급한 바에 같이 그래픽을 렌더링하기 위해서는 Canvas 객체에 대한 접근이 필요하다. 그래서 초기 게임 초기화시 Canvas와 Window, SDL Context 등을 담은 GameCommonContext 객체를 만들고 이를 함수간에 서로 주고받는 형태로 빠르게 게임을 구현했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e kira::manager::AudioManager;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e sdl2::{render::Canvas, EventPump, video::Window};\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eGameCommonContext\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) coins: \u003cspan class=\"hljs-built_in\"\u003eu32\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) price: \u003cspan class=\"hljs-built_in\"\u003eu32\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) sdl_context: sdl2::Sdl,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) audio_manager: AudioManager,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) canvas: Canvas\u0026lt;Window\u0026gt;,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) event_pump: EventPump,\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(속성은 나중에 게임이 개발되면 될 수록 더 늘어난다.)\u003c/p\u003e\n\u003cp\u003e그리고 이는 추후 대규모 리팩토링으로 Rust의 특징을 온몸으로 깨닫는 계기가 됐다.... 나중에 소유권이랑 lifetime 문제가 미친 듯이 터져나와서 그거 씨름하느라 엄청 고생하게 됐다.\u003c/p\u003e\n\u003ch2 id=\"rust에서의-시리얼-통신\"\u003eRust에서의 시리얼 통신\u003c/h2\u003e\n\u003cp\u003e게임을 장구 하드웨어와 연동하기 위해서는 시리얼 통신이 필요하다.\u003c/p\u003e\n\u003cp\u003eArduino Leonardo 등 HID 에뮬레이션을 지원하는 보드가 있으면 장구 하드웨어에서 키보드 인풋을 주도록 할 수도 있다. 그런데 당장 내 방에 있는 게 Arduino UNO 호환보드(흔히 \u0026quot;짭두이노\u0026quot;라고 불리는 보드)밖에 없었다. 그래서 시리얼 통신으로 구현했다. 나중의 미래에 레오나르도 보드를 사서 키보드 인풋으로도 구현해보긴 했는데.... 딱따구리마냥 장구 채를 갖다대기만 해도 장구 채를 미친듯이 연타한 것마냥 동작하는 버그가 있어서 그냥 시리얼 통신을 계속 쓰게 됐다.\u003c/p\u003e\n\u003cp\u003eRust에서는 시리얼 통신을 어떻게 할까? 고맙게도 \u003ca href=\"https://docs.rs/serialport/latest/serialport/\"\u003eserialport\u003c/a\u003e라는 라이브러리가 있다. 이를 이용해 장구 하드웨어와의 시리얼 통신 코드를 작성했다. 그리고 장구 하드웨어로부터 인풋을 읽는 코드를 멀티쓰레딩으로 분리하고 \u003ccode\u003eAtomicU8\u003c/code\u003e을 이용하여 게임 쓰레드와 인풋 쓰레드 간에 장구 인풋 상태를 서로 공유했다.\u003c/p\u003e\n\u003cp\u003e왜 뜬끔없이 \u003ccode\u003eAtomicU8\u003c/code\u003e이냐? 장구 컨트롤러의 상태를 나타내는 데에는 4개의 비트만 있으면 충분하다. 그래서 컨트롤러는 1바이트의 데이터를 무한히 연속적으로 보낸다. 이 1바이트를 해석하는 코드는 다음과 같다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eparse_janggu_bits\u003c/span\u003e\u003c/span\u003e(bits: \u003cspan class=\"hljs-built_in\"\u003eu8\u003c/span\u003e) -\u0026gt; JangguState {\n    JangguState {\n        궁채: \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::채편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::북편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n        },\n        북채: \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::채편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::북편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n        },\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e장구 컨트롤러와 연동하는 쓰레드는 컨트롤러로부터 시리얼 통신으로 받은 데이터를 바로 \u003ccode\u003eGameCommonContext\u003c/code\u003e 개체의 \u003ccode\u003ejanggu_bits_ptr\u003c/code\u003e 필드에 저장한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ... (생략) ....\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eGameCommonContext\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-comment\"\u003e// ... (생략) ...\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) janggu_bits_ptr: Arc\u0026lt;AtomicU8\u0026gt;,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e GameCommonContext {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eread_janggu_state\u003c/span\u003e\u003c/span\u003e(\u0026amp;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) -\u0026gt; JangguState {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e parse_janggu_bits(\n            \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.janggu_bits_ptr\n                .load(std::sync::atomic::Ordering::Relaxed),\n        );\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e게임 쓰레드에서 장구의 상태를 확인할 때는 \u003ccode\u003eread_janggu_state\u003c/code\u003e 메소드를 이용한다.\u003c/p\u003e\n\u003cp\u003e추후 미래에 \u003ccode\u003eAtomicU8\u003c/code\u003e을 없애고 Product-Consumer Lock으로 \u003ccode\u003eJangguState\u003c/code\u003e 객체를 직접 공유해보기도 했는데, 렉이 너무 심해서 그냥 \u003ccode\u003eAtomicU8\u003c/code\u003e을 계속 쓰게 됐다.\u003c/p\u003e\n\u003ch1 id=\"결론\"\u003e결론\u003c/h1\u003e\n\u003cp\u003eRust를 이용한 게임 개발은 초창기에는 할만했는데 뒤로 갈수록 어려웠다. 소유권, 대여, lifetime 문제를 해결하느라 골머리를 참 많이 썩었다. 그래서 결론적으로 짧은 기간 안에 게임을 개발해야 한다면 Rust는 별로 좋은 선택이 아니지 않을까라는 생각이 들었다.\u003c/p\u003e\n"},"nextPost":{"name":"retrospective_of_2024","metadata":{"title":"2024년의 회고","subtitle":"졸업과 취업","author":"LiteHell","date":"2024-12-27T10:41:06.311Z","category":"Life","tags":["Retrospective"]},"rendered":"\u003ch1 id=\"들어가는-글\"\u003e들어가는 글\u003c/h1\u003e\n\u003cp\u003e올해는 뭔가 많은 일이 있었다.... 되게 바빴지만 동시에 많은 것들을 이루어낸 해이기도 했다. 회고를 쓰면서 지난날들을 되돌아보려 한다.\u003c/p\u003e\n\u003ch2 id=\"하반기\"\u003e하반기\u003c/h2\u003e\n\u003cp\u003e하반기에는 인턴십을 하고 학업을 마무리했다.\u003c/p\u003e\n\u003ch3 id=\"하계방학-인턴십\"\u003e하계방학 인턴십\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://iacf.cau.ac.kr/\"\u003e중앙대학교 현장실습지원센터\u003c/a\u003e를 통해 여러 인턴십에 지원했다. LG CNS 채용 연계형 인턴십과 카카오 채용 연계형 겨울 인턴십, 그리고 \u003ca href=\"http://www.shuru.co.kr\"\u003e주식회사 슈르\u003c/a\u003e의 산학연계 인턴십에 지원했다.\u003c/p\u003e\n\u003cp\u003eLG CNS 채용 전형은 서류, 코딩테스트, 2:2 비대면 면접 순으로 진행됐고, 카카오 채용 전형은 서류, 코딩테스트, 3:1 대면 면접으로 진행됐다. 둘 다 면접까지는 갔으나 아쉽게도 불합격했다. LG CNS는 같이 면접 본 다른 지원자분께서 스펙이 너무나 뛰어났고, 카카오 인턴십은 면접이 서툴러서 잘못 본 것이 원인인 것 같다. 카카오는 대면면접을 볼 때 대기실이 따로 있고, 면접비로 50,000원 상당의 카카오페이포인트와 춘식이 핫팩을 주는 점이 좋았다.\u003c/p\u003e\n\u003cp\u003e주식회사 슈르는 \u003ca href=\"https://placement.cau.ac.kr\"\u003e중앙대학교 현장실습 통합관리 시스템\u003c/a\u003e을 통해 지원했다. 전형은 서류, 1:1 비대면 면접 순으로 진행됐다. 면접은 웹과 관련된 기술면접으로만 이루어졌다. 회사가 가산디지털단지역에 있어서 학교 기숙사에서 출퇴근하기 매우 편했고, 사람들이 되게 좋았다. 출퇴근은 자유로운 편이었으며, 휴가 사용은 완전히 자유로웠다. 포괄임금제이지만, 초과근무시 그에 상응하는 보상휴가를 지급해준다.\u003c/p\u003e\n\u003cp\u003e회사에서는 \u003ca href=\"https://www.youtube.com/watch?v=6WZ5jjVXeF0\"\u003e고인물테스트\u003c/a\u003e의 프론트엔드를 개발했다. 그때 회사에 나를 포함하여 인턴이 3명 있었는데, 내가 백엔드를 하면 다른 분께서 프론트 개발하는 데 우여곡절이 많을 것 같아서 그냥 내가 프론트엔드를 맡았다.\u003c/p\u003e\n\u003cp\u003e처음 회사 직원분께서 사이트가 매우 간단할 것으로 예측하고 그냥 HTML + CSS + Javascript 조합으로 빠르게 만들자고 제안하셨다. 초반 기획서도 그렇게 거창하지 않았기에 알겠다고 하고 HTML + CSS + Javascript 조합으로 만들었다. 그러나 기획서가 가면 갈수록 수정되면서 복잡해졌고, 이에 나는 개발 편의성을 위해 Javascript 코드를 Typescript 코드로 재작성하고 Webpack을 이용한 빌드 시스템을 구축했다.\u003c/p\u003e\n\u003cp\u003e가장 인상 깊었던 것은 좌우 무한 스크롤링을 구현하라는 요구사항이었다. 처음에는 웹브라우저에서 제공하는 스크롤바를 최대한 활용하려 했는데 사파리에서 자꾸만 버그가 나서 결국 그냥 바퀴를 재발명했다. 마우스랑 터치 이벤트를 받아 이동량을 계산하고 계산한 값에 따라 \u003ccode\u003erequestAnimationFrame\u003c/code\u003e으로 자식 요소의 위치를 이동시킴으로써 스크롤링을 직접 구현했다. 가장 하기 싫은 방법이었지만 결국 어쩔 수 없었다. 사소한 버그는 있었지만, 나름 그럴싸하게 동작했다. (이에 대해서는 추후 별도의 글로 쓸 예정)\u003c/p\u003e\n\u003cp\u003e학교 프로젝트에서 디자이너나 기획자랑 협업할 일이 없었는데 회사에서 처음으로 기획자, 디자이너, 실무자와 같이 협업했다. 그 과정에서 슬랙이랑 노션도 적극적으로 써보고 스타트업이 어떻게 돌아가는지에 대해 많은 걸 배울 수 있어 좋은 경험이었다.\u003c/p\u003e\n\u003ch3 id=\"2024-1학기\"\u003e2024-1학기\u003c/h3\u003e\n\u003ch4 id=\"학교-수업\"\u003e학교 수업\u003c/h4\u003e\n\u003cp\u003e2024-1학기에는 정보보호이론, 네트워크응용설계, 신호및시스템, 데이타베이스시스템, 캡스톤디자인(2)를 수강했다. 임베디드 관련 과목을 듣고 싶었는데 담당 교수님이 안식년인지라 어쩔 수 없이 신호및시스템을 대신 수강하게 됐다.\u003c/p\u003e\n\u003cp\u003e정보보호이론은 DES, AES, RSA, ElGamel와 같은 암호에 관한 내용을 배웠다, 한 번 제대로 배워보고 싶었던 내용이라서 재밌었다. 네트워크응용설계는 네트워크 레이어 3~7을 Bottom-Top으로 배운다. 데이타베이스시스템은 DB 시스템의 내부구조에 대해 가르친다. 신호및시스템은 푸리에 변환에 대해 맛보기로 가르쳐준다. 모두 다 좋은 내용이어서 만족스러웠다.\u003c/p\u003e\n\u003ch4 id=\"바이드럼캡스톤디자인\"\u003e바이드럼(캡스톤디자인)\u003c/h4\u003e\n\u003cp\u003e중앙대학교는 캡스톤디자인을 2번 해야 한다. 2023-2학기에는 알고모여를 했었고 (\u003ca href=\"/post/retrospective_of_2023\"\u003e관련 글\u003c/a\u003e) 이제 2024-1학기에도 프로젝트를 해야 했다.\u003c/p\u003e\n\u003cp\u003e팀 인원은 다행스럽게도 2023-2학기의 구성 그대로 가기로 결정돼서 주제만 빠르게 결정되면 됐다. 이때 리듬 게임을 만들 것을 다시 한번 더 제안했다. 말로만 제안하면 또 반대를 받을 게 예상돼서 이번에는 프로토타입을 미리 만들어 팀원들을 설득했다. 프로토타입에 관한 이야기는 \u003ca href=\"/post/bidrum_and_janggu_controller_prototyping\"\u003e이 글\u003c/a\u003e을 참고하라.\u003c/p\u003e\n\u003cp\u003e주제부터 결과물까지 모든 것이 어그로였다. (중앙대에서 졸업작품으로 아케이드 리듬 게임을 하는 용자는 매우 드물다) 그래서 이왕 어그로 끄는 김에 최종 발표도 어그로로 하기로 했다. 한솜미술센터에서 \u003ca href=\"https://thehansom.com/shop/item.php?it_id=1410694674\"\u003e사물놀이복\u003c/a\u003e을 빌려서 최종 발표를 했다. 결과는 매우 성공적이었고 웃음을 참지 못하던 조교의 표정을 아직도 잊을 수가 없다.\u003c/p\u003e\n\u003ch2 id=\"상반기\"\u003e상반기\u003c/h2\u003e\n\u003cp\u003e상반기에는 본격적인 사회인이 됐다.\u003c/p\u003e\n\u003ch3 id=\"첫-정규직-직장\"\u003e첫 정규직 직장\u003c/h3\u003e\n\u003cp\u003e하계방학에 인턴십을 진행한 주식회사 슈르에 정규직으로 입사하게 됐다. 내가 학업에 열중하는 동안 회사는 여러 우여곡절을 겪으며 체계가 더 단단해졌다. 회사에서 \u003ca href=\"https://shumaru.shop\"\u003e슈마루\u003c/a\u003e의 백오피스 프론트엔드 개발을 주로 맡았었다. 스타트업 기업에서 근무하면서 스타트업이 어떻게 돌아가는 지를 인턴으로 근무할 때보다 더 자세히 알 수 있었다. 다른 현직 개발자와 협업도 처음으로 해봤지만, 개인적으로 시간에 쫓겨 개발하느라 기술적인 성장을 많이 이루지 못한 것 같다. 그와는 별개로 Firebase를 본격적으로 처음 써봤는데 꽤 편리해서 좋았었다.\u003c/p\u003e\n\u003cp\u003e되게 열심히 일했다. 학교로 졸업사진 찍으러 가다 회사에 큰 일 터져서 바로 헐레벌떡 회사로 달려가 고쳐도 보고... 여러 추억을 쌓았다.\u003c/p\u003e\n\u003ch3 id=\"이직\"\u003e이직\u003c/h3\u003e\n\u003cp\u003e슈르를 다니다가 더 좋은 직장에서 더 높은 연봉의 오퍼를 받아 이직하게 됐다. 아직 모든 것이 낯설고 앞으로 내가 잘할 수 있는지 두렵지만 어찌 됐든 잘 적응해서 어서 빨리 성취를 이루고 싶다.\u003c/p\u003e\n\u003ch3 id=\"자취\"\u003e자취\u003c/h3\u003e\n\u003cp\u003e직장을 옮기니 집과 직장 사이의 거리가 더 멀어져 결국 자취를 하게 됐다. 수도권 집값 너무 비싸서 볼 때마다 아깝다는 생각이 들지만, 그래도 어쩔 수 없다. 집값도 비싸면서 이상한 집은 얼마나 많은지... 그래도 자취를 하니 직장까지 가기가 너무 편해서 만족스럽다. 특히 자취를 한 번도 안 했다가 이제서야 진정한 프라이버시를 얻게 된 점이 너무 좋다.\u003c/p\u003e\n\u003ch2 id=\"현재-근황\"\u003e현재 근황\u003c/h2\u003e\n\u003ch3 id=\"개인서버\"\u003e개인서버\u003c/h3\u003e\n\u003cp\u003e지인으로부터 안 쓰는 데스크톱 본체를 얻게 됐다. 이 본체에 \u003ca href=\"https://www.proxmox.com\"\u003eProxmox\u003c/a\u003e를 설치해 개인 서버를 구축했다. 이제 NAS를 설치하려고 이것저것 알아보고 있는데 \u003ca href=\"https://www.truenas.com\"\u003eTrueNAS\u003c/a\u003e는 제대로 쓰려면 하드웨어 패스쓰루를 해야 한다고 해서 내키지 않고, \u003ca href=\"https://www.openmediavault.org/\"\u003eopenmediavault\u003c/a\u003e는 웹 파일 브라우저 UI가 뭔가 마음이 들지 않아서... 그냥 내가 직접 만들까도 생각하고 있다.\u003c/p\u003e\n\u003ch3 id=\"tor-릴레이\"\u003eTor 릴레이\u003c/h3\u003e\n\u003cp\u003e개인적으로 고대역폭 Tor 릴레이를 구축해보고 싶다. 그래서 \u003ca href=\"https://www.kinx.net\"\u003eKINX\u003c/a\u003e에 관련 문의를 해봤는데 추후 견적이 어떻게 나오는가에 따라서 안 할 수도 있다.\u003c/p\u003e\n\u003ch3 id=\"프로젝트-나무위키-이야기\"\u003e프로젝트 \u0026quot;나무위키 이야기\u0026quot;\u003c/h3\u003e\n\u003cp\u003e나무위키의 초반기 역사에 대한 책을 쓰고 싶어서 올해 중반쯤에 프로젝트를 결성했는데, 바쁘게 살다 보니 그 새 까먹어서 이제서야 본격적인 시동을 걸게 됐다. 사람들이 슬슬 기억이 안 나기 시작해서 원할하게 될지는 모르겠지만, 어쨌든 잘 이루어졌으면 좋겠다.\u003c/p\u003e\n\u003ch3 id=\"쓰지-못한-글들\"\u003e쓰지 못한 글들\u003c/h3\u003e\n\u003cp\u003e아직 못 쓴 글들은 다음과 같다. 학생자치후기는 특성상 검열이 많이 될 수 있어서 재미가 없을 수도 있다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e학사일정 ICS 서비스 개발기 (下)\u003c/li\u003e\n\u003cli\u003e바이드럼 관련 글들\u003c/li\u003e\n\u003cli\u003e학생자치후기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아랫글들은 잠깐 쓰다 말았는데 완성 안 하고 그냥 삭제할 수도 있다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e리눅스에서 zapret 써서 인터넷 검열 우회하는 방법\u003c/li\u003e\n\u003cli\u003e유닉스 도메인 소켓 관련 커널 코드 분석\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아랫글은 쓰다 말았는데 타이밍을 놓쳐서 그냥 삭제할 계획이다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e졸업 후기\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"마무리\"\u003e마무리\u003c/h1\u003e\n\u003cp\u003e이제 연말이 얼마 남지 않았다. 다음 해에는 다들 즐거운 일만이 있기를!\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"caucalendar_1"},"buildId":"ceNNFcdZkyahVzhygnwwc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>