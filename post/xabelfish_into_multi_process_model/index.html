<!doctypehtml><html lang=ko><link href=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 rel=icon><link href=https://blog.litehell.info/post/xabelfish_into_multi_process_model rel=canonical><link href=https://blog.litehell.info/post/xabelfish_into_multi_process_model hreflang=ko rel=alternate><link href=https://blog.litehell.info/post/xabelfish_into_multi_process_model hreflang=en rel=alternate><link title="RSS 2.0 Feed for LiteHell's blog"href=https://blog.litehell.info/feed/rss rel=alternate type=application/rss+xml><link title="Atom 1.0 Feed for LiteHell's blog"type="	application/atom+xml"href=https://blog.litehell.info/feed/atom rel=alternate><link title="Json 1.0 Feed for LiteHell's blog"href=https://blog.litehell.info/feed/json rel=alternate type=application/feed+json><link href=https://esm.sh/@wooorm/starry-night@3/style/core.css rel=stylesheet><link href=https://esm.sh/@wooorm/starry-night@3/style/both.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap rel=stylesheet><meta content="XabelFish 개발기 - 멀티 프로세스 모델"property=og:title><meta content="귀찮다면 돌아가라"property=og:description><meta content=ko property=og:locale><meta content=blog property=og:type><meta content="LiteHell의 블로그"property=og:site_name><meta content=https://blog.litehell.info/post/xabelfish_into_multi_process_model property=og:url><meta content=https://blog.litehell.info/xabelfish_and_pipewire/screencast.png property=og:image><meta content=width=device-width,initial-scale=1 name=viewport><style>html,body{margin:0;padding:0;font-family:Noto Sans KR,sans-serif}</style><title>LiteHell의 블로그 - XabelFish 개발기 - 멀티 프로세스 모델</title><body><link as=image href=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 rel=preload><link as=image href=https://i.creativecommons.org/l/by-sa/4.0/88x31.png rel=preload><link as=image href=https://www.gnu.org/graphics/agplv3-with-text-100x42.png rel=preload><style data-emotion="css 1nfpw07">.css-1nfpw07{--top-padding:max(40px,3rem);--vertical-padding:max(20px,2em);padding:var(--top-padding)var(--vertical-padding)0em var(--vertical-padding);box-sizing:border-box;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;align-items:center;min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-1nfpw07>*{width:100%}@media (width>=1024px){.css-1nfpw07>*{max-width:960px}}.css-1nfpw07 main{-webkit-flex:1;-ms-flex:1;flex:1}.css-1nfpw07 footer{border-top:1px solid #727272;margin:2rem 0 0;padding:1.5rem 0}</style><div class=css-1nfpw07><style data-emotion="css 1fkv74n">.css-1fkv74n{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;align-items:center;gap:2rem;padding-bottom:1.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}@media (width<=25rem){.css-1fkv74n{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}}.css-1fkv74n .profileImg a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.css-1fkv74n .profileImg img{border-radius:4rem;width:8rem;height:8rem;box-shadow:0 3px 6px #00000029,0 3px 6px #0000003b}.css-1fkv74n .title h1{word-break:keep-all;margin:0 0 .5rem;padding:0;font-size:2rem;line-height:2.5rem}.css-1fkv74n .title h1 a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.css-1fkv74n .links{margin:0;padding:0;font-size:.9rem;line-height:1.2rem}@media (width<=1023px){.css-1fkv74n .title h1{font-size:1.5rem;line-height:2rem}.css-1fkv74n .rounded img{border-radius:3.5rem 3.4rem;width:7rem;height:7rem}}</style><header class=css-1fkv74n><div class=profileImg><a href=/><img alt="LiteHell의 Gravatar 아이콘"src=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1></a></div><div class=title><h1><a href=/>LiteHell의 블로그</a></h1><p class=links>외부고리: <a href=https://github.com/litehell>GitHub</a>, <a href=https://yeonjin.name/portfolio>Portfolio</a><br>내부고리: <a href=/categories>카테고리</a>, <a href=/tags>태그</a><br>다른 언어: <a href=https://blog-en.litehell.info hreflang=en>영어 (English)</a></p><style data-emotion="css u1wea8">.css-u1wea8{color:#5e5e5e;font-size:75%}</style><p class=css-u1wea8>글 쓸 때는 AI를 안 씁니다. 전부 직접 씁니다. 만약 오탈자나 어색한 문장이 있다면 퇴고를 대충해서 그런거니 양해 부탁드립니다.<br>블로그의 모든 시간 및 날짜는 별도의 언급이 없다면 한국 표준 시간대입니다.</div></header><main><div><style data-emotion="css 1v4sk1e">.css-1v4sk1e{border-bottom:1px solid #999;margin-bottom:.8rem;padding:1.5rem 0 2rem}.css-1v4sk1e .title{margin-bottom:.25rem}.css-1v4sk1e .title *{margin:0;padding:0;display:inline}.css-1v4sk1e .title h2{font-size:2rem;line-height:2.1rem}.css-1v4sk1e .title h3{margin-left:1rem;font-size:1rem;font-weight:200;line-height:1rem}.css-1v4sk1e .datetime{color:#666;margin:0;padding:0}.css-1v4sk1e .links .description{color:#666}</style><div class=css-1v4sk1e><div class=title><h2>XabelFish 개발기 - 멀티 프로세스 모델</h2><h3>귀찮다면 돌아가라</h3></div><p class=datetime>2025. 11. 16. 오후 8:58:29에 LiteHell이(가) 작성함.<div class=links><div class=link><span class=description>카테고리: </span><a href=/category/Dev>Dev</a></div><div class=link><span class=description>태그: </span><a href=/tag/Linux>Linux</a>, <a href=/tag/Rust>Rust</a></div></div></div><style data-emotion="css 1wotv8h">.css-1wotv8h{background:#ddd;border:1px solid #666;border-radius:4px;padding:1em}.css-1wotv8h .title,.css-1wotv8h .active{font-weight:600}.css-1wotv8h ul{margin:1em 0 0}</style><nav class=css-1wotv8h><div class=title>(시리즈) XabelFish 개발기</div><ul><li><a class=active href=/post/xabelfish_into_multi_process_model>XabelFish 개발기 - 멀티 프로세스 모델</a><li><a href=/post/xabelfish_and_pipewire>XabelFish 개발기 - Pipewire와 XDG Screencast</a></ul></nav><style data-emotion="css 1f9qn1f">.css-1f9qn1f{padding:10px;font-size:1rem;line-height:180%}@font-face{font-family:D2Coding;src:url(https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_three@1.0/D2Coding.woff)format("woff");font-weight:400;font-display:swap}.css-1f9qn1f pre{background:#f0f0f0;border-radius:6px;padding:.5em 1em;overflow-x:auto}@media (prefers-color-scheme:dark){.css-1f9qn1f pre{color:#ebebeb;background:#383838}}.css-1f9qn1f code{font-family:Fira Code,Source Code Pro,JetBrains Mono,Roboto Mono,DejaVu Sans Mono,DejaVu Mono,Inconsolata,Monaco,Consolas,Hack,Ubuntu Mono,Red Hat Mono,D2 coding,monospace}.css-1f9qn1f h1{margin:1.8rem 0;font-size:1.8rem}.css-1f9qn1f h1:before{content:"# ";color:#a19c91}.css-1f9qn1f h2{margin:1.6rem 0;font-size:1.6rem}.css-1f9qn1f h2:before{content:"## ";color:#a19c91}.css-1f9qn1f h3{margin:1.4rem 0;font-size:1.4rem}.css-1f9qn1f h3:before{content:"### ";color:#a19c91}.css-1f9qn1f h4{margin:1.2rem 0;font-size:1.2rem}.css-1f9qn1f h5{margin:1.15rem 0;font-size:1.15rem}.css-1f9qn1f h5:before{content:"> ";color:#a19c91}.css-1f9qn1f h6{margin:1.1rem 0;font-size:1.1rem}.css-1f9qn1f h6:before{content:">> ";color:#a19c91}.css-1f9qn1f img,.css-1f9qn1f iframe{max-width:80%;margin:0 auto;display:block}.css-1f9qn1f table{white-space:nowrap;border-collapse:collapse;display:block;overflow-x:auto}.css-1f9qn1f table td,.css-1f9qn1f table tr,.css-1f9qn1f table th{border:1px solid gray}.css-1f9qn1f table th{font-weight:700}.css-1f9qn1f table th,.css-1f9qn1f table td{padding:5px 10px}.css-1f9qn1f table thead{background:#d8d8d8}.css-1f9qn1f blockquote{background:#c2c2c2;border-left:5px solid #4e4e4e;margin:25px 10px 25px 30px;padding:10px 50px}.css-1f9qn1f ul li,.css-1f9qn1f ol li{margin:6px 0}</style><article class=css-1f9qn1f><h1>들어가는 글</h1><p><a href=/post/xabelfish_and_pipewire>지난 글</a>에서 딱 설정창까지만 만들었었는데 <a href=https://github.com/tesseract-ocr/tessdoc>Tesseract</a>의 인식률이 썩... 좋지가 않았다. 그래서 이걸 좀 사람이 쓸 수 있게 개발하려면 다른 OCR 엔진을 지원하도록 수정해야 할 필요가 있었다.<p>그런데 Rust를 쓰다보니 쉽지 않았다. 객체지향 프로그래밍하듯 인터페이스를 만들어서 각각의 OCR 구현체가 그 인터페이스를 구현하는 구조를 만들려고 했다. 이를 구현하려면 <code>dyn</code> 키워드를 활용해야 했는데 문제는 관련 객체가 여러 곳에서 공유되는 상태라는 것이다. 그래서 코드를 어떻게든 수정하려 해도 Rust 컴파일러가 컴파일을 거부해서... 하다가 머리에 열올라서 나중으로 미뤘다.<p>그래서 그 다음으로 이미지 크롭을 구현하려 했다. 알다시피, XabelFish에서는 다음과 같은 창이 뜬다.<p><img alt="Screencast 창/영역 선택 창"src=../xabelfish_and_pipewire/screencast.png><p>게임 창을 선택하면 OCR결과가 쓰레기같으므로(...) 딱 텍스트 영역만 지정해야 했는데, 문제는 이러면 게임 창을 이동했을 때 영역을 다시 지정해야 했다. 이게 은근 불편해서, 아예 프로그램 내에 특정 영역만 지정해서 OCR할 수 있는 기능이 필요했다.<p>이를 구현하려면 <a href=https://tauri.app/>Tauri</a>의 FE에 캡쳐된 이미지를 전송해야 했는데,<sup><a aria-describedby=footnote-label data-footnote-ref href=#user-content-fn-1 id=user-content-fnref-1>1</a></sup> 이거 못 하는 건 아닌데 좀 귀찮더라... 그래서 안하고 있었다.<p>그렇게 한 오랜시간 방치하다가 문득 생각이 나서, 일단 OCR 엔진 부분부터 손을 보았다.<h1>구조 변경</h1><h2>멀티 프로세스 구조</h2><p>기존에 OCR 엔진 변경 기능 구현이 매우 어려웠던 이유는 XabelFish 프로그램내에 OCR/번역/화면캡쳐 코드가 모두 들어있었기 때문이다.<p>그러면 OCR랑 번역이랑 화면캡쳐를 다른 프로세스로 분리하면 되지 않을까? 만약 OCR 엔진이나 번역기를 바꿔야 하면 프로세스만 바꾸면 되지 않을까?<h3>UNIX 도메인 소켓</h3><p>프로세스간 빈번한 통신에 HTTP를 이용하는 것은 자원낭비이다. 이럴 땐 파일 소켓을 이용하면 HTTP보다 적은 오버헤드를 달성할 수 있다.<p>이를 위해 먼저 소켓 파일 경로를 만드는 코드부터 작성하자.<pre><code class=language-rust>    <span class=pl-k>pub</span> <span class=pl-k>fn</span> <span class=pl-en>get_temp_sock_path</span>() <span class=pl-k>-></span> <span class=pl-en>PathBuf</span> {
        <span class=pl-k>let</span> <span class=pl-smi>temp_path</span> <span class=pl-k>=</span> <span class=pl-en>NamedTempFile</span><span class=pl-k>::</span><span class=pl-en>with_suffix</span>(<span class=pl-s><span class=pl-pds>"</span>.sock<span class=pl-pds>"</span></span>)
            <span class=pl-k>.</span><span class=pl-en>expect</span>(<span class=pl-s><span class=pl-pds>"</span>Failed to create temp file<span class=pl-pds>"</span></span>)
            <span class=pl-k>.</span><span class=pl-en>into_temp_path</span>();

        <span class=pl-en>remove_file</span>(<span class=pl-k>&</span><span class=pl-smi>temp_path</span>)<span class=pl-k>.</span><span class=pl-en>expect</span>(<span class=pl-s><span class=pl-pds>"</span>Failed to delete temp file<span class=pl-pds>"</span></span>);

        <span class=pl-c>// remove_file doesn't gauarantee that the file will be deleted immediately...</span>
        <span class=pl-c>// so we need to wait for file to be deleted.</span>
        <span class=pl-k>while</span> <span class=pl-en>exists</span>(<span class=pl-k>&</span><span class=pl-smi>temp_path</span>)<span class=pl-k>.</span><span class=pl-en>is_ok_and</span>(<span class=pl-k>|</span><span class=pl-smi>x</span><span class=pl-k>|</span> <span class=pl-smi>x</span>) {}

        <span class=pl-smi>temp_path</span><span class=pl-k>.</span><span class=pl-en>to_path_buf</span>()
    }
</code></pre><p>rust의 <a href=https://doc.rust-lang.org/std/fs/fn.remove_file.html>remove_file</a> 함수는 파일이 즉시 삭제될 것을 보장하지 않는다.<blockquote><p>Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).<p>-- <a href=https://doc.rust-lang.org/std/fs/fn.remove_file.html>rust 공식 문서</a></blockquote><p>따라서 파일이 삭제될 때까지 기다리는 코드(윗 코드에서 <code>while</code>문 부분)가 필요하다. 없으면 소켓 만들때 이미 존재하는 파일이라고 오류난다.<sup><a aria-describedby=footnote-label data-footnote-ref href=#user-content-fn-5 id=user-content-fnref-5>2</a></sup><p>UNIX 도메인 소켓은 데이터그램<sup><a aria-describedby=footnote-label data-footnote-ref href=#user-content-fn-2 id=user-content-fnref-2>3</a></sup> 방식과 스트림<sup><a aria-describedby=footnote-label data-footnote-ref href=#user-content-fn-3 id=user-content-fnref-3>4</a></sup> 방식이 가능하다. 본 프로그램을 개발할 때는 스트림 방식만을 이용했다.<p>먼저 연결을 받는 서버는 다음과 같다. 소켓을 bind하고 accept를 무한반복한다.<pre><code class=language-rust><span class=pl-k>use</span> <span class=pl-en>std</span><span class=pl-k>::</span>{
    <span class=pl-en>fs</span><span class=pl-k>::</span>{exists, remove_file},
    <span class=pl-en>io</span><span class=pl-k>::</span><span class=pl-en>Error</span>,
    <span class=pl-en>os</span><span class=pl-k>::</span><span class=pl-en>unix</span><span class=pl-k>::</span><span class=pl-en>net</span><span class=pl-k>::</span><span class=pl-en>UnixListener</span>,
    <span class=pl-en>path</span><span class=pl-k>::</span>{<span class=pl-en>Path</span>, <span class=pl-en>PathBuf</span>},
};

<span class=pl-k>use</span> <span class=pl-en>tempfile</span><span class=pl-k>::</span><span class=pl-en>NamedTempFile</span>;

<span class=pl-k>use</span> <span class=pl-k>crate::</span><span class=pl-en>unix_socket_client</span><span class=pl-k>::</span><span class=pl-en>UnixSocketClient</span>;

<span class=pl-k>pub</span> <span class=pl-k>struct</span> <span class=pl-en>UnixSocketServer</span> {
    <span class=pl-smi>listener</span><span class=pl-k>:</span> <span class=pl-en>UnixListener</span>,
    <span class=pl-smi>path</span><span class=pl-k>:</span> <span class=pl-en>PathBuf</span>,
}

<span class=pl-k>impl</span> <span class=pl-en>UnixSocketServer</span> {
    <span class=pl-k>pub</span> <span class=pl-k>fn</span> <span class=pl-en>bind</span>(<span class=pl-smi>path</span><span class=pl-k>:</span> <span class=pl-k>&</span><span class=pl-en>Path</span>) <span class=pl-k>-></span> <span class=pl-en>Result</span><<span class=pl-c1>Self</span>, <span class=pl-en>Error</span>> {
        <span class=pl-k>let</span> <span class=pl-smi>listener</span> <span class=pl-k>=</span> <span class=pl-en>UnixListener</span><span class=pl-k>::</span><span class=pl-en>bind</span>(<span class=pl-smi>path</span>)<span class=pl-k>?</span>;

        <span class=pl-en>Ok</span>(<span class=pl-c1>Self</span> {
            <span class=pl-smi>listener</span>,
            <span class=pl-smi>path</span><span class=pl-k>:</span> <span class=pl-smi>path</span><span class=pl-k>.</span><span class=pl-en>to_path_buf</span>(),
        })
    }

    <span class=pl-k>pub</span> <span class=pl-k>fn</span> <span class=pl-en>get_temp_sock_path</span>() <span class=pl-k>-></span> <span class=pl-en>PathBuf</span> {
        <span class=pl-k>let</span> <span class=pl-smi>temp_path</span> <span class=pl-k>=</span> <span class=pl-en>NamedTempFile</span><span class=pl-k>::</span><span class=pl-en>with_suffix</span>(<span class=pl-s><span class=pl-pds>"</span>.sock<span class=pl-pds>"</span></span>)
            <span class=pl-k>.</span><span class=pl-en>expect</span>(<span class=pl-s><span class=pl-pds>"</span>Failed to create temp file<span class=pl-pds>"</span></span>)
            <span class=pl-k>.</span><span class=pl-en>into_temp_path</span>();

        <span class=pl-en>remove_file</span>(<span class=pl-k>&</span><span class=pl-smi>temp_path</span>)<span class=pl-k>.</span><span class=pl-en>expect</span>(<span class=pl-s><span class=pl-pds>"</span>Failed to delete temp file<span class=pl-pds>"</span></span>);

        <span class=pl-c>// remove_file doesn't gauarantee that the file will be deleted immediately...</span>
        <span class=pl-c>// so we need to wait for file to be deleted.</span>
        <span class=pl-k>while</span> <span class=pl-en>exists</span>(<span class=pl-k>&</span><span class=pl-smi>temp_path</span>)<span class=pl-k>.</span><span class=pl-en>is_ok_and</span>(<span class=pl-k>|</span><span class=pl-smi>x</span><span class=pl-k>|</span> <span class=pl-smi>x</span>) {}

        <span class=pl-smi>temp_path</span><span class=pl-k>.</span><span class=pl-en>to_path_buf</span>()
    }

    <span class=pl-k>pub</span> <span class=pl-k>fn</span> <span class=pl-en>create</span>() <span class=pl-k>-></span> <span class=pl-en>Result</span><(<span class=pl-c1>Self</span>, <span class=pl-en>String</span>), <span class=pl-en>Error</span>> {
        <span class=pl-k>let</span> <span class=pl-smi>temp_path</span> <span class=pl-k>=</span> <span class=pl-c1>Self</span><span class=pl-k>::</span><span class=pl-en>get_temp_sock_path</span>();

        <span class=pl-k>let</span> <span class=pl-smi>server</span> <span class=pl-k>=</span> <span class=pl-c1>Self</span><span class=pl-k>::</span><span class=pl-en>bind</span>(<span class=pl-k>&</span><span class=pl-smi>temp_path</span>)<span class=pl-k>?</span>;
        <span class=pl-k>let</span> <span class=pl-smi>path_string</span> <span class=pl-k>=</span> <span class=pl-smi>temp_path</span><span class=pl-k>.</span><span class=pl-en>as_os_str</span>()<span class=pl-k>.</span><span class=pl-en>to_str</span>()<span class=pl-k>.</span><span class=pl-en>unwrap</span>()<span class=pl-k>.</span><span class=pl-en>to_string</span>();

        <span class=pl-en>Ok</span>((<span class=pl-smi>server</span>, <span class=pl-smi>path_string</span>))
    }

    <span class=pl-k>pub</span> <span class=pl-k>fn</span> <span class=pl-en>accept</span>(<span class=pl-k>&mut</span> <span class=pl-c1>self</span>) <span class=pl-k>-></span> <span class=pl-en>Result</span><<span class=pl-en>UnixSocketClient</span>, <span class=pl-en>Error</span>> {
        <span class=pl-k>let</span> (<span class=pl-smi>stream</span>, <span class=pl-smi>_addr</span>) <span class=pl-k>=</span> <span class=pl-c1>self</span><span class=pl-k>.</span>listener<span class=pl-k>.</span><span class=pl-en>accept</span>()<span class=pl-k>?</span>;

        <span class=pl-en>Ok</span>(<span class=pl-en>UnixSocketClient</span><span class=pl-k>::</span><span class=pl-en>from</span>(<span class=pl-smi>stream</span>))
    }
}

<span class=pl-k>impl</span> <span class=pl-en>Drop</span> <span class=pl-k>for</span> <span class=pl-en>UnixSocketServer</span> {
    <span class=pl-k>fn</span> <span class=pl-en>drop</span>(<span class=pl-k>&mut</span> <span class=pl-c1>self</span>) {
        <span class=pl-k>let</span> <span class=pl-smi>_</span> <span class=pl-k>=</span> <span class=pl-en>remove_file</span>(<span class=pl-c1>self</span><span class=pl-k>.</span>path<span class=pl-k>.</span><span class=pl-en>as_path</span>());
    }
}
</code></pre><p>그리고 클라이언트는 다음과 같다. 데이터 길이를 먼저 보낸 후, <a href=https://bsonspec.org/>BSON</a> 형식의 데이터를 보내도록 했다. 어처피 동일 시스템내 프로세스 간 통신이므로 엔디언을 굳이 리틀 엔디언이나 빅 엔디언으로 고정하진 않았다. <a href=https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read>Rust에서는 소켓이 닫히면 0 바이트를 읽는다.</a> 이를 이용해 데이터를 수신할 때 소켓이 닫혔는 지의 여부를 확인하도록 했다.<pre><code class=language-rust><span class=pl-k>use</span> <span class=pl-en>std</span><span class=pl-k>::</span>{
    cmp,
    <span class=pl-en>io</span><span class=pl-k>::</span>{<span class=pl-en>Error</span>, <span class=pl-en>Read</span>, <span class=pl-en>Write</span>},
    <span class=pl-en>os</span><span class=pl-k>::</span><span class=pl-en>unix</span><span class=pl-k>::</span><span class=pl-en>net</span><span class=pl-k>::</span><span class=pl-en>UnixStream</span>,
    <span class=pl-en>path</span><span class=pl-k>::</span><span class=pl-en>Path</span>,
};

<span class=pl-k>use</span> <span class=pl-en>serde</span><span class=pl-k>::</span>{<span class=pl-en>Serialize</span>, <span class=pl-en>de</span><span class=pl-k>::</span><span class=pl-en>DeserializeOwned</span>};

<span class=pl-k>pub</span> <span class=pl-k>struct</span> <span class=pl-en>UnixSocketClient</span> {
    <span class=pl-smi>stream</span><span class=pl-k>:</span> <span class=pl-en>UnixStream</span>,
    <span class=pl-smi>closed</span><span class=pl-k>:</span> <span class=pl-en>bool</span>,
}

<span class=pl-k>const</span> <span class=pl-c1>READ_BUFFER_SIZE</span><span class=pl-k>:</span> <span class=pl-en>usize</span> <span class=pl-k>=</span> <span class=pl-c1>1024</span>;

<span class=pl-k>impl</span> <span class=pl-en>From</span><<span class=pl-en>UnixStream</span>> <span class=pl-k>for</span> <span class=pl-en>UnixSocketClient</span> {
    <span class=pl-k>fn</span> <span class=pl-en>from</span>(<span class=pl-smi>stream</span><span class=pl-k>:</span> <span class=pl-en>UnixStream</span>) <span class=pl-k>-></span> <span class=pl-c1>Self</span> {
        <span class=pl-c1>Self</span> {
            <span class=pl-smi>stream</span>,
            <span class=pl-smi>closed</span><span class=pl-k>:</span> <span class=pl-c1>false</span>,
        }
    }
}

<span class=pl-k>impl</span> <span class=pl-en>UnixSocketClient</span> {
    <span class=pl-k>pub</span> <span class=pl-k>fn</span> <span class=pl-en>connect</span>(<span class=pl-smi>path</span><span class=pl-k>:</span> <span class=pl-k>&</span><span class=pl-en>Path</span>) <span class=pl-k>-></span> <span class=pl-en>Result</span><<span class=pl-c1>Self</span>, <span class=pl-en>Error</span>> {
        <span class=pl-k>let</span> <span class=pl-smi>stream</span> <span class=pl-k>=</span> <span class=pl-en>UnixStream</span><span class=pl-k>::</span><span class=pl-en>connect</span>(<span class=pl-k>&</span><span class=pl-smi>path</span>)<span class=pl-k>?</span>;
        <span class=pl-en>Ok</span>(<span class=pl-c1>Self</span> {
            <span class=pl-smi>stream</span>,
            <span class=pl-smi>closed</span><span class=pl-k>:</span> <span class=pl-c1>false</span>,
        })
    }

    <span class=pl-k>fn</span> <span class=pl-en>send_bytes</span>(<span class=pl-k>&mut</span> <span class=pl-c1>self</span>, <span class=pl-smi>data</span><span class=pl-k>:</span> <span class=pl-k>&</span>[<span class=pl-en>u8</span>]) <span class=pl-k>-></span> <span class=pl-en>Result</span><<span class=pl-en>usize</span>, <span class=pl-en>Error</span>> {
        <span class=pl-k>let</span> <span class=pl-smi>data_len</span> <span class=pl-k>=</span> <span class=pl-smi>data</span><span class=pl-k>.</span><span class=pl-en>len</span>();
        <span class=pl-c1>self</span><span class=pl-k>.</span>stream<span class=pl-k>.</span><span class=pl-en>write_all</span>(<span class=pl-k>&</span><span class=pl-smi>data_len</span><span class=pl-k>.</span><span class=pl-en>to_ne_bytes</span>())<span class=pl-k>?</span>;
        <span class=pl-c1>self</span><span class=pl-k>.</span>stream<span class=pl-k>.</span><span class=pl-en>write_all</span>(<span class=pl-smi>data</span>)<span class=pl-k>?</span>;

        <span class=pl-en>Ok</span>(<span class=pl-smi>data_len</span>)
    }

    <span class=pl-k>pub</span> <span class=pl-k>fn</span> <span class=pl-en>send</span><<span class=pl-en>T</span><span class=pl-k>:</span> <span class=pl-en>Serialize</span>>(<span class=pl-k>&mut</span> <span class=pl-c1>self</span>, <span class=pl-smi>data</span><span class=pl-k>:</span> <span class=pl-k>&</span><span class=pl-en>T</span>) <span class=pl-k>-></span> <span class=pl-en>Result</span><(), <span class=pl-en>Error</span>> {
        <span class=pl-k>let</span> <span class=pl-smi>serialized</span> <span class=pl-k>=</span> <span class=pl-en>bson</span><span class=pl-k>::</span><span class=pl-en>serialize_to_vec</span>(<span class=pl-smi>data</span>)<span class=pl-k>.</span><span class=pl-en>expect</span>(<span class=pl-s><span class=pl-pds>"</span>Failed to serailize to bson<span class=pl-pds>"</span></span>);

        <span class=pl-c1>self</span><span class=pl-k>.</span><span class=pl-en>send_bytes</span>(<span class=pl-smi>serialized</span><span class=pl-k>.</span><span class=pl-en>as_slice</span>())<span class=pl-k>?</span>;
        <span class=pl-en>Ok</span>(())
    }

    <span class=pl-k>pub</span> <span class=pl-k>fn</span> <span class=pl-en>recv</span><'<span class=pl-en>de</span>, <span class=pl-en>T</span>>(<span class=pl-k>&mut</span> <span class=pl-c1>self</span>) <span class=pl-k>-></span> <span class=pl-en>Result</span><<span class=pl-en>Option</span><<span class=pl-en>T</span>>, <span class=pl-en>Error</span>>
    <span class=pl-k>where</span>
        <span class=pl-en>T</span><span class=pl-k>:</span> <span class=pl-en>DeserializeOwned</span>,
    {
        <span class=pl-k>let</span> <span class=pl-smi>data</span> <span class=pl-k>=</span> {
            <span class=pl-k>let</span> <span class=pl-smi>recv_result</span> <span class=pl-k>=</span> <span class=pl-c1>self</span><span class=pl-k>.</span><span class=pl-en>recv_vec</span>()<span class=pl-k>?</span>;
            <span class=pl-k>if</span> <span class=pl-k>let</span> <span class=pl-en>Some</span>(<span class=pl-smi>vec</span>) <span class=pl-k>=</span> <span class=pl-smi>recv_result</span> {
                <span class=pl-smi>vec</span>
            } <span class=pl-k>else</span> {
                <span class=pl-k>return</span> <span class=pl-en>Ok</span>(<span class=pl-en>None</span>);
            }
        };

        <span class=pl-k>let</span> <span class=pl-smi>slice</span> <span class=pl-k>=</span> <span class=pl-smi>data</span><span class=pl-k>.</span><span class=pl-en>as_slice</span>();

        <span class=pl-k>let</span> <span class=pl-smi>deserialized</span> <span class=pl-k>=</span> <span class=pl-en>bson</span><span class=pl-k>::</span><span class=pl-en>deserialize_from_slice</span>(<span class=pl-smi>slice</span>)<span class=pl-k>.</span><span class=pl-en>expect</span>(<span class=pl-s><span class=pl-pds>"</span>Failed to deserialize bson<span class=pl-pds>"</span></span>);
        <span class=pl-en>Ok</span>(<span class=pl-en>Some</span>(<span class=pl-smi>deserialized</span>))
    }

    <span class=pl-k>pub</span> <span class=pl-k>fn</span> <span class=pl-en>is_closed</span>(<span class=pl-k>&</span><span class=pl-c1>self</span>) <span class=pl-k>-></span> <span class=pl-en>bool</span> {
        <span class=pl-c1>self</span><span class=pl-k>.</span>closed
    }

    <span class=pl-k>fn</span> <span class=pl-en>recv_data_len</span>(<span class=pl-k>&mut</span> <span class=pl-c1>self</span>) <span class=pl-k>-></span> <span class=pl-en>Result</span><<span class=pl-en>Option</span><<span class=pl-en>usize</span>>, <span class=pl-en>Error</span>> {
        <span class=pl-k>let</span> <span class=pl-smi>len_byte_count</span><span class=pl-k>:</span> <span class=pl-en>usize</span> <span class=pl-k>=</span> (<span class=pl-en>usize</span><span class=pl-k>::</span><span class=pl-c1>BITS</span> <span class=pl-k>/</span> <span class=pl-c1>8</span>)<span class=pl-k>.</span><span class=pl-en>try_into</span>()<span class=pl-k>.</span><span class=pl-en>unwrap</span>();
        <span class=pl-k>let</span> <span class=pl-k>mut</span> <span class=pl-smi>buffer</span> <span class=pl-k>=</span> [<span class=pl-c1>0</span>; <span class=pl-c1>8</span>];
        <span class=pl-k>let</span> <span class=pl-k>mut</span> <span class=pl-smi>total_read_byte_count</span><span class=pl-k>:</span> <span class=pl-en>usize</span> <span class=pl-k>=</span> <span class=pl-c1>0</span>;

        <span class=pl-k>while</span> <span class=pl-smi>total_read_byte_count</span> <span class=pl-k><</span> <span class=pl-smi>len_byte_count</span> {
            <span class=pl-k>let</span> <span class=pl-smi>byte_count_read</span> <span class=pl-k>=</span> <span class=pl-c1>self</span>
                <span class=pl-k>.</span>stream
                <span class=pl-k>.</span><span class=pl-en>read</span>(<span class=pl-k>&mut</span> <span class=pl-smi>buffer</span>[<span class=pl-smi>total_read_byte_count</span><span class=pl-k>..</span><span class=pl-smi>len_byte_count</span>])<span class=pl-k>?</span>;

            <span class=pl-k>if</span> <span class=pl-smi>byte_count_read</span> <span class=pl-k>==</span> <span class=pl-c1>0</span> {
                <span class=pl-c1>self</span><span class=pl-k>.</span>closed <span class=pl-k>=</span> <span class=pl-c1>true</span>;
                <span class=pl-k>return</span> <span class=pl-en>Ok</span>(<span class=pl-en>None</span>);
            }

            <span class=pl-smi>total_read_byte_count</span> <span class=pl-k>+=</span> <span class=pl-smi>byte_count_read</span>;
        }

        <span class=pl-en>Ok</span>(<span class=pl-en>Some</span>(<span class=pl-en>usize</span><span class=pl-k>::</span><span class=pl-en>from_ne_bytes</span>(<span class=pl-smi>buffer</span>)))
    }

    <span class=pl-k>fn</span> <span class=pl-en>recv_to</span>(<span class=pl-k>&mut</span> <span class=pl-c1>self</span>, <span class=pl-smi>vec</span><span class=pl-k>:</span> <span class=pl-k>&mut</span> <span class=pl-en>Vec</span><<span class=pl-en>u8</span>>) <span class=pl-k>-></span> <span class=pl-en>Result</span><<span class=pl-en>Option</span><()>, <span class=pl-en>Error</span>> {
        <span class=pl-k>let</span> <span class=pl-smi>data_len_option</span> <span class=pl-k>=</span> <span class=pl-c1>self</span><span class=pl-k>.</span><span class=pl-en>recv_data_len</span>()<span class=pl-k>?</span>;
        <span class=pl-k>let</span> <span class=pl-smi>data_len</span> <span class=pl-k>=</span> <span class=pl-k>if</span> <span class=pl-k>let</span> <span class=pl-en>Some</span>(<span class=pl-smi>data_len</span>) <span class=pl-k>=</span> <span class=pl-smi>data_len_option</span> {
            <span class=pl-smi>data_len</span>
        } <span class=pl-k>else</span> {
            <span class=pl-k>return</span> <span class=pl-en>Ok</span>(<span class=pl-en>None</span>);
        };
        <span class=pl-k>let</span> <span class=pl-k>mut</span> <span class=pl-smi>total_read_byte_count</span><span class=pl-k>:</span> <span class=pl-en>usize</span> <span class=pl-k>=</span> <span class=pl-c1>0</span>;

        <span class=pl-k>while</span> <span class=pl-smi>total_read_byte_count</span> <span class=pl-k><</span> <span class=pl-smi>data_len</span> {
            <span class=pl-k>let</span> <span class=pl-smi>remaining_byte_count</span> <span class=pl-k>=</span> <span class=pl-smi>data_len</span> <span class=pl-k>-</span> <span class=pl-smi>total_read_byte_count</span>;
            <span class=pl-k>let</span> <span class=pl-k>mut</span> <span class=pl-smi>buffer</span> <span class=pl-k>=</span> [<span class=pl-c1>0</span>; <span class=pl-c1>READ_BUFFER_SIZE</span>];
            <span class=pl-k>let</span> <span class=pl-smi>bytes_to_read</span> <span class=pl-k>=</span> <span class=pl-en>cmp</span><span class=pl-k>::</span><span class=pl-en>min</span>(<span class=pl-c1>READ_BUFFER_SIZE</span>, <span class=pl-smi>remaining_byte_count</span>);

            <span class=pl-k>let</span> <span class=pl-smi>read_byte_count</span> <span class=pl-k>=</span> <span class=pl-c1>self</span><span class=pl-k>.</span>stream<span class=pl-k>.</span><span class=pl-en>read</span>(<span class=pl-k>&mut</span> <span class=pl-smi>buffer</span>[<span class=pl-c1>0</span><span class=pl-k>..</span><span class=pl-smi>bytes_to_read</span>])<span class=pl-k>?</span>;

            <span class=pl-k>if</span> <span class=pl-smi>read_byte_count</span> <span class=pl-k>==</span> <span class=pl-c1>0</span> {
                <span class=pl-c1>self</span><span class=pl-k>.</span>closed <span class=pl-k>=</span> <span class=pl-c1>true</span>;
                <span class=pl-k>return</span> <span class=pl-en>Ok</span>(<span class=pl-en>None</span>);
            }

            <span class=pl-smi>total_read_byte_count</span> <span class=pl-k>+=</span> <span class=pl-smi>read_byte_count</span>;
            <span class=pl-smi>vec</span><span class=pl-k>.</span><span class=pl-en>extend_from_slice</span>(<span class=pl-k>&</span><span class=pl-smi>buffer</span>[<span class=pl-c1>0</span><span class=pl-k>..</span><span class=pl-smi>read_byte_count</span>]);
        }

        <span class=pl-en>Ok</span>(<span class=pl-en>Some</span>(()))
    }

    <span class=pl-k>fn</span> <span class=pl-en>recv_vec</span>(<span class=pl-k>&mut</span> <span class=pl-c1>self</span>) <span class=pl-k>-></span> <span class=pl-en>Result</span><<span class=pl-en>Option</span><<span class=pl-en>Vec</span><<span class=pl-en>u8</span>>>, <span class=pl-en>Error</span>> {
        <span class=pl-k>let</span> <span class=pl-k>mut</span> <span class=pl-smi>vec</span> <span class=pl-k>=</span> <span class=pl-en>Vec</span><span class=pl-k>::</span><span class=pl-en>new</span>();
        <span class=pl-k>let</span> <span class=pl-smi>success</span> <span class=pl-k>=</span> <span class=pl-c1>self</span><span class=pl-k>.</span><span class=pl-en>recv_to</span>(<span class=pl-k>&mut</span> <span class=pl-smi>vec</span>)<span class=pl-k>?</span>;

        <span class=pl-k>if</span> <span class=pl-smi>success</span><span class=pl-k>.</span><span class=pl-en>is_some</span>() {
            <span class=pl-en>Ok</span>(<span class=pl-en>Some</span>(<span class=pl-smi>vec</span>))
        } <span class=pl-k>else</span> {
            <span class=pl-en>Ok</span>(<span class=pl-en>None</span>)
        }
    }
}

<span class=pl-k>impl</span> <span class=pl-en>Drop</span> <span class=pl-k>for</span> <span class=pl-en>UnixSocketClient</span> {
    <span class=pl-k>fn</span> <span class=pl-en>drop</span>(<span class=pl-k>&mut</span> <span class=pl-c1>self</span>) {
        <span class=pl-k>let</span> <span class=pl-smi>_</span> <span class=pl-k>=</span> <span class=pl-c1>self</span><span class=pl-k>.</span>stream<span class=pl-k>.</span><span class=pl-en>shutdown</span>(<span class=pl-en>std</span><span class=pl-k>::</span><span class=pl-en>net</span><span class=pl-k>::</span><span class=pl-en>Shutdown</span><span class=pl-k>::</span><span class=pl-en>Both</span>);
    }
}
</code></pre><p>위 서버 코드는 멀티 클라이언트를 고려하지 않았지만, 어처피 프로세스간 단순한 내부통신 목적이니 크게 상관없다.<h3>호스트-클라이언트 구조</h3><p>XabelFish를 호스트-클라이언트 구조로 재작성했다. XabelFish는 OCR, 번역, 화면캡쳐를 위한 각각 세개의 UNIX 소켓을 열고, 자식 프로세스 실행시에 소켓 경로를 인자로 전달한다. 그러면 자식 프로세스는 전달받은 소켓에 접속하여 데이터를 주고받는다.<p>그러면 이제 자식 프로세스가 예기치 않게 종료됐을 시 다시 실행하는 기능을 구현해야 한다. 이를 구현하기 위해서는 자식 프로세스가 살아있는 지를 확인해야 한다.<p>이를 위해 처음에는 <a href=https://crates.io/crates/sysinfo>sysinfo</a> 라이브러리를 이용해 자식 프로세스가 살아있는 지를 주기적으로 확인하려 했는데, 생각한대로 동작하지 않았다. 그래서 그냥 Lock-file 방식을 이용하기로 했다.<p>구현하는 방법은 매우 간단한다. 먼저 호스트에서 자식 프로세스를 실행할 때 lock file 경로를 인자로 전달한다. 그러면 자식 프로세스에서는 다음과 같이 lock file의 lock을 취득한다.<pre><code class=language-rust>    <span class=pl-k>let</span> <span class=pl-smi>args</span> <span class=pl-k>=</span> <span class=pl-en>CommandArgs</span><span class=pl-k>::</span><span class=pl-en>parse</span>();

    <span class=pl-k>let</span> <span class=pl-smi>lockfile</span> <span class=pl-k>=</span> <span class=pl-en>File</span><span class=pl-k>::</span><span class=pl-en>open</span>(<span class=pl-smi>args</span><span class=pl-k>.</span>lock_file)<span class=pl-k>.</span><span class=pl-en>unwrap</span>();
    <span class=pl-smi>lockfile</span><span class=pl-k>.</span><span class=pl-en>lock</span>()<span class=pl-k>.</span><span class=pl-en>expect</span>(<span class=pl-s><span class=pl-pds>"</span>Failed to get a lock<span class=pl-pds>"</span></span>);
</code></pre><p>그리고 호스트에서는 주기적으로 lock file의 lock 획득을 시도한다. 만약 성공하면 자식 프로세스가 죽은 것이고 실패하면 살아있는 것이다. 이렇게 판단하면 된다.<pre><code class=language-rust>    <span class=pl-k>pub</span> <span class=pl-k>fn</span> <span class=pl-en>is_alive</span>(<span class=pl-k>&</span><span class=pl-c1>self</span>) <span class=pl-k>-></span> <span class=pl-en>bool</span> {
        <span class=pl-k>let</span> <span class=pl-smi>lockfile</span> <span class=pl-k>=</span> <span class=pl-en>File</span><span class=pl-k>::</span><span class=pl-en>open</span>(<span class=pl-c1>self</span><span class=pl-k>.</span>lockfile<span class=pl-k>.</span><span class=pl-en>clone</span>());

        <span class=pl-k>if</span> <span class=pl-k>let</span> <span class=pl-en>Ok</span>(<span class=pl-smi>lockfile</span>) <span class=pl-k>=</span> <span class=pl-smi>lockfile</span> {
            <span class=pl-smi>lockfile</span><span class=pl-k>.</span><span class=pl-en>try_lock</span>()<span class=pl-k>.</span><span class=pl-en>is_err</span>()
        } <span class=pl-k>else</span> {
            <span class=pl-c1>false</span>
        }
    }
</code></pre><h4>호스트</h4><p>호스트에서는 총 4개의 쓰레드가 실행된다.<ul><li>OCR 자식 프로세스랑 통신하는 쓰레드<li>화면 캡쳐 프로세스랑 통신하는 쓰레드<li>번역 프로세스랑 통신하는 쓰레드<li>자식 프로세스가 죽었는지 확인하는 쓰레드 (겸사겸사 번역기나 OCR 엔진 설정이 바뀌면 기존 프로세스를 죽이고 다른 프로세스를 실행하는 역할도 한다.)</ul><p>쓰레드간에 데이터를 서로 주고받으면서 최종적으로 번역결과물이 나온다.<p>이론적으로는 중간에 번역기나 OCR 엔진 종류를 바꿀 수도 있지만 실제로 잘 되는 지는 테스트해보지 않았다. 이건 나중에 테스트하는 거로...<h1>결과물</h1><p>원래 게임으로 테스트하려 했는데 실행이 안되서<sup><a aria-describedby=footnote-label data-footnote-ref href=#user-content-fn-4 id=user-content-fnref-4>5</a></sup> 그냥 <a href=https://www.nofuture.tv/20200415>인터넷에 있는 더미 텍스트</a>로 테스트해봤다.<p><img alt="테스트 결과"src=./test_result.png><p>잘 되는 것 같다. 이제 GUI만 만들면 되는데... 프로그램 특성상 멀티쓰레딩이 필연이라서 무슨 선택을 하던간에 만들기가 너무 귀찮다... 고민해봐야지...<hr><section class=footnotes data-footnotes><h1 class=sr-only id=footnote-label>주석</h1><ol><li id=user-content-fn-1><p>일단 뭐가 보여야 영역을 지정하니까. <a aria-label="Back to reference 1"class=data-footnote-backref data-footnote-backref href=#user-content-fnref-1>↩</a></p><li id=user-content-fn-5><p>덕분에 삽질 좀 했다. <a aria-label="Back to reference 2"class=data-footnote-backref data-footnote-backref href=#user-content-fnref-5>↩</a></p><li id=user-content-fn-2><p>UDP와 유사하다. <a aria-label="Back to reference 3"class=data-footnote-backref data-footnote-backref href=#user-content-fnref-2>↩</a></p><li id=user-content-fn-3><p>TCP와 유사하다. <a aria-label="Back to reference 4"class=data-footnote-backref data-footnote-backref href=#user-content-fnref-3>↩</a></p><li id=user-content-fn-4><p>최근에 노트북에 있던 Arch Linux를 밀고 Fedora로 바꿨다. 그래서 아직 설정이 덜 됐다. <a aria-label="Back to reference 5"class=data-footnote-backref data-footnote-backref href=#user-content-fnref-4>↩</a></p></ol></section></article><style data-emotion="css ly0ba3">.css-ly0ba3 .utterances{max-width:100%!important}</style><div class=css-ly0ba3><script label="blog comment"async crossorigin issue-term=xabelfish_into_multi_process_model repo=LiteHell/litehell-blog src=https://utteranc.es/client.js theme=github-light></script></div><style data-emotion="css eyxei3">.css-eyxei3{-webkit-box-flex-wrap:wrap;-webkit-flex-flow:wrap;-ms-flex-flow:wrap;flex-flow:wrap;justify-content:space-between;gap:1em .5em;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-eyxei3 a{-webkit-text-decoration:none;text-decoration:none}.css-eyxei3 .inner{vertical-align:top;display:inline-block}.css-eyxei3 .inner .title{font-size:1.3em;line-height:1.3rem}.css-eyxei3 .inner .subtitle{margin-top:.2rem;font-size:1rem;font-weight:200;line-height:1rem}.css-eyxei3 .inner .date{font-size:.8em;font-weight:200;line-height:.8rem}.css-eyxei3 .next,.css-eyxei3 .previous{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;gap:.5em;width:max-content;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-eyxei3 .next.next,.css-eyxei3 .previous.next{text-align:right;margin-left:auto}.css-eyxei3 .next.previous,.css-eyxei3 .previous.previous{text-align:left}.css-eyxei3 .next .inner,.css-eyxei3 .previous .inner{-webkit-flex:1;-ms-flex:1;flex:1}</style><nav class=css-eyxei3><div class=noop>첫 게시글입니다.</div><a class=next href=/post/multiple_tailnets_with_tailscale><div class=inner><div class=title>Tailscale을 이용한 두개 이상의 네트워크 만들기</div><div class=subtitle>계정 두개 만들 필요 X</div><div class=date>2025. 11. 1. 오후 10:28:27</div></div><div class=arrow>❯</div></a></nav></div></main><style data-emotion="css 19fp2wc">.css-19fp2wc{font-size:.75rem;line-height:.9rem}.css-19fp2wc p{margin:0 0 1em;padding:0}.css-19fp2wc .badges{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;gap:1em;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-19fp2wc .badges img{border-width:0;width:auto;height:3em}</style><footer class=css-19fp2wc><p>Copyright (C) 2020 ~ 2025 Yeonjin Shin (a.k.a. LiteHell), All rights reserved.<br><a href=/license>This blog is free software; For source code and more informations on license and copyrights, Click here.</a><p>Feeds: <a href=/feed/rss>RSS 2.0</a>, <a href=/feed/atom>Atom</a>, <a href=/feed/json>JSON</a><div class=badges><a href=http://creativecommons.org/licenses/by-sa/4.0/ rel=license><img alt="Creative Commons License"src=https://i.creativecommons.org/l/by-sa/4.0/88x31.png><a href=https://www.gnu.org/licenses/agpl-3.0.en.html><img alt="GNU Affero General License Version 3"src=https://www.gnu.org/graphics/agplv3-with-text-100x42.png></a></a></div></footer></div>