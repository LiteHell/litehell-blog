<!doctypehtml><link href=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 rel=icon><link href=https://blog.litehell.info/post/xabelfish_and_pipewire rel=canonical><link title="RSS 2.0 Feed for blog.litehell.info"href=https://blog.litehell.info/feed/rss rel=alternate type=application/rss+xml><link title="Atom 1.0 Feed for blog.litehell.info"type="	application/atom+xml"href=https://blog.litehell.info/feed/atom rel=alternate><link title="Json 1.0 Feed for blog.litehell.info"href=https://blog.litehell.info/feed/json rel=alternate type=application/feed+json><link href=https://esm.sh/@wooorm/starry-night@3/style/both.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap rel=stylesheet><meta content="XabelFish 개발기 - Pipewire와 XDG Screencast"property=og:title><meta content="리눅스에서 게임 번역기 개발하기"property=og:description><meta content=ko_KR property=og:locale><meta content=blog property=og:type><meta content="LiteHell의 블로그"property=og:site_name><meta content=https://blog.litehell.info/post/xabelfish_and_pipewire property=og:url><meta content=https://blog.litehell.info/screencast.png property=og:image><meta content=width=device-width,initial-scale=1 name=viewport><style>html,body{margin:0;padding:0;font-family:Noto Sans KR,sans-serif}</style><title>LiteHell의 블로그 - XabelFish 개발기 - Pipewire와 XDG Screencast</title><body><link as=image href=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 rel=preload><link as=image href=https://i.creativecommons.org/l/by-sa/4.0/88x31.png rel=preload><link as=image href=https://www.gnu.org/graphics/agplv3-with-text-100x42.png rel=preload><style data-emotion="css 1nfpw07">.css-1nfpw07{--top-padding:max(40px,3rem);--vertical-padding:max(20px,2em);padding:var(--top-padding)var(--vertical-padding)0em var(--vertical-padding);box-sizing:border-box;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;align-items:center;min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-1nfpw07>*{width:100%}@media (width>=1024px){.css-1nfpw07>*{max-width:960px}}.css-1nfpw07 main{-webkit-flex:1;-ms-flex:1;flex:1}.css-1nfpw07 footer{border-top:1px solid #727272;margin:2rem 0 0;padding:1.5rem 0}</style><div class=css-1nfpw07><style data-emotion="css 1fkv74n">.css-1fkv74n{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;align-items:center;gap:2rem;padding-bottom:1.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}@media (width<=25rem){.css-1fkv74n{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}}.css-1fkv74n .profileImg a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.css-1fkv74n .profileImg img{border-radius:4rem;width:8rem;height:8rem;box-shadow:0 3px 6px #00000029,0 3px 6px #0000003b}.css-1fkv74n .title h1{word-break:keep-all;margin:0 0 .5rem;padding:0;font-size:2rem;line-height:2.5rem}.css-1fkv74n .title h1 a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.css-1fkv74n .links{margin:0;padding:0;font-size:.9rem;line-height:1.2rem}@media (width<=1023px){.css-1fkv74n .title h1{font-size:1.5rem;line-height:2rem}.css-1fkv74n .rounded img{border-radius:3.5rem 3.4rem;width:7rem;height:7rem}}</style><header class=css-1fkv74n><div class=profileImg><a href=/><img alt="LiteHell의 Gravatar 아이콘"src=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1></a></div><div class=title><h1><a href=/>LiteHell의 블로그</a></h1><p class=links>외부고리: <a href=https://github.com/litehell>GitHub</a>, <a href=https://yeonjin.name/portfolio>Portfolio</a><br>내부고리: <a href=/categories>카테고리</a>, <a href=/tags>태그</a></div></header><main><div><style data-emotion="css 1v4sk1e">.css-1v4sk1e{border-bottom:1px solid #999;margin-bottom:.8rem;padding:1.5rem 0 2rem}.css-1v4sk1e .title{margin-bottom:.25rem}.css-1v4sk1e .title *{margin:0;padding:0;display:inline}.css-1v4sk1e .title h2{font-size:2rem;line-height:2.1rem}.css-1v4sk1e .title h3{margin-left:1rem;font-size:1rem;font-weight:200;line-height:1rem}.css-1v4sk1e .datetime{color:#666;margin:0;padding:0}.css-1v4sk1e .links .description{color:#666}</style><div class=css-1v4sk1e><div class=title><h2>XabelFish 개발기 - Pipewire와 XDG Screencast</h2><h3>리눅스에서 게임 번역기 개발하기</h3></div><p class=datetime>2025. 7. 26. 오후 10:29:15에 LiteHell이(가) 작성함.<div class=links><div class=link><span class=description>카테고리: </span><a href=/category/Dev>Dev</a></div><div class=link><span class=description>테그: </span><a href=/tag/Linux>Linux</a>, <a href=/tag/Rust>Rust</a></div></div></div><style data-emotion="css 1gzdrlg">.css-1gzdrlg{padding:10px;font-size:1rem;line-height:180%}.css-1gzdrlg pre{background:#f0f0f0;border-radius:6px;padding:.5em 1em;overflow-x:auto}.css-1gzdrlg code{font-family:monoscape}.css-1gzdrlg h1{margin:1.8rem 0;font-size:1.8rem}.css-1gzdrlg h1:before{content:"# ";color:#a19c91}.css-1gzdrlg h2{margin:1.6rem 0;font-size:1.6rem}.css-1gzdrlg h2:before{content:"## ";color:#a19c91}.css-1gzdrlg h3{margin:1.4rem 0;font-size:1.4rem}.css-1gzdrlg h3:before{content:"### ";color:#a19c91}.css-1gzdrlg h4{margin:1.2rem 0;font-size:1.2rem}.css-1gzdrlg h5{margin:1.15rem 0;font-size:1.15rem}.css-1gzdrlg h5:before{content:"> ";color:#a19c91}.css-1gzdrlg h6{margin:1.1rem 0;font-size:1.1rem}.css-1gzdrlg h6:before{content:">> ";color:#a19c91}.css-1gzdrlg img,.css-1gzdrlg iframe{max-width:80%;margin:0 auto;display:block}.css-1gzdrlg table{white-space:nowrap;border-collapse:collapse;display:block;overflow-x:auto}.css-1gzdrlg table td,.css-1gzdrlg table tr,.css-1gzdrlg table th{border:1px solid gray}.css-1gzdrlg table th{font-weight:700}.css-1gzdrlg table th,.css-1gzdrlg table td{padding:5px 10px}.css-1gzdrlg table thead{background:#d8d8d8}.css-1gzdrlg blockquote{background:#c2c2c2;border-left:5px solid #4e4e4e;margin:25px 10px 25px 30px;padding:10px 50px}.css-1gzdrlg ul li,.css-1gzdrlg ol li{margin:6px 0}</style><article class=css-1gzdrlg><h1>들어가는 글</h1><p>일본어를 모르면서 일본 게임을 하려면 번역기를 써야한다. 요즘 번역기가 잘 되어 있긴 한데 너무 불편하다. 이런 사람들을 위한 게임 번역 프로그램이 있다. 대표적으로 윈도우에서는 <a href=https://blog.naver.com/killkimno/223907695562>Mort</a>나 <a href=https://github.com/sokcuri/anemone>아네모네</a>+후커 조합이 있다. 근데 리눅스에는 비슷한 게 없다.<p>없으면... 만들면 되잖아? 그래서 만들어 보았다.<h1>구상</h1><p>구상은 다음과 같다.<ol><li>특정 영역이나 창을 선택한다.<li>다음을 무한 반복한다. <ol><li>스크린샷을 찍는다.<li>OCR을 돌린다.<li>텍스트를 번역한다.<li>번역된 텍스트를 표시한다.</ol></ol><p>Mort랑 똑같다. 이제 어떻게 만들지가 문제다.<h2>첫번째 구상: KWin과의 강결합</h2><p>필자는 <a href=https://kde.org/plasma-desktop/>KDE Plasma</a>를 쓴다. KDE에서는 스크린샷 프로그램으로 <a href=https://invent.kde.org/plasma/spectacle>Spectacle</a>을 제공한다. 어처피 개인적으로 쓰려고 만든거니 KDE에서만 돌아가도 상관없다. 그러면 해당 Spectacle 소스코드를 잘 살펴보면 되지 않을까? 이때 이름은 <strong>K</strong>DE + B<strong>abelfish</strong>라는 의미에서 <strong>Kabelfish</strong>라는 이름을 점찍어 두고 있었다.<p>Spectacle 소스코드를 살펴본 결과 Spectacle과 KWin 사이에서는 DBus를 이용하여 통신하는 것으로 보인다. 여기까진 예상했다. 근데 DBus로 통신할 때 <a href=https://www.qt.io/>Qt</a>에서 제공하는 자료형을 쓴다. 이건 예상 못했는데?<p>어처피 <a href=https://www.rust-lang.org/>Rust</a>(필자는 힙스터 기질이 있다)와 Qt 바인딩을 써서 <a href=https://develop.kde.org/frameworks/kirigami//>Kirigami</a> 기반으로 만들 생각이긴 했으나... DBus 통신할 때 Qt D-Bus 묘듈을 이용해서 Qt 자료형을 쓰면 개발이 과연 쉬울까? Rust-Qt 바인딩을 써본 적이 없어서 확신이 없었다. (바인딩 퀼리티가 꽝이면 개발 과정이 썩 즐겁지가 않다. 아시다시피 Rust라는 언어 자체가 까탈스럽다보니...) 그렇다고 C++ + Qt로 개발하자니 이건 아닌 것 같고... 그래서 고민하다가 다른 분께 의견을 요청했다.<h2>두번째 구상: Pipewire</h2><p><a href=https://keyoxide.org/00120513451AAC4DEFE2832711AB9E784263E186>깻잎</a>님께서 Pipewire를 써보라는 제안을 하셨다. <a href=https://wayland.freedesktop.org/>Wayland</a> 기반 리눅스 DE에서 화면을 녹화하는 표준적인 방법이라고 하셨다. 생각해보니 나쁘지 않은 것 같아 채택하였다.<h3>Pipewire</h3><p>Pipewire는 리눅스에서 오디오/비디오 스트림을 핸들링하기 위한 로우레벨 프레임워크이다. Rust에서 pipewire를 이용하기 위해서는 Rust에서는 <a href=https://pipewire.pages.freedesktop.org/pipewire-rs/pipewire/index.html>pipewire</a> carte를 이용하면 된다. 게임 번역기를 만드는 게 목적이니 오디오 스트림은 다루지 않는다.<h4>과정</h4><p>Pipewire의 비디오 스트림 핸들링 과정을 진짜 간략히 요약하면 다음과 같다.<ol><li>메인 루프랑 이것저것을 생성한다.<li>메인 루프에 핸들러 함수를 설정한다.<li>루프를 실행한다. (Blocking)</ol><pre><code class=language-rust>    <span class=pl-k>let</span> <span class=pl-smi>mainloop</span> <span class=pl-k>=</span> <span class=pl-en>MainLoop</span><span class=pl-k>::</span><span class=pl-en>new</span>(<span class=pl-en>None</span>)<span class=pl-k>?</span>;
    <span class=pl-k>let</span> <span class=pl-smi>context</span> <span class=pl-k>=</span> <span class=pl-en>Context</span><span class=pl-k>::</span><span class=pl-en>new</span>(<span class=pl-k>&</span><span class=pl-smi>mainloop</span>)<span class=pl-k>?</span>;
    <span class=pl-k>let</span> <span class=pl-smi>core</span> <span class=pl-k>=</span> <span class=pl-smi>context</span><span class=pl-k>.</span><span class=pl-en>connect</span>(<span class=pl-en>None</span>)<span class=pl-k>?</span>;
    <span class=pl-k>let</span> <span class=pl-smi>registry</span> <span class=pl-k>=</span> <span class=pl-smi>core</span><span class=pl-k>.</span><span class=pl-en>get_registry</span>()<span class=pl-k>?</span>;

    <span class=pl-c>// Do something here....</span>

    <span class=pl-smi>mainloop</span><span class=pl-k>.</span><span class=pl-en>run</span>(); 
    <span class=pl-c>// 위 코드에서 Blocking이 일어나기 때문에</span>
    <span class=pl-c>// 아래 코드는 실행되지 않는다.</span>
    <span class=pl-en>println!</span>(<span class=pl-s><span class=pl-pds>"</span>This code will not be reached<span class=pl-pds>"</span></span>);
</code></pre><p>고전적이다. Pipewire 루프는 Blocking이기 때문에 해당 루프는 별도의 스레드에서 구동한다. 잠깐, 근데 별도의 스레드에서 구동되면 Pipewire 루프는 어떻게 중단하지?<p>pipewire-rs에서는 이를 위해 <a href=https://pipewire.pages.freedesktop.org/pipewire-rs/pipewire/channel/index.html>pipewire::channel</a> 모듈을 제공한다. 해당 모듈을 이용하면 <a href=https://doc.rust-lang.org/std/sync/mpsc/>Rust mpsc</a>와 유사한 방법으로 Pipewire 메인루프와 외부 스레드 간에 통신할 수 있다. 이걸 이용하여 외부 스레드로부터 메세지가 수신되면 메인루프를 종료하는 식으로 pipewire 루프를 중단할 수 있다.<pre><code class=language-rust>    <span class=pl-k>let</span> <span class=pl-smi>mainloop</span> <span class=pl-k>=</span> <span class=pl-en>MainLoop</span><span class=pl-k>::</span><span class=pl-en>new</span>(<span class=pl-en>None</span>)<span class=pl-k>?</span>;
    <span class=pl-k>let</span> <span class=pl-smi>context</span> <span class=pl-k>=</span> <span class=pl-en>Context</span><span class=pl-k>::</span><span class=pl-en>new</span>(<span class=pl-k>&</span><span class=pl-smi>mainloop</span>)<span class=pl-k>?</span>;
    <span class=pl-k>let</span> <span class=pl-smi>core</span> <span class=pl-k>=</span> <span class=pl-smi>context</span><span class=pl-k>.</span><span class=pl-en>connect</span>(<span class=pl-en>None</span>)<span class=pl-k>?</span>;
    <span class=pl-k>let</span> <span class=pl-smi>registry</span> <span class=pl-k>=</span> <span class=pl-smi>core</span><span class=pl-k>.</span><span class=pl-en>get_registry</span>()<span class=pl-k>?</span>;

    <span class=pl-c>// pw_sender는 pipewire가 실행되는 스레드 외부에서 이용된다.</span>
    <span class=pl-k>let</span> (<span class=pl-smi>pw_sender</span>, <span class=pl-smi>pw_receiver</span>) <span class=pl-k>=</span> <span class=pl-en>pipewire</span><span class=pl-k>::</span><span class=pl-en>channel</span><span class=pl-k>::</span><span class=pl-en>channel</span>();

    <span class=pl-c>// Do something here....</span>
    
    <span class=pl-c>// pipewire가 실행되는 스레드 외부에서 pw_sender를 이용해 메세지를 전송하면</span>
    <span class=pl-c>// 아래 코드에 의해 메인 루프가 중단된다.</span>
    <span class=pl-k>let</span> <span class=pl-smi>_receiver</span> <span class=pl-k>=</span> <span class=pl-smi>pw_receiver</span><span class=pl-k>.</span><span class=pl-en>attach</span>(<span class=pl-smi>mainloop</span><span class=pl-k>.</span><span class=pl-en>loop_</span>(), {
        <span class=pl-k>let</span> <span class=pl-smi>mainloop</span> <span class=pl-k>=</span> <span class=pl-smi>mainloop</span><span class=pl-k>.</span><span class=pl-en>clone</span>();
        <span class=pl-k>move</span> <span class=pl-k>|</span><span class=pl-smi>_</span><span class=pl-k>|</span> <span class=pl-smi>mainloop</span><span class=pl-k>.</span><span class=pl-en>quit</span>()
    });

    <span class=pl-smi>mainloop</span><span class=pl-k>.</span><span class=pl-en>run</span>(); 
</code></pre><p>pipewire를 이용해 비디오 스트림을 다루는 방법은 <a href=https://docs.rs/crate/pipewire/latest/source/examples/streams.rs>pipewire-rs 예제코드</a>와 <a href=https://docs.pipewire.org/page_tutorial5.html>관련 pipewire 공식 튜토리얼</a>을 참고하자.<h3>XDG Desktop Portal</h3><p>Pipewire를 이용하여 비디오 스트림을 다룰 수 있다는 걸 알았다. 그러면 그 비디오 스트림은 이제 어떻게 구할 수 있을까? <a href=https://flatpak.github.io/xdg-desktop-portal/docs/doc-org.freedesktop.portal.ScreenCast.html>XDG Desktop Portal의 Screencast</a>을 이용하면 된다.<p><img alt="Screencast 창/영역 선택 창"src=./screencast.png><p>Screencast를 쓰면 위와 같은 창이 뜬다. 리눅스에서 <a href=https://obsproject.com/>OBS Studio</a>를 써봤다면 익숙할 수도 있다.<p>Screencast는 D-Bus를 쓴다. 따라서 D-Bus를 이용하여 통신해야 하는데, 찾아보니 <a href=https://crates.io/crates/portal-screencast>다른 사람이 만들어둔 crate</a>가 있었다. 그래서 그냥 그거 썼다. 편하게 살자.<pre><code class=language-rust>    <span class=pl-k>let</span> <span class=pl-smi>screen_cast</span> <span class=pl-k>=</span> <span class=pl-en>portal_screencast</span><span class=pl-k>::</span><span class=pl-en>ScreenCast</span><span class=pl-k>::</span><span class=pl-en>new</span>()
        <span class=pl-k>.</span><span class=pl-en>expect</span>(<span class=pl-s><span class=pl-pds>"</span>Failed to initialize xdg-portal-screencast session<span class=pl-pds>"</span></span>);
    <span class=pl-k>let</span> <span class=pl-smi>selected</span> <span class=pl-k>=</span> <span class=pl-smi>screen_cast</span><span class=pl-k>.</span><span class=pl-en>start</span>(<span class=pl-en>None</span>)<span class=pl-k>.</span><span class=pl-en>expect</span>(<span class=pl-s><span class=pl-pds>"</span>Failed to select share<span class=pl-pds>"</span></span>);
    <span class=pl-smi>selected</span> <span class=pl-c>// stream에 pipewire node id가 있다. 이를 이용하여 pipewire로 핸들링하면 된다. </span>
</code></pre><h1>최종 구상</h1><p>따라서 전체적인 구상은 다음과 같다.<ol><li>XDG Desktop Portal로 특정 영역이나 창을 선택한다.<li>다음을 무한 반복한다. <ol><li>비디오 프레임을 이미지로 저장한다.<li>OCR을 돌린다.<li>텍스트를 번역한다.<li>번역된 텍스트를 표시한다.</ol></ol><p>위를 좀 더 구체적으로 적으면 다음과 같다.<ol><li>XDG Desktop Portal로 특정 영역이나 창을 선택한다.<li>다음을 무한 반복한다. <ol><li>비디오 프레임을 이미지로 저장한다.<li>OCR을 돌린다.<li>텍스트를 번역한다.<li>번역된 텍스트를 표시한다.</ol></ol><p>Pipewire 관련 struct는 <a href=https://doc.rust-lang.org/std/ops/trait.Drop.html>Drop trait</a>를 구현했다. 이러면 Pipewire 메인 루프 중단을 편하게 구현할 수 있다.<h2>OCR과 번역</h2><p>OCR은 <a href=https://github.com/tesseract-ocr/tesseract>Tessearact</a>를 쓰고 번역은 <a href=https://www.deepl.com>DeepL API</a>를 썼다. 원래는 <a href=https://libretranslate.com/>LibreTranslate</a>를 쓰려고 했는데 이거 한일번역 성능이 너무 안 좋아서 안 썼다.<p>GUI는 Qt쓸지 GTK쓸지 계속 고민하다가 <a href=https://tauri.app/>Tauri</a>를 썼다. 간단하게 써서 그런가 좋긴 좋았다.<h1>결론</h1><p><img alt=스크린샷 src=./screenshot.png><p>되긴 되는데 좀 불편하다. 시간날 때마다 고쳐야지...<p><a href=https://github.com/litehell/xabelfish>소스 코드는 GitHub에서 볼 수 있다.</a></article><style data-emotion="css ly0ba3">.css-ly0ba3 .utterances{max-width:100%!important}</style><div class=css-ly0ba3><script label="blog comment"async crossorigin issue-term=og:title repo=LiteHell/litehell-blog src=https://utteranc.es/client.js theme=github-light></script></div><style data-emotion="css eyxei3">.css-eyxei3{-webkit-box-flex-wrap:wrap;-webkit-flex-flow:wrap;-ms-flex-flow:wrap;flex-flow:wrap;justify-content:space-between;gap:1em .5em;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-eyxei3 a{-webkit-text-decoration:none;text-decoration:none}.css-eyxei3 .inner{vertical-align:top;display:inline-block}.css-eyxei3 .inner .title{font-size:1.3em;line-height:1.3rem}.css-eyxei3 .inner .subtitle{margin-top:.2rem;font-size:1rem;font-weight:200;line-height:1rem}.css-eyxei3 .inner .date{font-size:.8em;font-weight:200;line-height:.8rem}.css-eyxei3 .next,.css-eyxei3 .previous{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;gap:.5em;width:max-content;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-eyxei3 .next.next,.css-eyxei3 .previous.next{text-align:right;margin-left:auto}.css-eyxei3 .next.previous,.css-eyxei3 .previous.previous{text-align:left}.css-eyxei3 .next .inner,.css-eyxei3 .previous .inner{-webkit-flex:1;-ms-flex:1;flex:1}</style><nav class=css-eyxei3><div class=noop>첫 게시글입니다.</div><a class=next href=/post/rewriting_blog_2025><div class=inner><div class=title>블로그 재작성한 이야기</div><div class=subtitle>튜닝의 끝은 순정</div><div class=date>2025. 6. 18. 오후 10:04:30</div></div><div class=arrow>❯</div></a></nav></div></main><style data-emotion="css 19fp2wc">.css-19fp2wc{font-size:.75rem;line-height:.9rem}.css-19fp2wc p{margin:0 0 1em;padding:0}.css-19fp2wc .badges{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;gap:1em;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-19fp2wc .badges img{border-width:0;width:auto;height:3em}</style><footer class=css-19fp2wc><p>Copyright (C) 2020 ~ 2025 Yeonjin Shin (a.k.a. LiteHell), All rights reserved.<br><a href=/license>This blog is free software; For source code and more informations on license and copyrights, Click here.</a><p>Feeds: <a href=/feed/rss>RSS 2.0</a>, <a href=/feed/atom>Atom</a>, <a href=/feed/json>JSON</a><div class=badges><a href=http://creativecommons.org/licenses/by-sa/4.0/ rel=license><img alt="Creative Commons License"src=https://i.creativecommons.org/l/by-sa/4.0/88x31.png><a href=https://www.gnu.org/licenses/agpl-3.0.en.html><img alt="GNU Affero General License Version 3"src=https://www.gnu.org/graphics/agplv3-with-text-100x42.png></a></a></div></footer></div>