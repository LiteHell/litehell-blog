<!doctypehtml><html lang=ko><link href=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 rel=icon><link href=https://blog.litehell.info/post/docker_for_testing rel=canonical><link href=https://blog.litehell.info/post/docker_for_testing hreflang=ko rel=alternate><link href=https://blog.litehell.info/post/docker_for_testing hreflang=en rel=alternate><link title="RSS 2.0 Feed for LiteHell's blog"href=https://blog.litehell.info/feed/rss rel=alternate type=application/rss+xml><link title="Atom 1.0 Feed for LiteHell's blog"type="	application/atom+xml"href=https://blog.litehell.info/feed/atom rel=alternate><link title="Json 1.0 Feed for LiteHell's blog"href=https://blog.litehell.info/feed/json rel=alternate type=application/feed+json><link href=https://esm.sh/@wooorm/starry-night@3/style/both.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap rel=stylesheet><meta content="Docker로 테스트하기"property=og:title><meta content="Docker로 빌드만 하지 말고 테스트도 하자"property=og:description><meta content=ko property=og:locale><meta content=blog property=og:type><meta content="LiteHell의 블로그"property=og:site_name><meta content=https://blog.litehell.info/post/docker_for_testing property=og:url><meta content=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 property=og:image><meta content=width=device-width,initial-scale=1 name=viewport><style>html,body{margin:0;padding:0;font-family:Noto Sans KR,sans-serif}</style><title>LiteHell의 블로그 - Docker로 테스트하기</title><body><link as=image href=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 rel=preload><link as=image href=https://i.creativecommons.org/l/by-sa/4.0/88x31.png rel=preload><link as=image href=https://www.gnu.org/graphics/agplv3-with-text-100x42.png rel=preload><style data-emotion="css 1nfpw07">.css-1nfpw07{--top-padding:max(40px,3rem);--vertical-padding:max(20px,2em);padding:var(--top-padding)var(--vertical-padding)0em var(--vertical-padding);box-sizing:border-box;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;align-items:center;min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-1nfpw07>*{width:100%}@media (width>=1024px){.css-1nfpw07>*{max-width:960px}}.css-1nfpw07 main{-webkit-flex:1;-ms-flex:1;flex:1}.css-1nfpw07 footer{border-top:1px solid #727272;margin:2rem 0 0;padding:1.5rem 0}</style><div class=css-1nfpw07><style data-emotion="css 1fkv74n">.css-1fkv74n{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;align-items:center;gap:2rem;padding-bottom:1.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}@media (width<=25rem){.css-1fkv74n{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}}.css-1fkv74n .profileImg a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.css-1fkv74n .profileImg img{border-radius:4rem;width:8rem;height:8rem;box-shadow:0 3px 6px #00000029,0 3px 6px #0000003b}.css-1fkv74n .title h1{word-break:keep-all;margin:0 0 .5rem;padding:0;font-size:2rem;line-height:2.5rem}.css-1fkv74n .title h1 a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.css-1fkv74n .links{margin:0;padding:0;font-size:.9rem;line-height:1.2rem}@media (width<=1023px){.css-1fkv74n .title h1{font-size:1.5rem;line-height:2rem}.css-1fkv74n .rounded img{border-radius:3.5rem 3.4rem;width:7rem;height:7rem}}</style><header class=css-1fkv74n><div class=profileImg><a href=/><img alt="LiteHell의 Gravatar 아이콘"src=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1></a></div><div class=title><h1><a href=/>LiteHell의 블로그</a></h1><p class=links>외부고리: <a href=https://github.com/litehell>GitHub</a>, <a href=https://yeonjin.name/portfolio>Portfolio</a><br>내부고리: <a href=/categories>카테고리</a>, <a href=/tags>태그</a><br>다른 언어: <a href=https://blog-en.litehell.info hreflang=en>영어 (English)</a></p><style data-emotion="css u1wea8">.css-u1wea8{color:#5e5e5e;font-size:75%}</style><p class=css-u1wea8>글 쓸 때는 AI를 안 씁니다. 전부 직접 씁니다. 만약 오탈자나 어색한 문장이 있다면 퇴고를 대충해서 그런거니 양해 부탁드립니다.</div></header><main><div><style data-emotion="css 1v4sk1e">.css-1v4sk1e{border-bottom:1px solid #999;margin-bottom:.8rem;padding:1.5rem 0 2rem}.css-1v4sk1e .title{margin-bottom:.25rem}.css-1v4sk1e .title *{margin:0;padding:0;display:inline}.css-1v4sk1e .title h2{font-size:2rem;line-height:2.1rem}.css-1v4sk1e .title h3{margin-left:1rem;font-size:1rem;font-weight:200;line-height:1rem}.css-1v4sk1e .datetime{color:#666;margin:0;padding:0}.css-1v4sk1e .links .description{color:#666}</style><div class=css-1v4sk1e><div class=title><h2>Docker로 테스트하기</h2><h3>Docker로 빌드만 하지 말고 테스트도 하자</h3></div><p class=datetime>2023. 10. 25. 오후 11:49:49에 LiteHell이(가) 작성하고 2024-12-27T13:05:23.710Z에 수정함.<div class=links><div class=link><span class=description>카테고리: </span><a href=/category/Dev>Dev</a></div><div class=link><span class=description>태그: </span><a href=/tag/Docker>Docker</a></div></div></div><style data-emotion="css 1gzdrlg">.css-1gzdrlg{padding:10px;font-size:1rem;line-height:180%}.css-1gzdrlg pre{background:#f0f0f0;border-radius:6px;padding:.5em 1em;overflow-x:auto}.css-1gzdrlg code{font-family:monoscape}.css-1gzdrlg h1{margin:1.8rem 0;font-size:1.8rem}.css-1gzdrlg h1:before{content:"# ";color:#a19c91}.css-1gzdrlg h2{margin:1.6rem 0;font-size:1.6rem}.css-1gzdrlg h2:before{content:"## ";color:#a19c91}.css-1gzdrlg h3{margin:1.4rem 0;font-size:1.4rem}.css-1gzdrlg h3:before{content:"### ";color:#a19c91}.css-1gzdrlg h4{margin:1.2rem 0;font-size:1.2rem}.css-1gzdrlg h5{margin:1.15rem 0;font-size:1.15rem}.css-1gzdrlg h5:before{content:"> ";color:#a19c91}.css-1gzdrlg h6{margin:1.1rem 0;font-size:1.1rem}.css-1gzdrlg h6:before{content:">> ";color:#a19c91}.css-1gzdrlg img,.css-1gzdrlg iframe{max-width:80%;margin:0 auto;display:block}.css-1gzdrlg table{white-space:nowrap;border-collapse:collapse;display:block;overflow-x:auto}.css-1gzdrlg table td,.css-1gzdrlg table tr,.css-1gzdrlg table th{border:1px solid gray}.css-1gzdrlg table th{font-weight:700}.css-1gzdrlg table th,.css-1gzdrlg table td{padding:5px 10px}.css-1gzdrlg table thead{background:#d8d8d8}.css-1gzdrlg blockquote{background:#c2c2c2;border-left:5px solid #4e4e4e;margin:25px 10px 25px 30px;padding:10px 50px}.css-1gzdrlg ul li,.css-1gzdrlg ol li{margin:6px 0}</style><article class=css-1gzdrlg><h1>들어가는 글</h1><p>필자는 중앙대학교 공지사항을 <a href=https://rss.puang.network>RSS</a>로 만들어서 구독한다. RSS로 만든 후 메신지 봇을 붙이면 알아서 알려주니 편하다.<p>그러나 최근 해당 RSS 프로그램의 테스트가 실패하는 현상이 발견됐다. 확인한 결과, <a href=https://swedu.cau.ac.kr>중앙대학교 SW교육원</a> 홈페이지의 TLS 인증서 이슈였던 것으로 확인됐다. 따라서 이를 해결하기 위해 일단 실행되고 있는 Docker 컨테이너에 직접 접근해서 해당 사이트의 CA 인증서를 설치했다.<h1>기존 테스트 방법의 한계점</h1><p>버그는 일단 임시방편으로 수정한 것이니 레포에는 반영되지 않았다. 따라서 테스트 실패 메일이 매일매일 내 메일함으로 전송됐다.<p>어떻게 하면 이 버그를 수정하고 잘 테스트할 수 있을까? 먼저 이 버그를 수정하려면 Dockerfile을 수정해야 한다. Dockerfile에 다음 내용을 추가하여 Docker 이미지 빌드시 CA 인증서를 복사하도록 했다. <a href=https://github.com/LiteHell/cau-rss/commit/d765d53d61e9370f5a284068ed273570d21013a3>LiteHell/cau-rss 레포의 커밋 21013a3</a>에서 확인할 수 있다.<pre><code class=language-Dockerfile>COPY swedu-cert.pem /usr/local/share/ca-certificates/swedu-cert.crt
RUN cat /usr/local/share/ca-certificates/swedu-cert.crt >> /etc/ssl/certs/ca-certificates.crt
</code></pre><p>이제 위 버그 수정도 같이 테스트해야 한다. 아래에 있는 기존의 GitHub Action으로는 이 버그 수정을 테스트할 수 없다. <code>go test -v ./...</code> 명령어가 빌드된 Docker 이미지 내에서 실행되는 것이 아니기 때문이다.<pre><code class=language-yaml>      - <span class=pl-ent>name</span>: <span class=pl-s>Build</span>
        <span class=pl-ent>run</span>: <span class=pl-s>go build -v ./...</span>

      - <span class=pl-ent>name</span>: <span class=pl-s>Test</span>
        <span class=pl-ent>run</span>: <span class=pl-s>go test -v ./...</span>
</code></pre><p>어떻게 하면 테스트할 수 있을까? 답은 간단하다. Docker로 테스트도 하면 된다.<h1>Docker를 이용한 테스트</h1><h2>Multi-stage 빌드</h2><p>Docker는 빌드를 여러 단계로 나누어 진행할 수 있다. 아래 예시 Dockerfile을 보자.<pre><code class=language-Dockerfile>FROM node AS base
WORKDIR /app
ADD src package.json package-lock.json tsconfig.json .

RUN npm i
RUN npm bulid

CMD ["npm", "run", "start"]
</code></pre><p>Typescript 프로젝트를 위한 간단한 Dockerfile이다. 이를 다음과 같이 여러개의 단계(stage)로 쪼갤 수 있다.<pre><code class=language-Dockerfile>FROM node AS base
WORKDIR /app
ADD src package.json package-lock.json tsconfig.json .

FROM base AS deps
RUN npm i

FROM deps AS build
RUN npm bulid

FROM build AS deployment
CMD ["npm", "run", "start"]

</code></pre><p>위와 같은 Dockerfile을 이용하면 Docker 빌드시 특정 스테이지까지만 빌드할 수 있다. 예를 들어 아래 명령어는 deps 스테이지까지만 빌드한다.<pre><code class=language-bash>docker build --target deps
</code></pre><p>스테이지가 직선적이여야 할 필요는 없다. 다음과 같이 스테이지가 중간에 분기하도록 작성할 수도 있다.<pre><code class=language-Dockerfile>FROM node AS base
WORKDIR /app
ADD src package.json package-lock.json tsconfig.json .

FROM base AS deps
RUN npm i

FROM deps AS build
RUN npm bulid

FROM build AS english
COPY english .

FROM english AS deployment-international
CMD ["npm", "run", "start", "--lang=english"]

FROM build AS korean
COPY korean .

FROM korean AS deployment-domestic
CMD ["npm", "run", "start", "--lang=korean"]
</code></pre><p>위 Dockerfile의 경우 build 스테이지에서 english 스테이지와 korean 스테이지로 분기한다.<h3>BuildKit</h3><pre><code class=language-Dockerfile>FROM node AS base
WORKDIR /app
ADD src package.json package-lock.json tsconfig.json .

FROM base AS deps
RUN npm i

FROM deps AS build
RUN npm bulid

FROM build AS english
COPY english .

FROM english AS deployment-international
CMD ["npm", "run", "start", "--lang=english"]

FROM build AS korean
COPY korean .

FROM korean AS deployment-domestic
CMD ["npm", "run", "start", "--lang=korean"]
</code></pre><p>위 Dockerfile을 가지고 아래 명령어를 실행한다고 가정해보자.<pre><code class=language-bash>docker build --target deployment-domestic
</code></pre><p>위 경우 빌드에 필요한 스테이지는 <code>base</code>, <code>deps</code>, <code>build</code>, <code>korean</code>, <code>deployment-domestic</code>이다. 그러나 실제로 위 명령어를 실행해보면 불필요한 <code>english</code>, <code>deployment-international</code> 스테이지도 빌드하는 것을 확인할 수 있다.<p>이는 도커 레거시 빌더를 이용하기 때문에 생기는 문제이다. <a href=https://docs.docker.com/build/buildkit/>Docker BuildKit</a>은 사용되지 않는 스테이지를 자동으로 파악하여 불필요한 스테이지는 빌드를 생략한다. 따라서 Docker BuildKit을 설치한 후 다음 명령어로 빌드하면 필요한 스테이지만 빌드할 수 있다.<pre><code class=language-bash>DOCKER_BUILDKIT=1 docker build --target deployment-domestic
</code></pre><h2>Multi-stage 빌드를 이용한 테스트</h2><p>이제 Docker를 이용해 테스트를 하는 방법에 대해 알아보자. 다음은 <a href=https://github.com/LiteHell/cau-rss>cau-rss 레포</a>의 Dockerfile 내용을 약간 수정한 예시이다.<pre><code class=language-Dockerfile>FROM golang:alpine AS base
WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download && go mod verify

COPY cau_parser ./cau_parser
COPY server ./server

# To avoid tls error from swedu.cau.ac.kr
COPY swedu-cert.pem /usr/local/share/ca-certificates/swedu-cert.crt
RUN cat /usr/local/share/ca-certificates/swedu-cert.crt >> /etc/ssl/certs/ca-certificates.crt

COPY static ./static
COPY html ./html

COPY *.go ./

FROM base AS build
RUN go build -v -o ./app ./
CMD ["/app/app"]

FROM base AS test
RUN ["go", "test" ,"-v", "./..."]

</code></pre><p><code>base</code> 스테이지에서 의존성을 설치한 뒤 각종 필요한 파일들을 복사하고 TLS 인증서 오류 해결을 위한 CA 인증서를 복사한다. <code>test</code> 스테이지는 <code>base</code> 스테이지에서 테스트 명령어를 실행하는 스테이지이며, <code>build</code> 스테이지는 <code>base</code> 스테이지를 바탕으로 도커 이미지를 빌드하는 스테이지이다.<p>따라서 위 Dockerfile을 이용해 <code>build</code> 스테이지까지 빌드하면 도커 이미지를 만드는 것이며, <code>test</code> 스테이지까지 빌드하면 테스트를 실행하게 되는 것이다. 이를 명령어로 나타내면 다음과 같으며, 캐시로 인해 테스트가 진행되지 않는 것을 방지하기 위해 <code>--no-cache</code> 매개변수를 추가했다.<pre><code class=language-bash><span class=pl-c># Test</span>
DOCKER_BUILDKIT=1 docker build --no-cache --target <span class=pl-c1>test</span> <span class=pl-c1>.</span>

<span class=pl-c># Build</span>
DOCKER_BUILDKIT=1 docker build --target build
</code></pre><p>테스트 실패시 Docker 빌드 오류가 발생한다. 이를 응용하면 다음과 같이 테스트 성공시 빌드를 진행하고, 실패시 오류 메세지를 출력하는 bash 스크립트를 작성할 수 있다.<pre><code class=language-bash><span class=pl-k>export</span> DOCKER_BUILDKIT=1

docker build --no-cache --target <span class=pl-c1>test</span> <span class=pl-c1>.</span>
test_status=<span class=pl-smi>$?</span>
<span class=pl-k>if</span> [ <span class=pl-smi>$test_status</span> <span class=pl-k>-eq</span> 0 ]<span class=pl-k>;</span> <span class=pl-k>then</span>
  docker build --taget build <span class=pl-c1>.</span> --tag example-application
<span class=pl-k>else</span>
  <span class=pl-c1>echo</span> <span class=pl-s><span class=pl-pds>"</span>ERROR while testing!<span class=pl-pds>"</span></span>
<span class=pl-k>fi</span>
</code></pre><h2>Github Action을 이용한 활용</h2><p>GitHub Action을 이용하면 다음과 같이 push시 테스트가 이루어지도록 할 수 있다.<pre><code class=language-yaml><span class=pl-ent>name</span>: <span class=pl-s>Test</span>
<span class=pl-ent>on</span>: <span class=pl-s>push</span>

<span class=pl-ent>jobs</span>:
  <span class=pl-ent>test</span>:
    <span class=pl-ent>runs-on</span>: <span class=pl-s>ubuntu-latest</span>
    <span class=pl-ent>steps</span>:
      - <span class=pl-ent>uses</span>: <span class=pl-s>actions/checkout@v3</span>

      - <span class=pl-ent>name</span>: <span class=pl-s>Set up Docker Buildx</span>
        <span class=pl-ent>uses</span>: <span class=pl-s>docker/setup-buildx-action@v3</span>

      - <span class=pl-ent>name</span>: <span class=pl-s>Test</span>
        <span class=pl-ent>run</span>: <span class=pl-s>docker build --no-cache --target test .</span>
        <span class=pl-ent>env</span>:
          <span class=pl-ent>DOCKER_BUILDKIT</span>: <span class=pl-c1>1</span>

</code></pre><p>빌드도 잘 되는지 확인하고 싶다면 빌드하는 job을 하나 더 추가하면 된다.<pre><code class=language-yaml><span class=pl-ent>name</span>: <span class=pl-s>Build and test</span>
<span class=pl-ent>on</span>: <span class=pl-s>push</span>

<span class=pl-ent>jobs</span>:
  <span class=pl-ent>build</span>:
    <span class=pl-ent>runs-on</span>: <span class=pl-s>ubuntu-latest</span>
    <span class=pl-ent>steps</span>:
      - <span class=pl-ent>uses</span>: <span class=pl-s>actions/checkout@v3</span>

      - <span class=pl-ent>name</span>: <span class=pl-s>Set up Docker Buildx</span>
        <span class=pl-ent>uses</span>: <span class=pl-s>docker/setup-buildx-action@v3</span>

      - <span class=pl-ent>name</span>: <span class=pl-s>Build</span>
        <span class=pl-ent>run</span>: <span class=pl-s>docker build --target build .</span>
        <span class=pl-ent>env</span>:
          <span class=pl-ent>DOCKER_BUILDKIT</span>: <span class=pl-c1>1</span>

  <span class=pl-ent>test</span>:
    <span class=pl-ent>runs-on</span>: <span class=pl-s>ubuntu-latest</span>
    <span class=pl-ent>steps</span>:
      - <span class=pl-ent>uses</span>: <span class=pl-s>actions/checkout@v3</span>

      - <span class=pl-ent>name</span>: <span class=pl-s>Set up Docker Buildx</span>
        <span class=pl-ent>uses</span>: <span class=pl-s>docker/setup-buildx-action@v3</span>

      - <span class=pl-ent>name</span>: <span class=pl-s>Test</span>
        <span class=pl-ent>run</span>: <span class=pl-s>docker build --no-cache --target test .</span>
        <span class=pl-ent>env</span>:
          <span class=pl-ent>DOCKER_BUILDKIT</span>: <span class=pl-c1>1</span>

</code></pre><h1>결론</h1><p>Docker 이미지로 배포를 진행하는 경우, Docker로 테스트도 같이 진행하면 실제 배포 환경과 유사한 환경에서 테스트를 진행할 수 있다는 큰 장점이 있다. 따라서 복잡한 어플리케이션이라면 이 글을 참고해 Docker로 테스트도 같이 하는 것이 좋은 선택이 될 수 있다.</article><style data-emotion="css ly0ba3">.css-ly0ba3 .utterances{max-width:100%!important}</style><div class=css-ly0ba3><script label="blog comment"async crossorigin issue-term=og:title repo=LiteHell/litehell-blog src=https://utteranc.es/client.js theme=github-light></script></div><style data-emotion="css eyxei3">.css-eyxei3{-webkit-box-flex-wrap:wrap;-webkit-flex-flow:wrap;-ms-flex-flow:wrap;flex-flow:wrap;justify-content:space-between;gap:1em .5em;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-eyxei3 a{-webkit-text-decoration:none;text-decoration:none}.css-eyxei3 .inner{vertical-align:top;display:inline-block}.css-eyxei3 .inner .title{font-size:1.3em;line-height:1.3rem}.css-eyxei3 .inner .subtitle{margin-top:.2rem;font-size:1rem;font-weight:200;line-height:1rem}.css-eyxei3 .inner .date{font-size:.8em;font-weight:200;line-height:.8rem}.css-eyxei3 .next,.css-eyxei3 .previous{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;gap:.5em;width:max-content;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-eyxei3 .next.next,.css-eyxei3 .previous.next{text-align:right;margin-left:auto}.css-eyxei3 .next.previous,.css-eyxei3 .previous.previous{text-align:left}.css-eyxei3 .next .inner,.css-eyxei3 .previous .inner{-webkit-flex:1;-ms-flex:1;flex:1}</style><nav class=css-eyxei3><a class=previous href=/post/korean_style_award_with_latex><div class=arrow>❮</div><div class=inner><div class=title>LaTeX을 이용한 한국식 상장 템플릿</div><div class=subtitle>한국인이라면 한 번쯤 봤을 법한 그 양식</div><div class=date>2023. 11. 5. 오후 1:26:36</div></div></a><a class=next href=/post/fcitx5_for_101_key_keyboard_kde_laptop><div class=inner><div class=title>한글 입력을 위한 fcitx5 설치</div><div class=subtitle>KDE 노트북에서의 버그없는 한글 입력을 위한 삽질기</div><div class=date>2023. 10. 17. 오후 9:34:16</div></div><div class=arrow>❯</div></a></nav></div></main><style data-emotion="css 19fp2wc">.css-19fp2wc{font-size:.75rem;line-height:.9rem}.css-19fp2wc p{margin:0 0 1em;padding:0}.css-19fp2wc .badges{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;gap:1em;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-19fp2wc .badges img{border-width:0;width:auto;height:3em}</style><footer class=css-19fp2wc><p>Copyright (C) 2020 ~ 2025 Yeonjin Shin (a.k.a. LiteHell), All rights reserved.<br><a href=/license>This blog is free software; For source code and more informations on license and copyrights, Click here.</a><p>Feeds: <a href=/feed/rss>RSS 2.0</a>, <a href=/feed/atom>Atom</a>, <a href=/feed/json>JSON</a><div class=badges><a href=http://creativecommons.org/licenses/by-sa/4.0/ rel=license><img alt="Creative Commons License"src=https://i.creativecommons.org/l/by-sa/4.0/88x31.png><a href=https://www.gnu.org/licenses/agpl-3.0.en.html><img alt="GNU Affero General License Version 3"src=https://www.gnu.org/graphics/agplv3-with-text-100x42.png></a></a></div></footer></div>