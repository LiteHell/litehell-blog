<!DOCTYPE html><html lang="ko-KR"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><link rel="canonical" href="https://blog.litehell.info/post/min_max_heap"/><link rel="alternate" type="application/rss+xml" title="RSS 2.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/rss"/><link rel="alternate" type=" application/atom+xml" title="Atom 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/atom"/><link rel="alternate" type="application/feed+json" title="Json 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/json"/><meta property="og:title" content="최소-최대 힙(Min-max heap) 구현하기 (백준 7662번 이중 우선순위 큐 문제)"/><meta property="og:description" content="최소값과 최대값을 동시에 구할 수 있는 힙 자료구조"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="article"/><meta property="og:site_name" content="LiteHell의 블로그"/><meta property="og:url" content="https://blog.litehell.info/post/min_max_heap"/><meta property="og:image" content="https://blog.litehell.info/img/min_max_heap/example.svg"/><title>LiteHell의 블로그 - <!-- -->최소-최대 힙(Min-max heap) 구현하기 (백준 7662번 이중 우선순위 큐 문제)</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/vs2015.min.css"/><meta name="next-head-count" content="16"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CZL0E8YDPW"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-CZL0E8YDPW', { page_path: window.location.pathname });
            </script><link rel="preload" href="/_next/static/css/27d177a30947857b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27d177a30947857b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/088d29430e0ecbdb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/088d29430e0ecbdb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-ad45764ecfcae9e5.js" defer=""></script><script src="/_next/static/chunks/main-ee0cf4b7f81d7c24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a96cacb95f41a3ef.js" defer=""></script><script src="/_next/static/chunks/996-c5e5aa4c30f33066.js" defer=""></script><script src="/_next/static/chunks/503-25bfb158f613fce4.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-b722ca2857677f7b.js" defer=""></script><script src="/_next/static/tPvn0ikdnYc2gkfCdDjpk/_buildManifest.js" defer=""></script><script src="/_next/static/tPvn0ikdnYc2gkfCdDjpk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_body__O2_kC"><header class="Layout_header__M_IZ8"><div class="Layout_container__z4qWC"><h1><a href="/">LiteHell의 블로그</a></h1><div class="Layout_outLinks__XBNs_">외부고리 : <a href="https://litehell.info">Homepage</a><a href="https://github.com/LiteHell">GitHub</a><a href="https://linkedin.com/in/LiteHell">LinkedIn</a><a href="https://keybase.io/LiteHell">Keybase</a><a href="mailto:litehell@litehell.info">Email</a></div><div class="Layout_inLinks__f7gmD">내부고리 : <a href="/category">카테고리</a><a href="/tag">태그</a></div></div></header><main class="Layout_mainContainer__5WZfx"><div class="Layout_container__z4qWC"><div class="Blog_header__r4wcZ"><div class="Blog_title___OFu6"><h1>최소-최대 힙(Min-max heap) 구현하기 (백준 7662번 이중 우선순위 큐 문제)</h1><h2>최소값과 최대값을 동시에 구할 수 있는 힙 자료구조</h2></div><p>5/3/2023, 3:24:12 PM<!-- -->에 <!-- -->LiteHell<!-- -->이(가) 작성<!-- -->함<br/><span>카테고리 : <a href="/category/Dev%20(PS)">Dev (PS)</a><br/></span><span>태그 : <span class="Blog_tag__RW5VK"><a href="/tag/Heap">Heap</a></span><br/></span></p></div><section class="Blog_article__WZp3G"><h1 id="백준-7662번-이중-우선순위-큐-문제">백준 7662번 이중 우선순위 큐 문제</h1>
<p><a href="https://www.acmicpc.net/problem/7662">백준 이중 우선순위 큐 문제</a>는 본 글에서 소개하는 최소-최대 힙(Min-max heap)을 구현하면 풀리는 문제이다.</p>
<p>필자는 최소-최대 힙을 시도하기에 앞서 다른 방법(최소 힙이랑 최대 힙 두개 만들기)을 시도했었으나 능력이 부족한 탓인지 실패했다. 따라서 이 방법의 정석적인 풀이방법인 최소-최대 힙을 <a href="https://en.wikipedia.org/wiki/Min-max_heap">영문 위키백과의 Min-max heap 문서</a>을 보면서 풀었다. 이 글에서는 최소-최대 힙에 대해 설명하고 C++ 구현 코드를 제시하고자 한다.</p>
<h2 id="heap이란">Heap이란?</h2>
<p>Heap은 최소값이나 최대값 등을 빠르게 구하기 위해 만들어진 완전 이진 트리(Complete binary tree) 형태의 자료구조이다. 일반적으로 Heap이라고 말할 때는 보통 최대 힙(Max-heap)이나 최소 힙(Min-heap)을 의미한다. 이 중에서 최대 힙은 다음과 같이 구현된다.</p>
<ul>
<li>추가<ol>
<li>추가하고자 하는 값을 힙 자료구조의 맨 뒤에 넣는다.</li>
<li>추가된 값을 부모 원소와 비교한다.<ul>
<li>만약 부모보다 작거나 같다면 멈춘다.</li>
<li>만약 부모보다 크다면 부모와 자리를 바꾼다.</li>
</ul>
</li>
<li>다시 2번으로 되돌아간다.</li>
</ol>
</li>
<li>최대값 삭제<ol>
<li>최대 힙에서는 루트에 있는 값이 항상 최대값이다. 따라서 루트를 삭제하고 힙의 맨 뒤에 있는 값을 루트로 옮긴다. 이 루트로 옮겨진 원소를 A라 하자.</li>
<li>A를 가장 큰 값을 가진 자식과 비교한다.<ul>
<li>만약 자식이 더 크다면 자식과 자리를 바꾼다.</li>
<li>만약 자식이 더 작거나 같다면 멈춘다.</li>
</ul>
</li>
<li>다시 2번으로 되돌아간다.</li>
</ol>
</li>
</ul>
<p>최소 힙은 위에서 비교하는 방향만 돌려서 다음과 같이 구현하면 된다.</p>
<ul>
<li>추가<ol>
<li>추가하고자 하는 값을 힙 자료구조의 맨 뒤에 넣는다.</li>
<li>추가된 값을 부모 원소와 비교한다.<ul>
<li>만약 부모보다 크거나 같다면 멈춘다.</li>
<li>만약 부모보다 작다면 부모와 자리를 바꾼다.</li>
</ul>
</li>
<li>다시 2번으로 되돌아간다.</li>
</ol>
</li>
<li>최소값 삭제<ol>
<li>최대 힙에서는 루트에 있는 값이 항상 최소값이다. 따라서 루트를 삭제하고 힙의 맨 뒤에 있는 값을 루트로 옮긴다. 이 루트로 옮겨진 원소를 A라 하자.</li>
<li>A를 가장 작은 값을 가진 자식과 비교한다.<ul>
<li>만약 자식이 더 작다면 자식과 자리를 바꾼다.</li>
<li>만약 자식이 더 크거나 같다면 멈춘다.</li>
</ul>
</li>
<li>다시 2번으로 되돌아간다.</li>
</ol>
</li>
</ul>
<p>위와 같이 구현된 최대 힙에서는 항상 가장 큰 값을 가진 원소가 루트가 되며, 최소 힙에서는 가장 작은 값을 가진 원소가 항상 루트가 된다. 즉, 최대 힙을 이용하면 주어진 값들 중에서 최댓값을 빠르게 구할 수 있으며, 최소 힙을 이용하면 최소값을 빠르게 구할 수 있다.</p>
<p>그렇다면 여기서 궁금증이 하나 생긴다, 최댓값과 최소값을 둘 다 빠르게 구할 수 있는 힙 자료구조가 있을까? 이에 대한 정답은 본 글에서 소개하고자 하는 최소-최대 힙이다.</p>
<h2 id="최소-최대-힙">최소-최대 힙</h2>
<p>Min-max heap(최소-최대 힙)은 홀수번째 레벨(이하 Min-level)의 원소는 그 밑에 있는 모든 원소들보다 작거나 같은 값을 가지며, 짝수번째 레벨(이하 Max-level)의 원소는 그 밑에 있는 모든 원소들보다 크거나 같은 값을 가진다. 루트가 있는 레벨은 Min-level이다.</p>
<p><img src="/img/min_max_heap/example.svg" alt="예시 Min-max heap"></p>
<p>위 예시를 보자. Min-level에 있는 원소는 그 하위에 있는 원소들보다 작은 값을 가지며, Max-level에 있는 원소는 그 밑에 있는 원소들보다 큰 값을 가진다.</p>
<p>따라서 우리는 최소-최대 힙에서 (루트는 Min-level이므로) 루트는 항상 힙의 최소값을 가지며, 2번째 레벨에 있는(루트 바로 밑 레벨에 있는) 두 원소 중 가장 큰 값이 힙의 최댓값을 나타냄을 알 수 있다.</p>
<h2 id="구현">구현</h2>
<p>최소-최대 힙의 구현은 다음과 같이 이루어진다.</p>
<ul>
<li>추가<ul>
<li>새로운 값을 추가할 때는 힙의 맨 뒤에 값을 추가한 뒤 그 값을 위로 올려가며(Push-up) 적절한 자리를 찾아 힙 자료구조를 완성한다.</li>
</ul>
</li>
<li>최소/최대값 확인<ul>
<li>최소값을 읽을 때는 루트의 값을 읽는다.</li>
<li>최대값을 읽을 때는 루트의 직계자식들 중 가장 큰 값을 읽는다.</li>
</ul>
</li>
<li>삭제<ul>
<li>최소값이나 최대값을 삭제한 뒤에는, 힙의 맨 뒤에 있는 값을 최소값이나 최대값이 있던 자리로 옮기고, 그 값을 아래로 내려가며(Push-down) 적절한 자리를 찾아 힙 자료구조를 완성한다.</li>
</ul>
</li>
</ul>
<p>위를 구현하기 위해서는 Push-up과 Push-down 알고리즘을 구현해야 한다.</p>
<h2 id="push-up의-구현">Push-Up의 구현</h2>
<p>예시를 들어 설명해보자. 다음 예시를 보라.</p>
<p><img src="/img/min_max_heap/pushup/step1.svg" alt="예시 Min-max heap"></p>
<p>위 그래프는 유효한 최소-최대힙이다. 위 그래프의 맨 끝에 3이라는 값을 추가했다고 가정해보자. 3을 추가할 시 아래와 같이 변한다.</p>
<p><img src="/img/min_max_heap/pushup/step2.svg" alt="예시 Min-max heap"></p>
<p>값을 추가하는 순간 유효한 최소-최대 힙이 아니게 된다. Min-level에 있는 6보다 더 작은 자식 3이 생기기 때문이다.</p>
<p>따라서 이 그래프를 다시 최소-최대 힙으로 만들기 위해서는 원소 3을 위로 올려가면서 적절한 위치를 찾아야 한다.
먼저, 추가한 값인 3이 Min-level에 있는 부모(6)보다 작다. 이는 최소-최대 힙의 조건과 모순되므로 부모와 추가된 값의 위치를 서로 바꿔준다.</p>
<p><img src="/img/min_max_heap/pushup/step3.svg" alt="에시 Min-max heap"></p>
<p>추가된 값이 부모와 바꿔지면서 Min-level로 옮겨졌음을 확인할 수 있다. 이제 3은 3을 루트로 하는 서브트리 내에서만큼은 무결하다. 왜나하면, 최소-최대 힙에서 루트에 있던 값은 그 밑의 모든 값들보다 작거나(혹은 루트의 레벨에 따라서, 크거나) 같아야 한다는 특징이 있는데, 이 값이 (6에서 3으로) 더 작아지는 것이 이 특징을 깨트리지 않음은 자명하기 때문이다.</p>
<p>그러나, 위 그래프는 아직도 최소-최대 힙의 특징을 만족하지 못한다. 5번째 레벨의 원소(값: 4)와 7번째 레벨의 원소(값: 5)를 보라. 5번째 레벨과 7번째 레벨은 홀수번째 레벨이므로 Min-level이다. 따라서 원소 4의 하위 원소들은 모두 값이 4보다 크거나 같아야 하고, 원소 5의 하위 원소들도 모두 값이 5보다 크거나 같아야 한다. 그러나 원소 3은 5나 4보다 크거나 같지 않다. 원소 5(혹은 4)의 하위 원소인 원소 3이 5(혹은 4)보다 작은 값을 가지므로 최소-최대 힙의 조건과 모순된다.</p>
<p>따라서 이 모순을 해결하기 위해, 원소 3을 상위의 Min-level에 있는 원소(위 사진에서 파란색으로 표시된 원소들)들과 비교하며 적절한 위치를 찾아야 한다. 원소 3을 파란색으로 표시된 원소들과 비교하여 위로 올려가며 적절한 위치를 찾은 결과는 다음과 같다.</p>
<p><img src="/img/min_max_heap/pushup/step4.svg" alt="에시 Min-max heap"></p>
<p>최소-최대 힙에 값 6이 성공적으로 추가됐음을 알 수 있다.</p>
<p>따라서 우리는 이 예시가 다음과 같은 알고리즘에 따라 이루어졌음을 알 수 있다.</p>
<ol>
<li>추가된 값(이하 원소 A)을 힙의 맨 뒤에 추가한다. A가 Max-level에 추가됐다고 가정하자.</li>
<li>A를 부모 원소와 비교한다.<ol>
<li>A가 부모 원소보다 작거나 같다면 A와 부모 원소를 서로 바꾼다.</li>
</ol>
</li>
<li>A를 A의 조부모 원소와 비교한다.<ul>
<li>만약 A가 Min-level이고 A가 조부모보다 더 작다면, A와 조부모의 위치를 서로 바꾼다.</li>
<li>만약 A가 Max-level이고 A가 조부모보다 더 크다면, A와 조부모의 위치를 서로 바꾼다.</li>
<li>서로 바꿀 필요가 없다면 멈춘다.</li>
</ul>
</li>
<li>3번으로 되돌아간다.</li>
</ol>
<p>위 알고리즘을 A가 처음에 Min-level에 추가된 경우로까지 확장하면 다음과 같다.</p>
<ol>
<li>추가된 값(이하 원소 A)을 힙의 맨 뒤에 추가한다.</li>
<li>A를 부모 원소와 비교한다.<ul>
<li>A가 Max-level에 있고, A가 부모 원소보다 작거나 같다면 A와 부모 원소를 서로 바꾼다.</li>
<li>A가 Min-level에 있고, A가 부모 원소보다 크거나 같다면 A와 부모 원소를 서로 바꾼다.</li>
</ul>
</li>
<li>A를 A의 조부모 원소와 비교한다.<ul>
<li>만약 A가 Min-level이고 A가 조부모보다 더 작다면, A와 조부모의 위치를 서로 바꾼다.</li>
<li>만약 A가 Max-level이고 A가 조부모보다 더 크다면, A와 조부모의 위치를 서로 바꾼다.</li>
<li>서로 바꿀 필요가 없다면 멈춘다.</li>
</ul>
</li>
<li>3번으로 되돌아간다.</li>
</ol>
<p>위 알고리즘이 최소-최대 힙의 Push-Up 알고리즘이다. 이 알고리즘을 이용하면 원소의 추가를 구현할 수 있다.</p>
<h2 id="push-down의-구현">Push-down의 구현</h2>
<p>Push-down은 다음과 같이 구현한다. 먼저, 아래와 같은 유효한 최소-최대 힙이이 있다고 가정하자.</p>
<p><img src="/img/min_max_heap/pushdown/step1.svg" alt="Min-max heap"></p>
<p>위 힙에서 최소값을 제거하고 최소값이 있던 자리(루트)에 8을 넣었다고 가정해보자. 그 결과는 다음과 같다.</p>
<p><img src="/img/min_max_heap/pushdown/step2.svg" alt="Min-max heap"></p>
<p>위 그래프는 유효한 최소-최대 힙이 아니다. 따라서 이 그래프를 최소-최대 힙으로 만들기 위해서는 원소들의 위치를 아래로 내려가며 조정해야 한다.</p>
<p>먼저, 위 그래프에서 원소 8은 Min-level에 있다. 따라서 원소 8의 자식(Child)과 손자(Grandchild)들중 가장 작은 값을 가진 원소를 확인한다. 이 원소는 2이다.</p>
<p>원소 2가 원소 8보다 더 작음은 Min-max heap의 조건에 모순된다. 따라서 원소 2와 원소 8의 위치를 서로 바꾼다.</p>
<p><img src="/img/min_max_heap/pushdown/step3.svg" alt="Min-max heap"></p>
<p>원소 2와 원소 8의 위치를 서로 바꾸었지만 Max-level에 있는 원소 7이 자식인 원소 8보다 더 작은 값을 가지고 있다. 이는 모순이다. 따라서 원소 7과 원소 8의 위치를 서로 바꾼다.</p>
<p><img src="/img/min_max_heap/pushdown/step4.svg" alt="Min-max heap"></p>
<p>이제 원소 2는 하위에 있는 모든 원소들보다 작은 값을 가지고, 원소 8은 하위에 있는 모든 원소들보다 큰 값을 가진다. 원소 7 위로는 Min-max heap의 조건과 모순되는 원소가 없다. 그러나 원소 7의 밑을 보라. 원소 7은 Min-level이므로 원소 7 하위의 모든 원소들보다 작거나 같은 값을 가져야 한다. 그러나 원소 6, 3, 5, 4로 인하여 이 조건이 만족되지 않는다.</p>
<p>이를 해결하기 위해 원소 7의 자식과 손자들 중 가장 작은 값을 가진 원소를 찾는다. 이러한 원소는 3이다. 원소 3으로 인하여 원소 7이 Min-level의 조건을 만족하지 않으니 원소 3과 원소 7의 위치를 서로 바꾼다.</p>
<p><img src="/img/min_max_heap/pushdown/step5.svg" alt="Min-max heap"></p>
<p>원소 7의 부모는 Max-level이므로 원소 7의 부모는 원소 7보다 더 크거나 같은 값을 가져야 한다. 그러나 부모 원소의 값은 6이므로 7보다 크거나 같은 값이 아니다. 따라서 원소 7과 6의 위치를 서로 바꾼다.</p>
<p><img src="/img/min_max_heap/pushdown/step6.svg" alt="Min-max heap"></p>
<p>이제 원소 6 위의 모든 원소들 (2, 8, 3, 7)들은 Min-level과 Max-level의 조건을 만족한다. 그러나 원소 6은 Min-level의 조건을 만족하지 못한다. 따라서 원소 6이 Min-level의 조건을 만족하도록 하기 위해 원소 6의 자식과 손자들 중 가장 작은 값을 가진 원소를 찾는다. 이 원소는 4이다. 원소 4는 Min-level인 원소 6의 손자임이도 불구하고 6보다 작은 값을 가지고 있다. 이는 모순이므로 원소 6과 4의 위치를 바꾼다.</p>
<p><img src="/img/min_max_heap/pushdown/step7.svg" alt="Min-max heap"></p>
<p>원소 6의 부모를 보자. 원소 6의 부모의 값은 5인데, 이 부모 원소는 Max-level에 있다. 이는 모순이다. 이 모순을 해결하기 위해 원소 6과 원소 5의 위치를 서로 바꾼다.</p>
<p><img src="/img/min_max_heap/pushdown/step8.svg" alt="Min-max heap"></p>
<p>이제 유효한 Min-max heap이 만들어졌음을 확인할 수 있다. 이 예시로부터 알고리즘을 도출하면 다음과 같다.</p>
<ul>
<li>주어진 원소 A에 대하여, 만약 A가 Min-level이라면<ol>
<li>자식과 손자들 중 가장 작은 값을 가진 원소를 B라고 하고 B의 인덱스를 <code>i</code>라고 하자.</li>
<li>만약 B가 A보다 더 작은 값을 가지고 있고.<ul>
<li>B가 A의 손자라면<ol>
<li>B와 A의 위치를 서로 바꾼다.</li>
<li>만약 A가 A의 부모보다 더 큰 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.</li>
<li><code>i</code>번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.</li>
</ol>
</li>
<li>B가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>위 알고리즘을 A가 Max-level인 경우로까지 확장하면 다음과 같다.</p>
<ul>
<li>주어진 원소 A에 대하여<ul>
<li>만약 A가 Min-level이라면<ol>
<li>자식과 손자들 중 가장 작은 값을 가진 원소를 B라고 하고 B의 인덱스를 <code>i</code>라고 하자.</li>
<li>만약 B가 A보다 더 작은 값을 가지고 있고.<ul>
<li>B가 A의 손자라면<ol>
<li>B와 A의 위치를 서로 바꾼다.</li>
<li>만약 A가 A의 부모보다 더 큰 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.</li>
<li><code>i</code>번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.</li>
</ol>
</li>
<li>B가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.</li>
</ul>
</li>
</ol>
</li>
<li>만약 A가 Max-level이라면<ol>
<li>자식과 손자들 중 가장 큰 값을 가진 원소를 B라고 하고 B의 인덱스를 <code>i</code>라고 하자.</li>
<li>만약 B가 A보다 더 큰 값을 가지고 있고.<ul>
<li>B가 A의 손자라면<ol>
<li>B와 A의 위치를 서로 바꾼다.</li>
<li>만약 A가 A의 부모보다 더 작은 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.</li>
<li><code>i</code>번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.</li>
</ol>
</li>
<li>B가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="소스코드-c">소스코드 (C++)</h2>
<p>이제 위에서 PushUp과 Pushdown의 구현 알고리즘을 살펴봤으므로 아래와 같이 C++로 구현할 수 있다.</p>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INT_SWAP(a,b) int tmp = a; a = b; b = tmp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAP_HEAP(a,b) INT_SWAP(heap[(a)], heap[(b)])</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IS_MIN_LEVEL(index) ((int)(std::log2(index)) % 2) == 0</span>

<span class="hljs-keyword">int</span> heapCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// How many elements in the heap?</span>
<span class="hljs-keyword">int</span> heap[<span class="hljs-number">1000001</span>]; <span class="hljs-comment">// Heap, starting from index 1</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> item)</span></span>; <span class="hljs-comment">// inserts an element</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popMin</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// removes minimum element</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popMax</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// removes maximum element</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seekMin</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// reads minimum element</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seekMax</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// reads maximum element</span>

<span class="hljs-comment">/**
 * Implementation of min/max pop using push-down
 */</span>

<span class="hljs-comment">// Picks index of largest(or smallest) child(or grandchild) of given element</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pickLargetOrSmallestDescendantIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">bool</span> largest)</span> </span>{
    <span class="hljs-keyword">int</span> resultIndex = index * <span class="hljs-number">2</span>, resultValue = heap[index * <span class="hljs-number">2</span>];
    <span class="hljs-keyword">int</span> candids[] = { <span class="hljs-comment">// Children and grandchildren</span>
        index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-comment">// Right child</span>
        index * <span class="hljs-number">4</span>, <span class="hljs-comment">// 1st grandchild (Left child of left child)</span>
        index * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>, <span class="hljs-comment">// 2nd grandchild (Right child of left cihld)</span>
        index * <span class="hljs-number">4</span> + <span class="hljs-number">2</span>, <span class="hljs-comment">// 3rd grandchild (Left child of right child)</span>
        index * <span class="hljs-number">4</span> + <span class="hljs-number">3</span> <span class="hljs-comment">// 4th grandchild (Right child of right child)</span>
    };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> candidIndex: candids) {
        <span class="hljs-keyword">if</span> (candidIndex &gt; heapCount)
            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// If it&#x27;s invalid index, continue</span>

        <span class="hljs-keyword">if</span> (largest &amp;&amp; resultValue &lt; heap[candidIndex]) {
            resultValue = heap[candidIndex];
            resultIndex = candidIndex;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!largest &amp;&amp; resultValue &gt; heap[candidIndex]) {
            resultValue = heap[candidIndex];
            resultIndex = candidIndex;
        }
    }

    <span class="hljs-keyword">return</span> resultIndex;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushDownMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushDownMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-keyword">if</span> (IS_MIN_LEVEL(index)) {
        pushDownMin(index);
    } <span class="hljs-keyword">else</span> {
        pushDownMax(index);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushDownMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-keyword">if</span> (index * <span class="hljs-number">2</span> &lt;= heapCount) { <span class="hljs-comment">// if has children</span>
        <span class="hljs-keyword">int</span> m = pickLargetOrSmallestDescendantIndex(index, <span class="hljs-literal">false</span>);

        <span class="hljs-keyword">if</span> (m &gt;= index * <span class="hljs-number">4</span>) { <span class="hljs-comment">// if m is a grandchild</span>
            <span class="hljs-keyword">if</span> (heap[m] &lt; heap[index]) {
                SWAP_HEAP(m, index);
                <span class="hljs-keyword">if</span> (heap[m] &gt; heap[m / <span class="hljs-number">2</span>]) {
                    SWAP_HEAP(m, m / <span class="hljs-number">2</span>);
                }
                pushDown(m);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heap[m] &lt; heap[index]) {
            SWAP_HEAP(m, index); 
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushDownMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-keyword">if</span> (index * <span class="hljs-number">2</span> &lt;= heapCount) { <span class="hljs-comment">// if has children</span>
        <span class="hljs-keyword">int</span> m = pickLargetOrSmallestDescendantIndex(index, <span class="hljs-literal">true</span>);

        <span class="hljs-keyword">if</span> (m &gt;= index * <span class="hljs-number">4</span>) { <span class="hljs-comment">// if m is a grandchild</span>
            <span class="hljs-keyword">if</span> (heap[m] &gt; heap[index]) {
                SWAP_HEAP(m, index);
                <span class="hljs-keyword">if</span> (heap[m] &lt; heap[m / <span class="hljs-number">2</span>]) {
                    SWAP_HEAP(m, m / <span class="hljs-number">2</span>);
                }
                pushDown(m);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heap[m] &gt; heap[index]) {
            SWAP_HEAP(m, index); 
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popMin</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (heapCount &lt;= <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// Removes minimum element</span>
    heap[<span class="hljs-number">1</span>] = heap[heapCount--];
    <span class="hljs-comment">// Push down root element to make the heap valid min-max heap</span>
    pushDown(<span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popMax</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (heapCount &lt;= <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">int</span> index;
    <span class="hljs-keyword">if</span> (heapCount == <span class="hljs-number">1</span>)
        index = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heapCount == <span class="hljs-number">2</span>)
        index = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">else</span>
        index = heap[<span class="hljs-number">2</span>] &gt; heap[<span class="hljs-number">3</span>] ? <span class="hljs-number">2</span> : <span class="hljs-number">3</span>;

    <span class="hljs-comment">// Removes maximum element</span>
    heap[index] = heap[heapCount--];
    <span class="hljs-comment">// Push down to root element make the heap valid min-max heap</span>
    pushDown(index);
}

<span class="hljs-comment">/**
 * Implementation of insertion using push-up
 */</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushUpMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-comment">// if index &gt;= 4, it must have a grandparent.</span>
        heap[index] &lt; heap[index / <span class="hljs-number">4</span>]) {
            SWAP_HEAP(index, index / <span class="hljs-number">4</span>);
            pushUpMin(index / <span class="hljs-number">4</span>);
        }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushUpMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-comment">// if index &gt;= 4, it must have a grandparent.</span>
        heap[index] &gt; heap[index / <span class="hljs-number">4</span>]) {
            SWAP_HEAP(index, index / <span class="hljs-number">4</span>);
            pushUpMax(index / <span class="hljs-number">4</span>);
        }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-keyword">if</span> (index != <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (IS_MIN_LEVEL(index)) {
            <span class="hljs-keyword">if</span> (heap[index] &gt; heap[index / <span class="hljs-number">2</span>]) {
                SWAP_HEAP(index, index / <span class="hljs-number">2</span>);
                pushUpMax(index / <span class="hljs-number">2</span>);
            } <span class="hljs-keyword">else</span> {
                pushUpMin(index);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (heap[index] &lt; heap[index / <span class="hljs-number">2</span>]) {
                SWAP_HEAP(index, index / <span class="hljs-number">2</span>);
                pushUpMin(index / <span class="hljs-number">2</span>);
            } <span class="hljs-keyword">else</span> {
                pushUpMax(index);
            }
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> item)</span> </span>{
    heap[++heapCount] = item;
    pushUp(heapCount);
}


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seekMin</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> heap[<span class="hljs-number">1</span>];
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seekMax</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (heapCount == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> heap[<span class="hljs-number">1</span>];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heapCount == <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">return</span> heap[<span class="hljs-number">2</span>];
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::max(heap[<span class="hljs-number">2</span>], heap[<span class="hljs-number">3</span>]);
    }

}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>.tie(<span class="hljs-literal">NULL</span>);
    <span class="hljs-built_in">std</span>::ios_base::sync_with_stdio(<span class="hljs-literal">false</span>);

    <span class="hljs-comment">// How many test cases?</span>
    <span class="hljs-keyword">int</span> t;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; t;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++) {
        <span class="hljs-comment">// How many operations?</span>
        <span class="hljs-keyword">int</span> q;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; q;

        <span class="hljs-comment">// Process operations</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; q; j++) {
            <span class="hljs-keyword">char</span> c;
            <span class="hljs-keyword">int</span> data;
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; c &gt;&gt; data;

            <span class="hljs-keyword">switch</span>(c) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>:
                    insertHeap(data);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:
                    <span class="hljs-keyword">if</span> (data == <span class="hljs-number">-1</span>)
                        popMin();
                    <span class="hljs-keyword">else</span>
                        popMax();
            }
        }

        <span class="hljs-comment">// Print result</span>
        <span class="hljs-keyword">int</span> max = seekMax(), min = seekMin();

        <span class="hljs-keyword">if</span> (heapCount == <span class="hljs-number">0</span>)
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;EMPTY\n&quot;</span>;
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; min &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
        heapCount = <span class="hljs-number">0</span>;
    }
}</code></pre>
</section><div class="Comments_blogComments__GRWmY"></div><nav class="Blog_postNav__ivy8_ Blog_hasBoth__3MRPr"><div class="Blog_leftAnchor__HhzIP"><a href="/post/how_to_fix_no_sound_issue_in_samsung_laptop_ubuntu"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">삼성 노트북(950XBE) 우분투에서 소리 안 들리는 버그 고치기</div><div class="Blog_subtitle__RRFh7">한 줄로 고치는 버그</div></div></a></div><div class="Blog_rightAnchor__B9n7B"><a href="/post/creating_mastodon_instance"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">Mastodon 서버 구축하기</div><div class="Blog_subtitle__RRFh7">6$짜리 VPS와 CloudFlare를 이용한 인스턴스 구축</div></div></a></div></nav></div></main><footer class="Layout_footer__bKkxe"><div class="Layout_container__z4qWC"><a href="https://www.gnu.org/licenses/agpl-3.0.en.html"><img alt="GNU Affero General License Version 3" src="https://www.gnu.org/graphics/agplv3-with-text-100x42.png" style="height:31px"/></a> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a><br/>Copyrights (C) 2020 LiteHell, All rights reserved.<br/><div class="Layout_visibleOnPrintOnly__UK6Yl">LiteHell&#x27;s Blog - <a href="https://blog.litehell.info">https://blog.litehell.info</a><br/>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.<br/><br/>Url of this article: <a href="https://blog.litehell.info/post/min_max_heap">https://blog.litehell.info/post/min_max_heap</a><br/></div><div class="Layout_invisibleOnPrint__rdrDv">Fox Image : Copyrights (C) 2004 Shiretoko-Shari Torurist Association<br/><a href="/license">This blog is free software; For source code and more informations on license and copyrights, Click here.</a><br/><br/>Feeds : <a href="/feed/rss">RSS 2.0</a>,<!-- --> <a href="/feed/atom">Atom 1.0</a>, <a href="/feed/json">Json 1.0</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"metadata":{"title":"최소-최대 힙(Min-max heap) 구현하기 (백준 7662번 이중 우선순위 큐 문제)","subtitle":"최소값과 최대값을 동시에 구할 수 있는 힙 자료구조","author":"LiteHell","date":"2023-05-03T15:24:12.104Z","category":"Dev (PS)","tags":["Heap"]},"rendered":"\u003ch1 id=\"백준-7662번-이중-우선순위-큐-문제\"\u003e백준 7662번 이중 우선순위 큐 문제\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.acmicpc.net/problem/7662\"\u003e백준 이중 우선순위 큐 문제\u003c/a\u003e는 본 글에서 소개하는 최소-최대 힙(Min-max heap)을 구현하면 풀리는 문제이다.\u003c/p\u003e\n\u003cp\u003e필자는 최소-최대 힙을 시도하기에 앞서 다른 방법(최소 힙이랑 최대 힙 두개 만들기)을 시도했었으나 능력이 부족한 탓인지 실패했다. 따라서 이 방법의 정석적인 풀이방법인 최소-최대 힙을 \u003ca href=\"https://en.wikipedia.org/wiki/Min-max_heap\"\u003e영문 위키백과의 Min-max heap 문서\u003c/a\u003e을 보면서 풀었다. 이 글에서는 최소-최대 힙에 대해 설명하고 C++ 구현 코드를 제시하고자 한다.\u003c/p\u003e\n\u003ch2 id=\"heap이란\"\u003eHeap이란?\u003c/h2\u003e\n\u003cp\u003eHeap은 최소값이나 최대값 등을 빠르게 구하기 위해 만들어진 완전 이진 트리(Complete binary tree) 형태의 자료구조이다. 일반적으로 Heap이라고 말할 때는 보통 최대 힙(Max-heap)이나 최소 힙(Min-heap)을 의미한다. 이 중에서 최대 힙은 다음과 같이 구현된다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e추가\u003col\u003e\n\u003cli\u003e추가하고자 하는 값을 힙 자료구조의 맨 뒤에 넣는다.\u003c/li\u003e\n\u003cli\u003e추가된 값을 부모 원소와 비교한다.\u003cul\u003e\n\u003cli\u003e만약 부모보다 작거나 같다면 멈춘다.\u003c/li\u003e\n\u003cli\u003e만약 부모보다 크다면 부모와 자리를 바꾼다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e다시 2번으로 되돌아간다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e최대값 삭제\u003col\u003e\n\u003cli\u003e최대 힙에서는 루트에 있는 값이 항상 최대값이다. 따라서 루트를 삭제하고 힙의 맨 뒤에 있는 값을 루트로 옮긴다. 이 루트로 옮겨진 원소를 A라 하자.\u003c/li\u003e\n\u003cli\u003eA를 가장 큰 값을 가진 자식과 비교한다.\u003cul\u003e\n\u003cli\u003e만약 자식이 더 크다면 자식과 자리를 바꾼다.\u003c/li\u003e\n\u003cli\u003e만약 자식이 더 작거나 같다면 멈춘다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e다시 2번으로 되돌아간다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e최소 힙은 위에서 비교하는 방향만 돌려서 다음과 같이 구현하면 된다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e추가\u003col\u003e\n\u003cli\u003e추가하고자 하는 값을 힙 자료구조의 맨 뒤에 넣는다.\u003c/li\u003e\n\u003cli\u003e추가된 값을 부모 원소와 비교한다.\u003cul\u003e\n\u003cli\u003e만약 부모보다 크거나 같다면 멈춘다.\u003c/li\u003e\n\u003cli\u003e만약 부모보다 작다면 부모와 자리를 바꾼다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e다시 2번으로 되돌아간다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e최소값 삭제\u003col\u003e\n\u003cli\u003e최대 힙에서는 루트에 있는 값이 항상 최소값이다. 따라서 루트를 삭제하고 힙의 맨 뒤에 있는 값을 루트로 옮긴다. 이 루트로 옮겨진 원소를 A라 하자.\u003c/li\u003e\n\u003cli\u003eA를 가장 작은 값을 가진 자식과 비교한다.\u003cul\u003e\n\u003cli\u003e만약 자식이 더 작다면 자식과 자리를 바꾼다.\u003c/li\u003e\n\u003cli\u003e만약 자식이 더 크거나 같다면 멈춘다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e다시 2번으로 되돌아간다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위와 같이 구현된 최대 힙에서는 항상 가장 큰 값을 가진 원소가 루트가 되며, 최소 힙에서는 가장 작은 값을 가진 원소가 항상 루트가 된다. 즉, 최대 힙을 이용하면 주어진 값들 중에서 최댓값을 빠르게 구할 수 있으며, 최소 힙을 이용하면 최소값을 빠르게 구할 수 있다.\u003c/p\u003e\n\u003cp\u003e그렇다면 여기서 궁금증이 하나 생긴다, 최댓값과 최소값을 둘 다 빠르게 구할 수 있는 힙 자료구조가 있을까? 이에 대한 정답은 본 글에서 소개하고자 하는 최소-최대 힙이다.\u003c/p\u003e\n\u003ch2 id=\"최소-최대-힙\"\u003e최소-최대 힙\u003c/h2\u003e\n\u003cp\u003eMin-max heap(최소-최대 힙)은 홀수번째 레벨(이하 Min-level)의 원소는 그 밑에 있는 모든 원소들보다 작거나 같은 값을 가지며, 짝수번째 레벨(이하 Max-level)의 원소는 그 밑에 있는 모든 원소들보다 크거나 같은 값을 가진다. 루트가 있는 레벨은 Min-level이다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/example.svg\" alt=\"예시 Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e위 예시를 보자. Min-level에 있는 원소는 그 하위에 있는 원소들보다 작은 값을 가지며, Max-level에 있는 원소는 그 밑에 있는 원소들보다 큰 값을 가진다.\u003c/p\u003e\n\u003cp\u003e따라서 우리는 최소-최대 힙에서 (루트는 Min-level이므로) 루트는 항상 힙의 최소값을 가지며, 2번째 레벨에 있는(루트 바로 밑 레벨에 있는) 두 원소 중 가장 큰 값이 힙의 최댓값을 나타냄을 알 수 있다.\u003c/p\u003e\n\u003ch2 id=\"구현\"\u003e구현\u003c/h2\u003e\n\u003cp\u003e최소-최대 힙의 구현은 다음과 같이 이루어진다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e추가\u003cul\u003e\n\u003cli\u003e새로운 값을 추가할 때는 힙의 맨 뒤에 값을 추가한 뒤 그 값을 위로 올려가며(Push-up) 적절한 자리를 찾아 힙 자료구조를 완성한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e최소/최대값 확인\u003cul\u003e\n\u003cli\u003e최소값을 읽을 때는 루트의 값을 읽는다.\u003c/li\u003e\n\u003cli\u003e최대값을 읽을 때는 루트의 직계자식들 중 가장 큰 값을 읽는다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e삭제\u003cul\u003e\n\u003cli\u003e최소값이나 최대값을 삭제한 뒤에는, 힙의 맨 뒤에 있는 값을 최소값이나 최대값이 있던 자리로 옮기고, 그 값을 아래로 내려가며(Push-down) 적절한 자리를 찾아 힙 자료구조를 완성한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위를 구현하기 위해서는 Push-up과 Push-down 알고리즘을 구현해야 한다.\u003c/p\u003e\n\u003ch2 id=\"push-up의-구현\"\u003ePush-Up의 구현\u003c/h2\u003e\n\u003cp\u003e예시를 들어 설명해보자. 다음 예시를 보라.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushup/step1.svg\" alt=\"예시 Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e위 그래프는 유효한 최소-최대힙이다. 위 그래프의 맨 끝에 3이라는 값을 추가했다고 가정해보자. 3을 추가할 시 아래와 같이 변한다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushup/step2.svg\" alt=\"예시 Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e값을 추가하는 순간 유효한 최소-최대 힙이 아니게 된다. Min-level에 있는 6보다 더 작은 자식 3이 생기기 때문이다.\u003c/p\u003e\n\u003cp\u003e따라서 이 그래프를 다시 최소-최대 힙으로 만들기 위해서는 원소 3을 위로 올려가면서 적절한 위치를 찾아야 한다.\n먼저, 추가한 값인 3이 Min-level에 있는 부모(6)보다 작다. 이는 최소-최대 힙의 조건과 모순되므로 부모와 추가된 값의 위치를 서로 바꿔준다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushup/step3.svg\" alt=\"에시 Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e추가된 값이 부모와 바꿔지면서 Min-level로 옮겨졌음을 확인할 수 있다. 이제 3은 3을 루트로 하는 서브트리 내에서만큼은 무결하다. 왜나하면, 최소-최대 힙에서 루트에 있던 값은 그 밑의 모든 값들보다 작거나(혹은 루트의 레벨에 따라서, 크거나) 같아야 한다는 특징이 있는데, 이 값이 (6에서 3으로) 더 작아지는 것이 이 특징을 깨트리지 않음은 자명하기 때문이다.\u003c/p\u003e\n\u003cp\u003e그러나, 위 그래프는 아직도 최소-최대 힙의 특징을 만족하지 못한다. 5번째 레벨의 원소(값: 4)와 7번째 레벨의 원소(값: 5)를 보라. 5번째 레벨과 7번째 레벨은 홀수번째 레벨이므로 Min-level이다. 따라서 원소 4의 하위 원소들은 모두 값이 4보다 크거나 같아야 하고, 원소 5의 하위 원소들도 모두 값이 5보다 크거나 같아야 한다. 그러나 원소 3은 5나 4보다 크거나 같지 않다. 원소 5(혹은 4)의 하위 원소인 원소 3이 5(혹은 4)보다 작은 값을 가지므로 최소-최대 힙의 조건과 모순된다.\u003c/p\u003e\n\u003cp\u003e따라서 이 모순을 해결하기 위해, 원소 3을 상위의 Min-level에 있는 원소(위 사진에서 파란색으로 표시된 원소들)들과 비교하며 적절한 위치를 찾아야 한다. 원소 3을 파란색으로 표시된 원소들과 비교하여 위로 올려가며 적절한 위치를 찾은 결과는 다음과 같다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushup/step4.svg\" alt=\"에시 Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e최소-최대 힙에 값 6이 성공적으로 추가됐음을 알 수 있다.\u003c/p\u003e\n\u003cp\u003e따라서 우리는 이 예시가 다음과 같은 알고리즘에 따라 이루어졌음을 알 수 있다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e추가된 값(이하 원소 A)을 힙의 맨 뒤에 추가한다. A가 Max-level에 추가됐다고 가정하자.\u003c/li\u003e\n\u003cli\u003eA를 부모 원소와 비교한다.\u003col\u003e\n\u003cli\u003eA가 부모 원소보다 작거나 같다면 A와 부모 원소를 서로 바꾼다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eA를 A의 조부모 원소와 비교한다.\u003cul\u003e\n\u003cli\u003e만약 A가 Min-level이고 A가 조부모보다 더 작다면, A와 조부모의 위치를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003e만약 A가 Max-level이고 A가 조부모보다 더 크다면, A와 조부모의 위치를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003e서로 바꿀 필요가 없다면 멈춘다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e3번으로 되돌아간다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e위 알고리즘을 A가 처음에 Min-level에 추가된 경우로까지 확장하면 다음과 같다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e추가된 값(이하 원소 A)을 힙의 맨 뒤에 추가한다.\u003c/li\u003e\n\u003cli\u003eA를 부모 원소와 비교한다.\u003cul\u003e\n\u003cli\u003eA가 Max-level에 있고, A가 부모 원소보다 작거나 같다면 A와 부모 원소를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003eA가 Min-level에 있고, A가 부모 원소보다 크거나 같다면 A와 부모 원소를 서로 바꾼다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eA를 A의 조부모 원소와 비교한다.\u003cul\u003e\n\u003cli\u003e만약 A가 Min-level이고 A가 조부모보다 더 작다면, A와 조부모의 위치를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003e만약 A가 Max-level이고 A가 조부모보다 더 크다면, A와 조부모의 위치를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003e서로 바꿀 필요가 없다면 멈춘다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e3번으로 되돌아간다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e위 알고리즘이 최소-최대 힙의 Push-Up 알고리즘이다. 이 알고리즘을 이용하면 원소의 추가를 구현할 수 있다.\u003c/p\u003e\n\u003ch2 id=\"push-down의-구현\"\u003ePush-down의 구현\u003c/h2\u003e\n\u003cp\u003ePush-down은 다음과 같이 구현한다. 먼저, 아래와 같은 유효한 최소-최대 힙이이 있다고 가정하자.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushdown/step1.svg\" alt=\"Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e위 힙에서 최소값을 제거하고 최소값이 있던 자리(루트)에 8을 넣었다고 가정해보자. 그 결과는 다음과 같다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushdown/step2.svg\" alt=\"Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e위 그래프는 유효한 최소-최대 힙이 아니다. 따라서 이 그래프를 최소-최대 힙으로 만들기 위해서는 원소들의 위치를 아래로 내려가며 조정해야 한다.\u003c/p\u003e\n\u003cp\u003e먼저, 위 그래프에서 원소 8은 Min-level에 있다. 따라서 원소 8의 자식(Child)과 손자(Grandchild)들중 가장 작은 값을 가진 원소를 확인한다. 이 원소는 2이다.\u003c/p\u003e\n\u003cp\u003e원소 2가 원소 8보다 더 작음은 Min-max heap의 조건에 모순된다. 따라서 원소 2와 원소 8의 위치를 서로 바꾼다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushdown/step3.svg\" alt=\"Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e원소 2와 원소 8의 위치를 서로 바꾸었지만 Max-level에 있는 원소 7이 자식인 원소 8보다 더 작은 값을 가지고 있다. 이는 모순이다. 따라서 원소 7과 원소 8의 위치를 서로 바꾼다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushdown/step4.svg\" alt=\"Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 원소 2는 하위에 있는 모든 원소들보다 작은 값을 가지고, 원소 8은 하위에 있는 모든 원소들보다 큰 값을 가진다. 원소 7 위로는 Min-max heap의 조건과 모순되는 원소가 없다. 그러나 원소 7의 밑을 보라. 원소 7은 Min-level이므로 원소 7 하위의 모든 원소들보다 작거나 같은 값을 가져야 한다. 그러나 원소 6, 3, 5, 4로 인하여 이 조건이 만족되지 않는다.\u003c/p\u003e\n\u003cp\u003e이를 해결하기 위해 원소 7의 자식과 손자들 중 가장 작은 값을 가진 원소를 찾는다. 이러한 원소는 3이다. 원소 3으로 인하여 원소 7이 Min-level의 조건을 만족하지 않으니 원소 3과 원소 7의 위치를 서로 바꾼다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushdown/step5.svg\" alt=\"Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e원소 7의 부모는 Max-level이므로 원소 7의 부모는 원소 7보다 더 크거나 같은 값을 가져야 한다. 그러나 부모 원소의 값은 6이므로 7보다 크거나 같은 값이 아니다. 따라서 원소 7과 6의 위치를 서로 바꾼다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushdown/step6.svg\" alt=\"Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 원소 6 위의 모든 원소들 (2, 8, 3, 7)들은 Min-level과 Max-level의 조건을 만족한다. 그러나 원소 6은 Min-level의 조건을 만족하지 못한다. 따라서 원소 6이 Min-level의 조건을 만족하도록 하기 위해 원소 6의 자식과 손자들 중 가장 작은 값을 가진 원소를 찾는다. 이 원소는 4이다. 원소 4는 Min-level인 원소 6의 손자임이도 불구하고 6보다 작은 값을 가지고 있다. 이는 모순이므로 원소 6과 4의 위치를 바꾼다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushdown/step7.svg\" alt=\"Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e원소 6의 부모를 보자. 원소 6의 부모의 값은 5인데, 이 부모 원소는 Max-level에 있다. 이는 모순이다. 이 모순을 해결하기 위해 원소 6과 원소 5의 위치를 서로 바꾼다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/min_max_heap/pushdown/step8.svg\" alt=\"Min-max heap\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 유효한 Min-max heap이 만들어졌음을 확인할 수 있다. 이 예시로부터 알고리즘을 도출하면 다음과 같다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e주어진 원소 A에 대하여, 만약 A가 Min-level이라면\u003col\u003e\n\u003cli\u003e자식과 손자들 중 가장 작은 값을 가진 원소를 B라고 하고 B의 인덱스를 \u003ccode\u003ei\u003c/code\u003e라고 하자.\u003c/li\u003e\n\u003cli\u003e만약 B가 A보다 더 작은 값을 가지고 있고.\u003cul\u003e\n\u003cli\u003eB가 A의 손자라면\u003col\u003e\n\u003cli\u003eB와 A의 위치를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003e만약 A가 A의 부모보다 더 큰 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ei\u003c/code\u003e번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eB가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 알고리즘을 A가 Max-level인 경우로까지 확장하면 다음과 같다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e주어진 원소 A에 대하여\u003cul\u003e\n\u003cli\u003e만약 A가 Min-level이라면\u003col\u003e\n\u003cli\u003e자식과 손자들 중 가장 작은 값을 가진 원소를 B라고 하고 B의 인덱스를 \u003ccode\u003ei\u003c/code\u003e라고 하자.\u003c/li\u003e\n\u003cli\u003e만약 B가 A보다 더 작은 값을 가지고 있고.\u003cul\u003e\n\u003cli\u003eB가 A의 손자라면\u003col\u003e\n\u003cli\u003eB와 A의 위치를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003e만약 A가 A의 부모보다 더 큰 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ei\u003c/code\u003e번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eB가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e만약 A가 Max-level이라면\u003col\u003e\n\u003cli\u003e자식과 손자들 중 가장 큰 값을 가진 원소를 B라고 하고 B의 인덱스를 \u003ccode\u003ei\u003c/code\u003e라고 하자.\u003c/li\u003e\n\u003cli\u003e만약 B가 A보다 더 큰 값을 가지고 있고.\u003cul\u003e\n\u003cli\u003eB가 A의 손자라면\u003col\u003e\n\u003cli\u003eB와 A의 위치를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003e만약 A가 A의 부모보다 더 작은 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ei\u003c/code\u003e번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eB가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"소스코드-c\"\u003e소스코드 (C++)\u003c/h2\u003e\n\u003cp\u003e이제 위에서 PushUp과 Pushdown의 구현 알고리즘을 살펴봤으므로 아래와 같이 C++로 구현할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-meta-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-meta-string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-meta-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-meta-string\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-meta-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-meta-string\"\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-meta-keyword\"\u003edefine\u003c/span\u003e INT_SWAP(a,b) int tmp = a; a = b; b = tmp\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-meta-keyword\"\u003edefine\u003c/span\u003e SWAP_HEAP(a,b) INT_SWAP(heap[(a)], heap[(b)])\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-meta-keyword\"\u003edefine\u003c/span\u003e IS_MIN_LEVEL(index) ((int)(std::log2(index)) % 2) == 0\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e heapCount = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// How many elements in the heap?\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e heap[\u003cspan class=\"hljs-number\"\u003e1000001\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// Heap, starting from index 1\u003c/span\u003e\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003einsertHeap\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e item)\u003c/span\u003e\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// inserts an element\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epopMin\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// removes minimum element\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epopMax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// removes maximum element\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eseekMin\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// reads minimum element\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eseekMax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// reads maximum element\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * Implementation of min/max pop using push-down\n */\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// Picks index of largest(or smallest) child(or grandchild) of given element\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epickLargetOrSmallestDescendantIndex\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index, \u003cspan class=\"hljs-keyword\"\u003ebool\u003c/span\u003e largest)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e resultIndex = index * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, resultValue = heap[index * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n    \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e candids[] = { \u003cspan class=\"hljs-comment\"\u003e// Children and grandchildren\u003c/span\u003e\n        index * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// Right child\u003c/span\u003e\n        index * \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 1st grandchild (Left child of left child)\u003c/span\u003e\n        index * \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 2nd grandchild (Right child of left cihld)\u003c/span\u003e\n        index * \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 3rd grandchild (Left child of right child)\u003c/span\u003e\n        index * \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 4th grandchild (Right child of right child)\u003c/span\u003e\n    };\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e candidIndex: candids) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (candidIndex \u0026gt; heapCount)\n            \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// If it\u0026#x27;s invalid index, continue\u003c/span\u003e\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (largest \u0026amp;\u0026amp; resultValue \u0026lt; heap[candidIndex]) {\n            resultValue = heap[candidIndex];\n            resultIndex = candidIndex;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!largest \u0026amp;\u0026amp; resultValue \u0026gt; heap[candidIndex]) {\n            resultValue = heap[candidIndex];\n            resultIndex = candidIndex;\n        }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e resultIndex;\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epushDownMin\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index)\u003c/span\u003e\u003c/span\u003e;\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epushDownMax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index)\u003c/span\u003e\u003c/span\u003e;\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epushDown\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (IS_MIN_LEVEL(index)) {\n        pushDownMin(index);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        pushDownMax(index);\n    }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epushDownMin\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u0026lt;= heapCount) { \u003cspan class=\"hljs-comment\"\u003e// if has children\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e m = pickLargetOrSmallestDescendantIndex(index, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (m \u0026gt;= index * \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e// if m is a grandchild\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heap[m] \u0026lt; heap[index]) {\n                SWAP_HEAP(m, index);\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heap[m] \u0026gt; heap[m / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]) {\n                    SWAP_HEAP(m, m / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n                }\n                pushDown(m);\n            }\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heap[m] \u0026lt; heap[index]) {\n            SWAP_HEAP(m, index); \n        }\n    }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epushDownMax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u0026lt;= heapCount) { \u003cspan class=\"hljs-comment\"\u003e// if has children\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e m = pickLargetOrSmallestDescendantIndex(index, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (m \u0026gt;= index * \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e// if m is a grandchild\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heap[m] \u0026gt; heap[index]) {\n                SWAP_HEAP(m, index);\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heap[m] \u0026lt; heap[m / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]) {\n                    SWAP_HEAP(m, m / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n                }\n                pushDown(m);\n            }\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heap[m] \u0026gt; heap[index]) {\n            SWAP_HEAP(m, index); \n        }\n    }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epopMin\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heapCount \u0026lt;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// Removes minimum element\u003c/span\u003e\n    heap[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = heap[heapCount--];\n    \u003cspan class=\"hljs-comment\"\u003e// Push down root element to make the heap valid min-max heap\u003c/span\u003e\n    pushDown(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epopMax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heapCount \u0026lt;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heapCount == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n        index = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heapCount == \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n        index = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n        index = heap[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] \u0026gt; heap[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] ? \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e : \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// Removes maximum element\u003c/span\u003e\n    heap[index] = heap[heapCount--];\n    \u003cspan class=\"hljs-comment\"\u003e// Push down to root element make the heap valid min-max heap\u003c/span\u003e\n    pushDown(index);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * Implementation of insertion using push-up\n */\u003c/span\u003e\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epushUpMin\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index \u0026gt;= \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e \u0026amp;\u0026amp; \u003cspan class=\"hljs-comment\"\u003e// if index \u0026gt;= 4, it must have a grandparent.\u003c/span\u003e\n        heap[index] \u0026lt; heap[index / \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]) {\n            SWAP_HEAP(index, index / \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n            pushUpMin(index / \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n        }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epushUpMax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index \u0026gt;= \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e \u0026amp;\u0026amp; \u003cspan class=\"hljs-comment\"\u003e// if index \u0026gt;= 4, it must have a grandparent.\u003c/span\u003e\n        heap[index] \u0026gt; heap[index / \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]) {\n            SWAP_HEAP(index, index / \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n            pushUpMax(index / \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n        }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epushUp\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index != \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (IS_MIN_LEVEL(index)) {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heap[index] \u0026gt; heap[index / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]) {\n                SWAP_HEAP(index, index / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n                pushUpMax(index / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                pushUpMin(index);\n            }\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heap[index] \u0026lt; heap[index / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]) {\n                SWAP_HEAP(index, index / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n                pushUpMin(index / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                pushUpMax(index);\n            }\n        }\n    }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003einsertHeap\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e item)\u003c/span\u003e \u003c/span\u003e{\n    heap[++heapCount] = item;\n    pushUp(heapCount);\n}\n\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eseekMin\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e heap[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eseekMax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heapCount == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e heap[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heapCount == \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e heap[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003estd\u003c/span\u003e::max(heap[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], heap[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]);\n    }\n\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-built_in\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-built_in\"\u003ecin\u003c/span\u003e.tie(\u003cspan class=\"hljs-literal\"\u003eNULL\u003c/span\u003e);\n    \u003cspan class=\"hljs-built_in\"\u003estd\u003c/span\u003e::ios_base::sync_with_stdio(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// How many test cases?\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e t;\n    \u003cspan class=\"hljs-built_in\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-built_in\"\u003ecin\u003c/span\u003e \u0026gt;\u0026gt; t;\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; t; i++) {\n        \u003cspan class=\"hljs-comment\"\u003e// How many operations?\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e q;\n        \u003cspan class=\"hljs-built_in\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-built_in\"\u003ecin\u003c/span\u003e \u0026gt;\u0026gt; q;\n\n        \u003cspan class=\"hljs-comment\"\u003e// Process operations\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e j = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; j \u0026lt; q; j++) {\n            \u003cspan class=\"hljs-keyword\"\u003echar\u003c/span\u003e c;\n            \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e data;\n            \u003cspan class=\"hljs-built_in\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-built_in\"\u003ecin\u003c/span\u003e \u0026gt;\u0026gt; c \u0026gt;\u0026gt; data;\n\n            \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e(c) {\n                \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;I\u0026#x27;\u003c/span\u003e:\n                    insertHeap(data);\n                    \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n                \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;D\u0026#x27;\u003c/span\u003e:\n                    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data == \u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e)\n                        popMin();\n                    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n                        popMax();\n            }\n        }\n\n        \u003cspan class=\"hljs-comment\"\u003e// Print result\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e max = seekMax(), min = seekMin();\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (heapCount == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n            \u003cspan class=\"hljs-built_in\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-built_in\"\u003ecout\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\u0026quot;EMPTY\\n\u0026quot;\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n            \u003cspan class=\"hljs-built_in\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-built_in\"\u003ecout\u003c/span\u003e \u0026lt;\u0026lt; max \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\u0026#x27; \u0026#x27;\u003c/span\u003e \u0026lt;\u0026lt; min \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\n\u0026#x27;\u003c/span\u003e;\n        heapCount = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n"},"articleId":"min_max_heap","previousPost":{"name":"how_to_fix_no_sound_issue_in_samsung_laptop_ubuntu","metadata":{"title":"삼성 노트북(950XBE) 우분투에서 소리 안 들리는 버그 고치기","subtitle":"한 줄로 고치는 버그","author":"LiteHell","date":"2023-03-18T10:21:27.090Z","category":"Linux","tags":["Linux","Ubuntu"]},"rendered":"\u003cp\u003e나는 삼성 노트북 9 Always(모델명: NT950XBE)를 이용한다. 꽤 괜찮은 노트북인데, 대학에서 운영체제 수업을 듣다보니 우분투를 깔 필요를 느껴서 듀얼부팅으로 설치했다.\u003c/p\u003e\n\u003cp\u003e우분투를 설치하고 이용하는 데엔 큰 문제가 없었다, Wine으로 설치한 카카오톡도 잘 작동했다. 그러나 문제는 다른 데 있었다, 소리가 안 들렸다.\u003c/p\u003e\n\u003ch1 id=\"어떻게-안-들리나요\"\u003e어떻게 안 들리나요?\u003c/h1\u003e\n\u003cp\u003e이 소리가 안 들리는 증상을 자세히 서술하면 다음과 같았다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e노트북 내부 스피커: 아예 작동하지 않음.\u003c/li\u003e\n\u003cli\u003e노트북 이어폰 잭: pauvcontrol로 볼륨을 150%까지 올리면 들리긴 하는데 소리가 지지직거린다. 150%까지 안 올리면 들리지도 않는다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이어폰 잭은 그래도 \u003ccode\u003esudo hda-verb /dev/snd/hwC0D0 0x1a SET_PIN_WIDGET_CONTROL 0x5\u003c/code\u003e명령어를 실행하면 정상적으로 작동은 하는 데 이조차도 영구적인 해결책이 아니었고, 잠시 소리가 idle이 되면 바로 원상복구된다는 한계가 있었다. 영구적으로 해결할 수 있는 방법이 없을까?\u003c/p\u003e\n\u003ch2 id=\"생각보다-간단했던-해결방법\"\u003e생각보다 간단했던 해결방법\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1851518?comments=all\"\u003e찾아보니 이미 커널 버그로 보고된 문제였다.\u003c/a\u003e 이 버그 보고를 읽다가 문득 \u0026#39;\u003ccode\u003e/etc/modprobe.d/alsa-base.conf\u003c/code\u003e 파일 맨 밑에 다음 줄을 추가하면 되지 않을까?\u0026#39;라는 생각이 들었다. 그래서 추가했고, 재부팅했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# audio fix\noptions snd-hda-intel model=alc298-samsung-amp\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과는? 해결됐다. 이어폰도 스피커도 매우 잘 작동한다. 커널 버그라서 복잡하게 해결할 줄 알았는데 문제가 손쉽게 해결되서 다행이었다, 메데타시 메데타시.\u003c/p\u003e\n"},"nextPost":{"name":"creating_mastodon_instance","metadata":{"title":"Mastodon 서버 구축하기","subtitle":"6$짜리 VPS와 CloudFlare를 이용한 인스턴스 구축","author":"LiteHell","date":"2023-07-22T15:55:38.110Z","category":"Dev","tags":["Mastodon","ActivityPub"]},"rendered":"\u003ch1 id=\"트위터와-페디버스\"\u003e트위터와 페디버스\u003c/h1\u003e\n\u003cp\u003e확실히 요즘 트위터는 달라졌다. 일론 머스크가 인수한 이후의 트위터는 확실히 뭔가 달라졌다. 뭔가 보여주겠다는 의지의 표출인가?\u003c/p\u003e\n\u003cp\u003e이런 새로워진 트위터에 적응하지 못한 사람들은 \u003ca href=\"https://joinmastodon.org\"\u003e마스토돈\u003c/a\u003e이나 \u003ca href=\"https://misskey-hub.net/\"\u003e미스키\u003c/a\u003e 등의 \u003ca href=\"https://www.w3.org/TR/activitypub/\"\u003eActivityPub\u003c/a\u003e를 구현한 분산형 SNS 인스턴스로 이주하고 있다. 국내의 이런 분산형 SNS는 대표적으로 다음과 같다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://twingyeo.kr/\"\u003e트잉여\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://planet.moe/\"\u003e플래닛\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://qdon.space/\"\u003e큐돈\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ani.work/\"\u003e애니워크\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://social.silicon.moe\"\u003eSifNet Mastodon\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://hoto.moe\"\u003ehotomoe\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위와 같이 서로 AcitivtyPub 등의 프로토콜을 이용해 통신하는 SNS 서비스들의 집합을 \u003cstrong\u003eFediverse\u003c/strong\u003e(페디버스)라 일컬는다. 페디버스는 서버간에 서로 통신할 수 있기 때문에 다른 서버에 있는 사용자와도 소통할 수 있다. 즉, 서버 A에서 서버 B에 있는 사람을 팔로우할 수도 있다.\u003c/p\u003e\n\u003ch1 id=\"mastodon-설치\"\u003eMastodon 설치\u003c/h1\u003e\n\u003cp\u003e분산형 SNS이니 당연히 본인이 직접 서버를 구축하는 것도 가능하다. 따라서 직접 VPS에 마스토돈을 설치했다. VPS 운영체제로는 데비안을 택했고, 사양은 Vultr $6 VPS로 했다.\u003c/p\u003e\n\u003cp\u003e설치 자체는 \u003ca href=\"https://docs.joinmastodon.org/admin/install/\"\u003e공식 홈페이지의 문서\u003c/a\u003e를 따르는 식으로 진행했으나 중간중간 삽질을 약간 했다.\u003c/p\u003e\n\u003ch2 id=\"root-계정-전환\"\u003eroot 계정 전환\u003c/h2\u003e\n\u003cp\u003e마스토돈을 설치하기 위해서는 먼저 root 계정으로 전환한다. \u003ccode\u003esu\u003c/code\u003e 명령어를 이용하면 된다.\u003c/p\u003e\n\u003ch2 id=\"의존성-설치\"\u003e의존성 설치\u003c/h2\u003e\n\u003cp\u003e그 다음, 의존성을 설치해야 한다. 의존성 설치 자체는 공식 홈페이지에 있는 명령어를 복사-붙여넣기하면 끝난다.\u003c/p\u003e\n\u003cp\u003e첫번째로 다음 명령어를 실행해 node.js v16을 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecurl -sL https://deb.nodesource.com/setup_16.x | bash -\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 다음 명령어를 실행해 PostgreSQL와 기타 다른 의존성들을 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eapt install -y curl wget gnupg apt-transport-https lsb-release ca-certificates\nwget -O /usr/share/keyrings/postgresql.asc https://www.postgresql.org/media/keys/ACCC4CF8.asc\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;deb [signed-by=/usr/share/keyrings/postgresql.asc] http://apt.postgresql.org/pub/repos/apt \u003cspan class=\"hljs-subst\"\u003e$(lsb_release -cs)\u003c/span\u003e-pgdg main\u0026quot;\u003c/span\u003e \u0026gt; /etc/apt/sources.list.d/postgresql.list\napt update\napt install -y \\\n  imagemagick ffmpeg libpq-dev libxml2-dev libxslt1-dev file git-core \\\n  g++ libprotobuf-dev protobuf-compiler pkg-config nodejs gcc autoconf \\\n  bison build-essential libssl-dev libyaml-dev libreadline6-dev \\\n  zlib1g-dev libncurses5-dev libffi-dev libgdbm-dev \\\n  nginx redis-server redis-tools postgresql postgresql-contrib \\\n  certbot python3-certbot-nginx libidn11-dev libicu-dev libjemalloc-dev\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"nodejs-버전-확인\"\u003enodejs 버전 확인\u003c/h3\u003e\n\u003cp\u003e다만 여기서 주의해야 하는 것이 있다. 시스템에 따라서 nodejs 16버전이 아닌 그보다 더 최신 버전이 설치됐었을 수도 있다.\n상관없지 않냐고? 상관있다, nodejs v16 버전이 아니면 나중에 webpack precompile 과정에서 오류가 난다.\u003c/p\u003e\n\u003cp\u003e설치된 nodejs의 버전은 \u003ccode\u003enode --version\u003c/code\u003e 명령어로 확인할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ node --version\nv18.13.0\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 데비안 apt 레포지토리에 있는 \u003ccode\u003enodejs\u003c/code\u003e 패키지 버전이 16보다 더 최신이기 때문에 발생한 문제이다. 이를 해결하기 위해서는 먼저 \u003ccode\u003esudo apt-cache policy nodejs\u003c/code\u003e를 실행해 어떤 버전이 설치 가능한지 확인해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ sudo apt-cache policy nodejs\nnodejs:\n  Installed: 18.13.0+dfsg1-1\n  Candidate: 18.13.0+dfsg1-1\n  Version table:\n *** 18.13.0+dfsg1-1 500\n        500 https://deb.debian.org/debian bookworm/main amd64 Packages\n        500 https://debian.mirror.constant.com bookworm/main amd64 Packages\n     16.20.1-deb-1nodesource1 500\n        500 https://deb.nodesource.com/node_16.x bookworm/main amd64 Packages\n        100 /var/lib/dpkg/status\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예시에서는 \u003ccode\u003e18.13.0+dfsg1-1\u003c/code\u003e과 \u003ccode\u003e16.20.1-deb-1nodesource1\u003c/code\u003e 버전이 설치 가능하다. 우리가 필요한 것은 nodejs v16대 버전이니 \u003ccode\u003e16.20.1-deb-1nodesource1\u003c/code\u003e을 설치할 것이다.\u003c/p\u003e\n\u003cp\u003eapt에서 특정한 버전을 지정해 설치하기 위해서는 다음과 같이 명령어를 실행하면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ sudo apt install nodejs=16.20.1-deb-1nodesource1\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 nodejs v16이 정상적으로 설치된 것을 확인할 수 있다.\u003c/p\u003e\n\u003ch3 id=\"yarn-설치\"\u003eYarn 설치\u003c/h3\u003e\n\u003cp\u003e위에서 nodejs, PostregreSQL 등의 의존성을 다 설치했으면 \u003ca href=\"https://yarnpkg.com\"\u003eYarn\u003c/a\u003e을 설치해야 한다. Yarn은 다음 명령어로 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecorepack \u003cspan class=\"hljs-built_in\"\u003eenable\u003c/span\u003e\nyarn \u003cspan class=\"hljs-built_in\"\u003eset\u003c/span\u003e version classic\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e혹시 위 명령어가 작동하지 않는다면 다음과 같이 npm을 이용해 설치할 수도 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo npm i -g yarn\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 위 npm을 이용한 명령어가 npm이 설치되어 있지 않아 실행되지 않는다면 아래 명령어로 npm을 실치할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecurl -qL https://www.npmjs.com/install.sh | sh\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ruby-설치\"\u003eRuby 설치\u003c/h2\u003e\n\u003cp\u003e이제 Ruby를 설치해야 한다. 먼저 \u003ccode\u003emastodon\u003c/code\u003e이라는 이름의 리눅스 계정을 생성한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eadduser --disabled-login mastodon\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 쉘을 지정한다. (안 하면 \u003ccode\u003esudo su - mastodon\u003c/code\u003e 명령어가 오류날 수 있다.) 아래 명령어에서는 쉘을 bash로 지정했는데, 쉘이 무조건 bash여야 할 필요는 없다. 선호하는 쉘이 있다면 그 쉘로 지정해도 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003echsh -s /bin/bash mastodon\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 mastodon으로 계정을 전환하자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo su - mastodon\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 명령어를 모두 실행해 Ruby를 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003egit \u003cspan class=\"hljs-built_in\"\u003eclone\u003c/span\u003e https://github.com/rbenv/rbenv.git ~/.rbenv\n\u003cspan class=\"hljs-built_in\"\u003ecd\u003c/span\u003e ~/.rbenv \u0026amp;\u0026amp; src/configure \u0026amp;\u0026amp; make -C src\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;export PATH=\u0026quot;$HOME/.rbenv/bin:$PATH\u0026quot;\u0026#x27;\u003c/span\u003e \u0026gt;\u0026gt; ~/.bashrc\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;eval \u0026quot;$(rbenv init -)\u0026quot;\u0026#x27;\u003c/span\u003e \u0026gt;\u0026gt; ~/.bashrc\n\u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e bash\ngit \u003cspan class=\"hljs-built_in\"\u003eclone\u003c/span\u003e https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build\nRUBY_CONFIGURE_OPTS=--with-jemalloc rbenv install 3.0.6\nrbenv global 3.0.6\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRuby 설치가 완료됐다면 bundler도 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003egem install bundler --no-document\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRuby와 bundler 설치를 마쳤다면 root 유저로 되돌아간다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexit\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"postgresql-설정\"\u003ePostgreSQL 설정\u003c/h2\u003e\n\u003cp\u003e공식 문서에서 pgTune을 쓰고 싶으면 쓰라고 나와있는데 필자는 귀찮아서 건너뛰었다.\u003c/p\u003e\n\u003cp\u003ePostgreSQL 설정을 위해 다음 명령어로 PostgreSQL 쉘을 띄운다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo -u postgres psql\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePostgreSQL 쉘이 띄워졌으면 다음 쿼리를 실행해서 SQL 계정을 생성한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eUSER\u003c/span\u003e mastodon CREATEDB;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e계정이 생성됐으면 다음 명령을 쳐서 쉘을 빠져나온다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\\q\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"마스토돈-다운로드\"\u003e마스토돈 다운로드\u003c/h2\u003e\n\u003cp\u003e이제 마스토돈을 다운로드하고 설정할 때가 왔다. 먼저 mastodon 계정으로 전환한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo su - mastodon\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 명령어를 실행해 최신 stable 버전의 mastodon을 다운로드한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003egit \u003cspan class=\"hljs-built_in\"\u003eclone\u003c/span\u003e https://github.com/mastodon/mastodon.git live \u0026amp;\u0026amp; \u003cspan class=\"hljs-built_in\"\u003ecd\u003c/span\u003e live\ngit checkout $(git tag -l | grep -v \u003cspan class=\"hljs-string\"\u003e\u0026#x27;rc[0-9]*$\u0026#x27;\u003c/span\u003e | sort -V | tail -n 1)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 Ruby 의존성과 JavaScript 의존성을 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ebundle config deployment \u003cspan class=\"hljs-string\"\u003e\u0026#x27;true\u0026#x27;\u003c/span\u003e\nbundle config without \u003cspan class=\"hljs-string\"\u003e\u0026#x27;development test\u0026#x27;\u003c/span\u003e\nbundle install -j$(getconf _NPROCESSORS_ONLN)\nyarn install --pure-lockfile\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"서버-swap-설정-및-nodejs-heap-용량-설정\"\u003e서버 swap 설정 및 nodejs heap 용량 설정\u003c/h2\u003e\n\u003cp\u003e마스토돈 설정(바로 다음 문단)을 하는 과정에서 Javascript heap out of memory 오류가 발생할 수 있다. 이는 서버에 RAM이 부족하기 때문이다. 이를 해결하기 위해서는 RAM을 더 꽂거나 swap 파일을 형성하고, 그 다음 node 설정을 수정해야 한다.\u003c/p\u003e\n\u003cp\u003e먼저 swap파일을 생성하는 방법은 다음과 같다. 용량은 적절하게 바꾸면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo fallocate -l 2G /tmp-swapfile\nsudo chmod 600 /tmp-swapfile\nsudo mkswap /tmp-swapfile\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e생성된 swap파일은 다음과 같이 적용할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo swapon /tmp-swapfile\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 명령어로 적용된 swap파일은 재부팅이 될 시 다시 적용되지 않으므로 재부팅을 하면 위 명령어를 다시 쳐줘야 한다. 따라서 swap 파일을 영구적으로 적용하기 위해서는 \u003ccode\u003e/etc/fstab\u003c/code\u003e 파일을 수정해야 하나, 본 글에서는 마스토돈을 설정하는 동안에만 임시적으로 이용할 swap 파일을 생성하는 것이므로 이 파일을 수정하는 방법에 대해서 언급하지 않는다.\u003c/p\u003e\n\u003cp\u003e이제 node 설정을 바꾸어야 한다. 먼저 현재 할당한 힙 용량을 다음 명령어로 확인한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003enode -e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;console.log(v8.getHeapStatistics().heap_size_limit/(1024*1024))\u0026#x27;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e실행하면 다음과 같이 뜰 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ node -e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;console.log(v8.getHeapStatistics().heap_size_limit/(1024*1024))\u0026#x27;\u003c/span\u003e\n495.75\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 용량을 참고해서 위 용량보다 적당히 더 큰 용량으로 힙 용량을 설정하면 된다. 힙 용량의 설정은 다음 명령어를 마스토돈 설정 명령어 실행 직전에 실행함으로써 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e NODE_OPTIONS=--max_old_space_size=800\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"마스토돈-설정\"\u003e마스토돈 설정\u003c/h2\u003e\n\u003cp\u003e다음 명령어를 실행해 마스토돈 서버를 설정한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eRAILS_ENV=production bundle \u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e rake mastodon:setup\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 Javascript heap out of memory 오류가 떴다면 바로 윗 문단에 따라 힙 용량 및 swap 설정을 하고 다음 명령어를 실행하면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eRAILS_ENV=production bundle \u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e rails assets:precompile\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e성공적으로 실행됐을 시 마스토돈 관리자 비밀번호가 표시될 것이다. 잊지 말고 메모하도록 하자.\u003c/p\u003e\n\u003ch2 id=\"nginx-설정\"\u003enginx 설정\u003c/h2\u003e\n\u003cp\u003e다음 명령어를 실행한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecp /home/mastodon/live/dist/nginx.conf /etc/nginx/sites-available/mastodon\nln -s /etc/nginx/sites-available/mastodon /etc/nginx/sites-enabled/mastodon\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e/etc/nginx/sites-available/mastodon\u003c/code\u003e 파일에서 \u003ccode\u003eexample.com\u003c/code\u003e을 모두 자신의 마스토돈 도메인(내 경우에는 \u003ccode\u003esocial.litehell.info\u003c/code\u003e)로 바꾼다. 그리고 다음 명령어를 실행한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esystemctl reload nginx\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"cloudflare-origin-certificate-설정\"\u003eCloudFlare Origin Certificate 설정\u003c/h2\u003e\n\u003cp\u003e필자는 CloudFlare Origin Certificate를 쓴다. CloudFlare에서 Origin Certificate를 생성한 뒤 서버에 저장하고, \u003ccode\u003e/etc/nginx/sites-available/mastodon\u003c/code\u003e 파일에서 \u003ccode\u003essl_certificate\u003c/code\u003e 속성과 \u003ccode\u003essl_certificate_key\u003c/code\u003e를 다운받은 서버/서버 개인키 경로로 수정하면 된다.\u003c/p\u003e\n\u003ch2 id=\"systemd-설정\"\u003esystemd 설정\u003c/h2\u003e\n\u003cp\u003e아래 명령어를 실행한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecp /home/mastodon/live/dist/mastodon-*.service /etc/systemd/system/\nsystemctl daemon-reload\nsystemctl \u003cspan class=\"hljs-built_in\"\u003eenable\u003c/span\u003e --now mastodon-web mastodon-sidekiq mastodon-streaming\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 마스토돈이 실행될 것이다. 이제 즐기면 된다.\u003c/p\u003e\n\u003ch2 id=\"cloudflare-최적화로-인한-사이트-깨짐-문제-해결\"\u003eCloudFlare 최적화로 인한 사이트 깨짐 문제 해결\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/img/broken_css_mastodon.png\" alt=\"CSS가 정상적으로 불러와지지 않은 마스토돈 인스턴스의 스크린샷\"\u003e\u003c/p\u003e\n\u003cp\u003eCloudFlare를 쓰면 위와 같이 마스토돈이 깨지는 문제를 겪을 수 있다.\n이는, 무결성을 위해 HTML 내에 CSS 파일의 해시가 포함되어있는데, CloudFlare가 CSS를 자동 최적화하면서 CSS 파일이 변경되고, 이로 인해 해시가 불일치됨에 따라 웹브라우저가 CSS를 불러오지 않음으로써 발생하는 문제이다.\u003c/p\u003e\n\u003cp\u003e이 문제는 CloudFlare에서 Auto Minify를 비활성화하고 모든 캐시를 삭제하여 해결할 수 있다.\u003c/p\u003e\n\u003ch2 id=\"릴레이-연결\"\u003e릴레이 연결\u003c/h2\u003e\n\u003cp\u003e마스토돈에 혼자 있으면 외롭다. 이를 극복하기 위해서는 릴레이를 연결해야 한다. 페디버스 내에서 인스턴스는 기본적으로 게시물을 팔로워가 있는 서버에만 전송한다. 따라서 타 서버의 팔로워가 없는 인스턴스는 외로울 수 밖에 없다. 이를 극복하기 위해 릴레이가 있다.\u003c/p\u003e\n\u003cp\u003e릴레이는 구독하는 서버들간에 게시물을 나눈다. 릴레이에 구독된 인스턴스가 게시물을 릴레이로 보내면, 릴레이가 구독된 모든 서버들에게 게시물을 전송하는 방식이다. 따라서 릴레이내에 있는 서버간에는 팔로워가 있는지의 여부와 상관없이 게시물이 서로 공유된다.\u003c/p\u003e\n\u003cp\u003e한국어권 릴레이는 다음 세가지 릴레이가 있다. 이 릴레이는 모두 화이트리스트이다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://relay.mastodon.kr\"\u003e한국 Mastodon 인스턴스 연합(가칭) 릴레이\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://interstellar.flights\"\u003e인터스텔라 릴레이 커뮤니티\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://relay.musubi.moe\"\u003emusubi.moe\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 릴레이에 가입하기 위해서는 각 릴레이에서 요구하는 조건을 모두 만족시킨 뒤 릴레이측에 가입 신청을 하면 된다. 가입 신청 방법 및 조건은 릴레이마다 다르다. 가입 신청이 받아들여지면 릴레이 관리 페이지(\u003ccode\u003e/admin/relays\u003c/code\u003e)에서 해당 릴레이에서 안내하는 주소를 추가하면 된다. 참고로 내 경험상 개인 인스턴스라고 딱히 안 받아주진 않았다. 조건만 맞으면 받아주는 것 같으니 조건이 맞는다면 부담없이 신청해보자.\u003c/p\u003e\n\u003cp\u003e모든 릴레이가 화이트리스트인 것은 아니다. \u003ca href=\"https://relaylist.com\"\u003eRelayList\u003c/a\u003e에서 Registeration이 open으로 되어있는 릴레이는 가입신청을 하지 않아도 되는 릴레이들이다. 다만 대규모 릴레이는 구독이 처리되는 데 시간이 좀 오래 걸릴 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://relay.fedi.buzz/\"\u003e#FediBuzz Relay\u003c/a\u003e 서비스를 이용하면 특정 마스토돈 인스턴스의 타임라인을 릴레이를 통해 구독할 수도 있다. 해당 사이트의 안내를 따르면 특정 인스턴스의 타임라인을 구독할 수 있다.\u003c/p\u003e\n\u003ch2 id=\"publicsystem-용량-문제\"\u003epublic/system 용량 문제\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003epublic/system\u003c/code\u003e 디렉토리는 용량을 많이 잡아먹는다. 다음 두 가지 방법 중 하나를 택하여 해결하면 된다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eS3-Compatible Object Storage 쓰기\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.joinmastodon.org/admin/setup/#cleanup\"\u003e마스토돈 공식 홈페이지의 Running periodic cleanup tasks 문단\u003c/a\u003e에 따라 crontab을 생성하고 마스토돈이 설치된 디렉토리에서 다음 명령어 모두 실행하기\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eRAILS_ENV=production ./bin/tootctl accounts prune\nRAILS_ENV=production ./bin/tootctl cache clear\nRAILS_ENV=production ./bin/tootctl media remove --days=0\nRAILS_ENV=production ./bin/tootctl media remove --prune-profiles --days=0\nRAILS_ENV=production ./bin/tootctl preview_cards remove --days=0\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ecrontab과 위 명령어만으로 부족하면 그냥 대용량 하드디스크 하나 꽂고 \u003ccode\u003e/etc/fstab\u003c/code\u003e 파일 수정해서 \u003ccode\u003epublic/system\u003c/code\u003e 디렉토리에 영구 마운트해버리기 (좀 무식하게 보일 수도 있지만 간단하고 직빵이다)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마음에 드는 방법을 택하도록 하자.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"min_max_heap"},"buildId":"tPvn0ikdnYc2gkfCdDjpk","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>