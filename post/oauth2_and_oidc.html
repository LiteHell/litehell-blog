<!DOCTYPE html><html lang="ko-KR"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><link rel="canonical" href="https://blog.litehell.info/post/oauth2_and_oidc"/><link rel="alternate" type="application/rss+xml" title="RSS 2.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/rss"/><link rel="alternate" type=" application/atom+xml" title="Atom 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/atom"/><link rel="alternate" type="application/feed+json" title="Json 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/json"/><meta property="og:title" content="OAuth 2.0과 OpenID Connect Core 1.0"/><meta property="og:description" content="동아리 홈페이지와 통합 인증에 관한 이야기"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="article"/><meta property="og:site_name" content="LiteHell의 블로그"/><meta property="og:url" content="https://blog.litehell.info/post/oauth2_and_oidc"/><meta property="og:image" content="https://blog.litehell.info/img/rfc6749_section4.1.1_fig3.svg"/><title>LiteHell의 블로그 - <!-- -->OAuth 2.0과 OpenID Connect Core 1.0</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/vs2015.min.css"/><meta name="next-head-count" content="16"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CZL0E8YDPW"></script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5916984077364289" crossorigin="anonymous"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-CZL0E8YDPW', { page_path: window.location.pathname });
            </script><link rel="preload" href="/_next/static/css/27d177a30947857b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27d177a30947857b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/088d29430e0ecbdb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/088d29430e0ecbdb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-ad45764ecfcae9e5.js" defer=""></script><script src="/_next/static/chunks/main-ee0cf4b7f81d7c24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a96cacb95f41a3ef.js" defer=""></script><script src="/_next/static/chunks/996-c5e5aa4c30f33066.js" defer=""></script><script src="/_next/static/chunks/503-25bfb158f613fce4.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-c55bde140ab34b85.js" defer=""></script><script src="/_next/static/C4IygSzdus1WQT9k-jkf-/_buildManifest.js" defer=""></script><script src="/_next/static/C4IygSzdus1WQT9k-jkf-/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_body__O2_kC"><header class="Layout_header__M_IZ8"><div class="Layout_container__z4qWC"><h1><a href="/">LiteHell의 블로그</a></h1><div class="Layout_outLinks__XBNs_">외부고리 : <a href="https://litehell.info">Homepage</a><a href="https://github.com/LiteHell">GitHub</a><a href="https://linkedin.com/in/LiteHell">LinkedIn</a><a href="https://keybase.io/LiteHell">Keybase</a><a href="mailto:litehell@litehell.info">Email</a></div><div class="Layout_inLinks__f7gmD">내부고리 : <a href="/category">카테고리</a><a href="/tag">태그</a></div></div></header><main class="Layout_mainContainer__5WZfx"><div class="Layout_container__z4qWC"><div class="Blog_header__r4wcZ"><div class="Blog_title___OFu6"><h1>OAuth 2.0과 OpenID Connect Core 1.0</h1><h2>동아리 홈페이지와 통합 인증에 관한 이야기</h2></div><p>1/25/2021, 9:27:00 AM<!-- -->에 <!-- -->LiteHell<!-- -->이(가) 작성<!-- -->함<br/><span>카테고리 : <a href="/category/Dev">Dev</a><br/></span><span>태그 : <span class="Blog_tag__RW5VK"><a href="/tag/SSO">SSO</a></span><span class="Blog_tag__RW5VK"><a href="/tag/OAuth">OAuth</a></span><span class="Blog_tag__RW5VK"><a href="/tag/OpenID_Connect">OpenID_Connect</a></span><br/></span></p></div><section class="Blog_article__WZp3G"><h1 id="들어가는-말">들어가는 말</h1>
<p>얼떨결에 동아리에서 자리를 하나 맡게 되면서 사이트를 인수인계받았다. <a href="https://github.com/2du/openNAMU">오픈나무</a>을 약간 수정해서 자체적으로 운영하던 사이트였는데, 회원들의 사적인 정보가 담겨있었다. 이걸 그냥 개방된 채로 뒀다가 사고가 나면 어떻게 될 지 상상하고 싶지 않더라.
그래서 사이트를 운영하기에 앞서 다음과 같이 수정해야할 필요가 있었다.</p>
<ul>
<li>위키를 외부인에게 공개해선 안 됐다.</li>
<li>누구나 위키에 가입해선 안 됐다.</li>
<li>학교 학생임을 증명해야 했다.</li>
</ul>
<h1 id="오픈나무-수정">오픈나무 수정</h1>
<p>첫번째 목표는 오픈나무에서 제공하는 ACL기능을 이용해서 달성할 수 있다. (ACL 기능을 <a href="https://github.com/2du/openNAMU/pull/923">도구로까지 확장하면</a> 더 완벽히 틀어막을 수 있다.)
다만 두번째 목표부터는 쉽지 않았다. 두번째 목표를 달성하려면 회원가입을 위키 소유자가 통제할 수 있는 기능이 필요했는데, 오픈나무에는 그런 기능이 없었다. 그래서 직접 <a href="https://github.com/2du/openNAMU/pull/819">회원가입 승인 기능</a>을 추가했다. 세번째 목표는 이메일 인증을 강제하고 도메인을 제한하는 방향으로 접근했다. 이걸 하려면 오픈나무에서 제공하는 이메일 화이트리스트 기능을 쓰면 되는데, 사소한 문제가 있었다. 오픈나무가 네이버, G메일, 다음, 카카오 메일을 강제로 자동추가한다는 점이다. (하드코딩이라 삭제도 안 된다.) 그래서 <a href="https://github.com/2du/openNAMU/pull/821">약간의 수정</a>으로 이 문제를 해결했다. 또한 이메일 발송시에 구글을 안 쓰는데 메일 발송 설정에서 구글만을 지원해서 이것도 <a href="https://github.com/2du/openNAMU/pull/842">수정</a>했다.</p>
<h2 id="게시판을-만들까">게시판을 만들까?</h2>
<p>그렇게 위키를 수정해서 굴리고 있었는데 문득 게시판이 있으면 좋겠다는 생각이 들었다.
근데 귀찮다고 XE만 깔고 통치면 위키랑 XE가 아이디가 따로 놀잖아.</p>
<p>이거는 보기가 별로 예쁘지 않다. 그래서 통합 로그인을 구축하기로 했다.</p>
<h3 id="접근방식">접근방식</h3>
<p>로그인을 통합하기 위해서는, 아이디와 비밀번호 등 인증 정보를 관리하는 서비스가 필요했다. 이 문단에서는 이를 <code>통합 로그인 제공자</code>라고 통칭한다.</p>
<p>위키밖에 없는 상황이니, 통합 로그인 제공자가 있을리 없었다. 이런 때에는 두가지 방법으로 접근할 수 있다.</p>
<ul>
<li>위키가 통합 로그인을 제공하도록 하고, 게시판이 위키를 통해 로그인하도록 하기</li>
<li>통합 로그인을 제공하는 사이트를 만들고, 위키와 게시판이 통합 로그인 제공자를 통해 로그인하도록 하기</li>
</ul>
<p>각자 장단점이 있다. 위키에서 통합 로그인을 제공하도록 하는 첫번째 방법은 아래와 같은 장점이 있다.</p>
<ul>
<li>장점<ul>
<li>기존에 있던 위키 이용자들의 인증 정보를 별다른 마이그레이션없이 그대로 쓸 수 있다.</li>
<li>기존에 있던 위키 소스코드를 수정하기만 하면 된다.</li>
</ul>
</li>
<li>단점<ul>
<li>위키 소스코드를 수정하는 과정이 굉장히 짜증날 것 같다.</li>
</ul>
</li>
</ul>
<p>두번째 방법의 장단점은 다음과 같다.</p>
<ul>
<li>장점<ul>
<li>개발하면서 공부를 더 많이 할 수 있다.</li>
<li>위키와 함께 합쳐두는 것보다는 따로따로 두는 것이 왠지 보기 깔끔할 것 같다.</li>
</ul>
</li>
<li>단점<ul>
<li>기존 위키의 인증 정보를 새로운 통합 로그인 제공자로 옮겨야 한다.</li>
<li>오픈나무도 통합 인증을 지원하도록 수정해야 했다.</li>
</ul>
</li>
</ul>
<p>나는 두번째 방법을 택했다. 그 이유로는 위키를 수정하는 과정이 번거로울 것 같아 차라리 새로 개발하는 게 더 좋을 것 같았고, 그 과정 속에서 공부가 더 많이 될 것 같았다. 인증 통합에 이용할 표준으로는 <a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Core 1.0</a>을 채택했는데, SAML2.0같은 다른 표준들은 복잡해 보였기 때문이다. (일단 SAML2.0은 XML을 써서 귀찮지만 OpenID Connect Core 1.0은 OAuth2.0 기반이고 JSON을 쓴다.)</p>
<h2 id="프로토타이핑">프로토타이핑</h2>
<p>두번째 방법을 택한 나는 일단 최단기간 안에 개발하기 위해 내게 익숙했던 언어와 프레임워크를 택했다. <a href="https://www.typescriptlang.org/">TypeScript</a> 언어와 <a href="https://github.com/koajs/koa">koajs</a> 프레임워크를 이용하고, 템플릿 엔진으로 <a href="https://github.com/koajs/koa">pugjs</a> 라이브러리를 이용했다. OpenID Connect Core 1.0 개발은 <a href="https://github.com/panva/node-oidc-provider">oidc-provider</a> 라이브러리를 이용했다.</p>
<p>근데 빠르게 개발한 것이라 그런가 문제가 있었다. 먼저 소스코드가 좀 많이 더러웠고, oidc-provider 라이브러리가 생각 이상으로 무거웠다. oidc-provider가 생성하는 세션과 홈페이지 자체적인 세션이 따로따로 노는 것도 약간 마음에 안 들었다.</p>
<p>그래도 일단 사이트를 만들긴 했으니 만든 사이트를 사용하고, 나중에 기회가 되면 사이트를 제대로 다시 만들기로 마음먹었다.</p>
<h2 id="리빌딩">리빌딩</h2>
<p>2020년 연말에 여유가 남아 사이트 재개발을 하기 시작했다. TypeScript를 이용하되 지난 번과 달리 프론트엔드랑 백엔드를 분리하기로 마음먹었다. 프로토타이핑때 백엔드랑 프론트엔드를 합친 &quot;전통적인 방식&quot;으로 개발했더니 소스코드가 영 보기 좀 그랬다.</p>
<p>그러려면 프론트엔드랑 백엔드 사이에 통신하는 API 스펙이 필요하다. 단순하게는 JSON 기반의 REST API를 이용하는 방법이 있다. 근데 이런 방식은 경험상 개발하다가도 스스로 API 스펙을 헷갈리기 쉽고, 문서화하기가 굉장히 귀찮았다.</p>
<p>그래서 어떻게 할까 생각하는데 문득 <a href="https://www.oss.kr/notice/show/18f215a2-a650-4c46-aaab-b4cf7d41484e?page=2">2020 오픈소스 컨트리뷰톤</a>에서 참가했던 <a href="https://github.com/dooboolab/hackatalk">HackaTalk</a> 프로젝트가 떠올랐다. HackaTalk의 서버 기술스택은 <a href="https://www.prisma.io">Prisma</a>-<a href="https://nexusjs.org/">GraphQL Nexus</a>로 이루어진 <a href="https://graphql.org/">GraphQL</a> 기반의 기술스택이다. Prisma는 GraphQL 개발시에 쓰면 편한 ORM이고, GraphQL Nexus는 GraphQL Schema를 작성할 때 쓰는 Code-First 철학의 라이브러리이다. GraphQL Nexus를 쓰면 Nexus에서 TypeScript Type Definition 파일을 자동으로 생성해줘 코딩할 때 인텔리센스와 TypeScript 컴파일러의 도움을 받을 수 있다.</p>
<p>이런 기술스택을 쓰면 괜찮겠다는 생각이 들어서, 백엔드는 Prisma와 GraphQL Nexus 기반에 <a href="https://github.com/prisma-labs/graphql-yoga">GraphQL Yoga</a>를 이용해 만들기로 했다. 프론트엔드는 <a href="https://ko.nuxtjs.org/">Nuxt.js</a>를 이용하고, GraphQL 요청은 <a href="https://www.npmjs.com/package/@nuxtjs/apollo">@nuxtjs/apollo</a>를 이용했다.</p>
<p>또한 이번 개발때는 oidc-provider와 같은 라이브러리를 이용하지 않고 OAuth2와 OpenID Connect Core 부분을 직접 개발하기로 마음먹었다.</p>
<h3 id="oauth2">OAuth2?</h3>
<p><a href="https://tools.ietf.org/html/rfc6749">OAuth2 (RFC6749)</a>란 리소스 소유자(주로 사용자)와 리소스 서버(주로 API 제공자), 리소스를 이용하고자 하는 HTTP 서비스(이하 클라이언트, 주로 서드파티) 간의 상호작용을 정의한 표준이다. 정보통신표준화위원회 <a href="http://committee.tta.or.kr/data/standard_view.jsp?order=t.standard_no&amp;by=asc&amp;pk_num=TTAE.IF-RFC6749&amp;commit_code=PG504">RFC6749 번역본</a>의 한글 내용요약을 인용하면 다음과 같다.</p>
<blockquote>
<p>공개 인증 2.0 프레임워크는 리소스 소유자를 대신하여 리소스 소유자와 HTTP 서비스간에 승인된 상호작용에 의하거나 또는 그 자신을 대신하여 얻은 접근권한을 제삼의 응용에게 제삼의 응용에게 허여하여, HTTP 서비스에 대한 제한적 접근을 획득하도록 제공을 한다. 본 표준은 공개 인증 1.0에 기술된 프로토콜을 대신한다.</p>
<p>-- 출처 : <a href="http://committee.tta.or.kr/data/standard_view.jsp?order=t.standard_no&amp;by=asc&amp;pk_num=TTAE.IF-RFC6749&amp;commit_code=PG504">TTAE.IF-RFC6749</a></p>
</blockquote>
<p>OAuth2는 거의 모든 웹 서비스에서 API 인증 방식으로 쓰이는 범용적인 표준이다. OAuth2가 없을 적에는 클아이너트가 리소스 소유자(주로 사용자)의 접근이 제한된 리소스(예시를 들자면 이메일 주소 같은 것들)에 지속적으로 접근하려면 리소스 소유자의 자격증명(credentials, 주로 비밀번호)을 바람직하지 않은 방법(예시: 평문)으로 저장해야 하는 문제점이 있었다. 또한 클라이언트가 비밀번호를 평문으로 저장하는 경우, 추후 접근 허가를 철회하거나 서드파티를 통제하기도 어렵다는 문제점도 있었다.</p>
<p>OAuth2는 이러한 문제점을 해결하기 위해 <code>Access Token(엑세스 토큰)</code>이란 개념을 도입한다. 액세스 토큰은 클라이언트가 접근이 제한된 리소스를 취득하기 위해 사용하는 자격증명으로, 토큰 그 자체로는 어떠한 의미도 지니지 않는다. 이 액세스 토큰은 OAuth2에서 정의하는 여러가지 방식에 따라 취득할 수 있는데, 리소스 소유자가 인증을 담당하는 Authorization 서버(혹은 리소스 서버, Authorization 서버와 리소스 서버는 동일할 수 있다.)에 직접 인증하는 방식이 거의 대부분이기에 서드파티에 자격증명을 줄 필요가 없다는 장점이 있다.</p>
<h4 id="authorization-code-grant">Authorization Code Grant</h4>
<p><code>Authorization Code Grant</code>는 클라이언트가 Access Token을 얻기 위한 방법 중 하나이다. 아래 그림은 RFC6749 Section 4.1의 Figure 3을 한국어로 옮긴 그림이다.</p>
<p><a href="https://tools.ietf.org/html/rfc6749#section-4.1"><img src="/img/rfc6749_section4.1.1_fig3.svg" alt="RFC6749 Section 4.1 Figure 3: Authorization Code Flow 한국어 번역"></a></p>
<p>그림의 설명하자면 다음과 같다. 먼저 클라이언트가 User-Agent(웹브라우저)를 클라이언트 식별자와 리다이렉션 주소가 담긴 Authorization Request 주소로 리다이렉트시키면(그림에서 (A) 단계), Authorization 서버에서는 사용자에게 인증을 요구한다(그림에서 (B) 단계). 사용자가 인증을 완료하면 Authorization 서버는 리다이렉트 주소에 Authorization Code를 <code>code</code> 매개변수로 추가해 User-Agent를 그 주소로 리다이렉트시킨다. (그림에서 (C) 단계) 그러면 클라이언트는 <code>code</code> 매개변수로 Authorization Code를 얻게 되고, 이 코드를 Authorization 서버에 보내 엑세스 토큰과 교환할 것을 요청한다. (그림에서 (D) 단계) 그러면 Authorization 서버는 Authorization Code를 확인하고 그 코드가 올바르다면 액세스 토큰을 발급해 클라이언트에게 제공하게 된다. (그림에서 (E) 단계)</p>
<p>쉽게 말해, Authorization 서버가 사용자를 확인하면, Authorziation 서버는 클라이언트에게 Authorization Code를 주고, 클라이언트는 그 Authorization Code를 엑세스 토큰과 교환하는 방식이다.</p>
<p>Authorization Code Grant는, 코드를 주지 않고 바로 엑세스 토큰을 주는 Implicit Grant와 달리, 리소스 소유자에게 엑세스 토큰을 노출하지 않는다는 장점이 있다. 다만 Authorization Code Grant는 클라이언트 인증이 요구되므로 JavaScript 등으로 클라이언트 사이드에서 작동하는 웹 어플리케이션보다는 서버(백엔드)가 있는 웹 사이트에 적합하다.</p>
<h4 id="oauth2-인증의-구현">OAuth2 인증의 구현</h4>
<p>OAuth2 인증을 구현하기 위해 백엔드단에서 GraphQL 서버말고 HTTP 서버도 열어야 할 필요가 있다. 따라서 HTTP 서버를 열고 GraphQL 서버와 다른 포트에서 요청을 받도록 수정했다. (어처피 리버스 프록시 쓰면 포트 달라도 서비스하는 데엔 상관없다.)</p>
<p>OAuth2 인증을 구현하려면, 외적으로는 인증을 하는 Endpoint와(이하 <code>인증 Endpoint</code>, 보통 <code>/authorize</code>와 같은 이름으로 구현함) 토큰을 교환하거나 발급하는 Endpoint(<code>/token</code>과 같은 이름을 구현함.) 두가지를 구현해야 한다.</p>
<p>그런데 앞서 말했듯 프론트엔드와 백엔드가 분리되어 있다. 그러니 당연히 사용자의 인증정보(세션)도 프론트엔드단에서 관리하고 있으므로, 백엔드에서 프론트엔드를 거치고 않고 직접 받는 HTTP 서비스에서는 프론트엔드의 인증 정보를 바로 편하게 받을 수 없었다. (물론 가능은 하겠지만... &#39;굳이?&#39;라는 생각이 들었다. 그리고 그렇게 하면 코드가 생각보다 복잡해질 것 같았다.)
그래서, oidc-provider 라이브러리가 <code>/interaction/[Some ID Here]</code>와 같이 리다이렉트하던 것에서 힌트를 받아 다음과 같이 구현했다.</p>
<ol>
<li>인증 Endpoint에 요청이 들어오면</li>
<li>요청받은 내용을 전부 DB에 저장하고 그 DB 데이터의 Primary ID를 받아서</li>
<li>프론트엔드가 담당하는 페이지로 ID와 같이 전송한다. (예시 : <code>/authorize_oauth2/[Some ID Here]</code>)</li>
<li>그러면 프론트엔드에서 GraphQL 서버로의 요청을 통해 인증 요청을 처리한다.</li>
</ol>
<p>즉, HTTP API 서버의 인증 Endpoint는 요청받은 매개변수를 DB에 저장해 프론트엔드로 넘기는 역할만 하고, 실질적인 인증 처리는 프론트엔드와 GraphQL 서버단에서 이루어지도록 하는 것이다. 이렇게 함으로써 인증 Endpoint와 관련된 문제를 간단히 해결했다.</p>
<h3 id="openid-connect">OpenID Connect</h3>
<p>이제 OpenID Connect를 구현해야 한다. OpenID Connect는 OAuth2 프로토콜 위에서 동작하는 표준으로, 사용자에 대한 간단한 정보를 얻고 사용자를 인증할 수 있도록 하는 간단한 레이어 표준이다. <code>openid</code> scope를 포함한 OAuth2 Authorization Request를 보냄으로써 시작하며, <a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token">JSON Web Token</a> 표준을 이용해 사용자를 인증해주는 ID Token을 발급한다.</p>
<p>쉽게 말하면, 내가 Authorization Request를 보낼때 scope에 <code>openid</code>도 포함시키면, 서버에서 액세스 토큰 줄때 ID 토큰도 같이 주고, 이 액세스 토큰과 함께 <code>userinfo</code> Endpoint(후술)에 접근하면 사용자에 관한 정보(닉네임이라던지)도 주는 것에 관한 표준이라는 것이다.</p>
<p>OpenID Connect를 사용하는 목적과 범위을 통합 인증으로만 극한한다면, <a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Core</a> 표준의 일부분(<a href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">Section 3.1</a>, <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">Section 5.3</a>, <a href="https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication">Section 9</a>, 갱신 토큰도 지원한다면 <a href="https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokens">Section 12</a>도)과 <a href="https://openid.net/specs/openid-connect-rpinitiated-1_0.html">OpenID Connect RP-Initiated Logout 1.0 - draft 01</a>만 구현해도 실사용에는 크게 무리가 없다. <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect Discovery</a>에서 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Section 4 (Obtaining OpenID Provider Configuration Information)</a>도 구현하면 서드파티에서 통합 인증을 설정할 때 편하다. <a href="https://openid.net/specs/openid-connect-registration-1_0.html">OpenID Connect Dynamic Discovery</a>는 전체적인 서비스 운영을 폐쇄적으로 할 생각이라면 굳이 구현할 필요가 없다.</p>
<p>OpenID Connect Core는 다음과 같이 기존 OAuth2 구현을 확장하고 추가적인 <code>userinfo</code> Endpoint와 jwks를 제공하는 Endpoint를 만들어 구현할 수 있다.</p>
<ol>
<li>Authorization request 처리시 OpenID Connect Core 스펙에서 정의하는 prompt 매개변수, id_token_hint 매개변수, login_hint 매개변수를 처리하도록 확장한다.<ul>
<li>prompt 매개변수는 간단하게 prompt=none인데 인증이 안 된 경우라면 무조건 <code>login_required</code> 오류를 반환하도록 구현하면 된다.</li>
<li>id_token_hint나 login_hint는 id_token_hint와 login_hint에서 가리키는 사용자와 현재 로그인된 사용자가 다르다면 오류를 반환하도록 구현하면 된다.</li>
<li>state가 있다면 리다이렉트할 때 쿼리 매개변수로 state를 넣어 리다이렉트한다.</li>
</ul>
</li>
<li>토큰 Endpoint에서 엑세스 토큰을 발급할때 <code>openid</code> scope가 포함됐다면 ID 토큰도 함께 발급한다.<ul>
<li>ID Token 발급시에는 특별한 경우가 아니라면 RS256 알고리즘으로 서명해야 한다. (<a href="https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation">OpenID Connect Core 1.0 Section 3.1.3.7. ID Token Validation 문단</a>에서 <code>default of RS256</code>라는 표현으로 명시하고 있음.)</li>
<li>nonce가 있다면 id_token 발급할 때 nonce를 포함한다.</li>
<li>state가 있다면 리다이렉트할때 쿼리 매개변수로 state를 넣어 리다이렉트한다.</li>
</ul>
</li>
<li><code>userinfo</code> endpoint는 액세스 토큰의 scope에 따라 적절한 claim(<code>name</code>이나 <code>nickname</code> 같은 것들)들을 JSON 객체로 반환하도록 구현한다.</li>
<li>jwks를 반환하는 endpoint는 말 그대로 ID Token 발급시 사용하는 jwks의 공개키들을 jwks 형식으로 반환하도록 구현한다.</li>
</ol>
<p>RP-Initiated Logout도 구현하기로 했다면, 다음과 같은 행동을 하는 HTTP Endpoint를 하나 더 구현해야 된다.</p>
<ol>
<li>id_token_hint 있으면 검증하고</li>
<li>사용자를 로그아웃시킨 뒤</li>
<li>id_token_hint와 post_logout_redirect_uri가 <strong>동시에</strong> 주어졌다면 post_logout_redirect_uri가 허가된 주소인지 검증하고, 만약 그렇다면 post_logout_redirect_uri로 리다이렉트한다.<ul>
<li><strong>동시에</strong>가 중요하다. id_token_hint없이 post_logout_redirect_uri가 주어졌다면 무효한 요청이다.</li>
<li>요청 매개변수로 state가 주어졌다면 state도 같이 쿼리 매개변수로 붙어서 리다이렉트한다.</li>
</ul>
</li>
</ol>
<p>RP-Initiated Logout 표준은 OP에서 로그아웃하는 것에 대한 표준이므로, 다른 RP들에 관해서는 언급하고 있지 않다. OP에서 로그아웃할 때 다른 RP들도 로그아웃하는 것을 원한다면 <a href="https://openid.net/specs/openid-connect-session-1_0.html">OpenID Connect Session Management 1.0</a>이나 <a href="https://openid.net/specs/openid-connect-backchannel-1_0.html">OpenID Connect Back-Channel Logout</a>, <a href="https://openid.net/specs/openid-connect-frontchannel-1_0.html">OpenID Connect Front-Channel Logout</a>등의 Draft들 중 마음에 드는 것을 골라 구현하거나, 아니면 직접 자신의 방법으로 구현해야 한다.</p>
<p>추가적으로, OpenID Connect Discovery 표준도 구현하기로 했다면, 그냥 적절한 OpenID Provider Configuration Information을 반환하는 <code>/.well-known/openid-configuration</code> HTTP Endpoint를 구현하면 된다. 시간이 남으면 표준에서 제시하는 Webfinger 관련 API도 구현해도 되지만, 사이트 관리를 폐쇄적으로 할 계획이라면 굳이 그럴 필요가 없다.</p>
<h2 id="구현-끝">구현 끝</h2>
<p>위와 같이 구현하면 간단한 SSO 기능을 제공하는 사이트를 만들 수 있다. 이렇게 SSO를 제공하는 사이트에 회원관리 기능과 가입신청 받는 기능도 덧붙여서 간단한 동아리 회원관리 사이트를 만들었다.</p>
<p>Nextjs로 SPA를 구현해서 그런가 깔끔하더라. 수정해야 할 게 지금도 좀 있긴 하지만 예전보단 보기 좋아졌다.</p>
<h2 id="그래서-게시판은">그래서 게시판은?</h2>
<p>게을려서 아직 안 만들었다. 언젠가 만들지 않을까?
...농담이고, 사실 만들려고 했다가 &#39;단체채팅방이 있는데 굳이 만들어야 할까?&#39;라는 생각이 들어 만들지 않았다. 그래도 이 홈페이지를 개발하면서 많은 도움이 됐다.</p>
<p>끝</p>
</section><div class="Comments_blogComments__GRWmY"></div><nav class="Blog_postNav__ivy8_ Blog_hasBoth__3MRPr"><div class="Blog_leftAnchor__HhzIP"><a href="/post/loremipsum"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">Lorem ipsum</div><div class="Blog_subtitle__RRFh7">블로그 테스트를 위한 Lorem ipsum</div></div></a></div><div class="Blog_rightAnchor__B9n7B"><a href="/post/first_use_of_firebase"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">Firebase 처음 써본 이야기</div><div class="Blog_subtitle__RRFh7">데이터베이스 스카마 설계하기 귀찮을 때</div></div></a></div></nav></div></main><footer class="Layout_footer__bKkxe"><div class="Layout_container__z4qWC"><a href="https://www.gnu.org/licenses/agpl-3.0.en.html"><img alt="GNU Affero General License Version 3" src="https://www.gnu.org/graphics/agplv3-with-text-100x42.png" style="height:31px"/></a> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a><br/>Copyrights (C) 2020 ~ 2024 LiteHell, All rights reserved.<br/><div class="Layout_visibleOnPrintOnly__UK6Yl">LiteHell&#x27;s Blog - <a href="https://blog.litehell.info">https://blog.litehell.info</a><br/>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.<br/><br/>Url of this article: <a href="https://blog.litehell.info/post/oauth2_and_oidc">https://blog.litehell.info/post/oauth2_and_oidc</a><br/></div><div class="Layout_invisibleOnPrint__rdrDv">Fox Image : Copyrights (C) 2004 Shiretoko-Shari Torurist Association<br/><a href="/license">This blog is free software; For source code and more informations on license and copyrights, Click here.</a><br/><br/>Feeds : <a href="/feed/rss">RSS 2.0</a>,<!-- --> <a href="/feed/atom">Atom 1.0</a>, <a href="/feed/json">Json 1.0</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"metadata":{"title":"OAuth 2.0과 OpenID Connect Core 1.0","subtitle":"동아리 홈페이지와 통합 인증에 관한 이야기","author":"LiteHell","date":"2021-01-25T18:27:00+09:00","category":"Dev","tags":["SSO","OAuth","OpenID_Connect"]},"rendered":"\u003ch1 id=\"들어가는-말\"\u003e들어가는 말\u003c/h1\u003e\n\u003cp\u003e얼떨결에 동아리에서 자리를 하나 맡게 되면서 사이트를 인수인계받았다. \u003ca href=\"https://github.com/2du/openNAMU\"\u003e오픈나무\u003c/a\u003e을 약간 수정해서 자체적으로 운영하던 사이트였는데, 회원들의 사적인 정보가 담겨있었다. 이걸 그냥 개방된 채로 뒀다가 사고가 나면 어떻게 될 지 상상하고 싶지 않더라.\n그래서 사이트를 운영하기에 앞서 다음과 같이 수정해야할 필요가 있었다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e위키를 외부인에게 공개해선 안 됐다.\u003c/li\u003e\n\u003cli\u003e누구나 위키에 가입해선 안 됐다.\u003c/li\u003e\n\u003cli\u003e학교 학생임을 증명해야 했다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"오픈나무-수정\"\u003e오픈나무 수정\u003c/h1\u003e\n\u003cp\u003e첫번째 목표는 오픈나무에서 제공하는 ACL기능을 이용해서 달성할 수 있다. (ACL 기능을 \u003ca href=\"https://github.com/2du/openNAMU/pull/923\"\u003e도구로까지 확장하면\u003c/a\u003e 더 완벽히 틀어막을 수 있다.)\n다만 두번째 목표부터는 쉽지 않았다. 두번째 목표를 달성하려면 회원가입을 위키 소유자가 통제할 수 있는 기능이 필요했는데, 오픈나무에는 그런 기능이 없었다. 그래서 직접 \u003ca href=\"https://github.com/2du/openNAMU/pull/819\"\u003e회원가입 승인 기능\u003c/a\u003e을 추가했다. 세번째 목표는 이메일 인증을 강제하고 도메인을 제한하는 방향으로 접근했다. 이걸 하려면 오픈나무에서 제공하는 이메일 화이트리스트 기능을 쓰면 되는데, 사소한 문제가 있었다. 오픈나무가 네이버, G메일, 다음, 카카오 메일을 강제로 자동추가한다는 점이다. (하드코딩이라 삭제도 안 된다.) 그래서 \u003ca href=\"https://github.com/2du/openNAMU/pull/821\"\u003e약간의 수정\u003c/a\u003e으로 이 문제를 해결했다. 또한 이메일 발송시에 구글을 안 쓰는데 메일 발송 설정에서 구글만을 지원해서 이것도 \u003ca href=\"https://github.com/2du/openNAMU/pull/842\"\u003e수정\u003c/a\u003e했다.\u003c/p\u003e\n\u003ch2 id=\"게시판을-만들까\"\u003e게시판을 만들까?\u003c/h2\u003e\n\u003cp\u003e그렇게 위키를 수정해서 굴리고 있었는데 문득 게시판이 있으면 좋겠다는 생각이 들었다.\n근데 귀찮다고 XE만 깔고 통치면 위키랑 XE가 아이디가 따로 놀잖아.\u003c/p\u003e\n\u003cp\u003e이거는 보기가 별로 예쁘지 않다. 그래서 통합 로그인을 구축하기로 했다.\u003c/p\u003e\n\u003ch3 id=\"접근방식\"\u003e접근방식\u003c/h3\u003e\n\u003cp\u003e로그인을 통합하기 위해서는, 아이디와 비밀번호 등 인증 정보를 관리하는 서비스가 필요했다. 이 문단에서는 이를 \u003ccode\u003e통합 로그인 제공자\u003c/code\u003e라고 통칭한다.\u003c/p\u003e\n\u003cp\u003e위키밖에 없는 상황이니, 통합 로그인 제공자가 있을리 없었다. 이런 때에는 두가지 방법으로 접근할 수 있다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e위키가 통합 로그인을 제공하도록 하고, 게시판이 위키를 통해 로그인하도록 하기\u003c/li\u003e\n\u003cli\u003e통합 로그인을 제공하는 사이트를 만들고, 위키와 게시판이 통합 로그인 제공자를 통해 로그인하도록 하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e각자 장단점이 있다. 위키에서 통합 로그인을 제공하도록 하는 첫번째 방법은 아래와 같은 장점이 있다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e장점\u003cul\u003e\n\u003cli\u003e기존에 있던 위키 이용자들의 인증 정보를 별다른 마이그레이션없이 그대로 쓸 수 있다.\u003c/li\u003e\n\u003cli\u003e기존에 있던 위키 소스코드를 수정하기만 하면 된다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e단점\u003cul\u003e\n\u003cli\u003e위키 소스코드를 수정하는 과정이 굉장히 짜증날 것 같다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e두번째 방법의 장단점은 다음과 같다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e장점\u003cul\u003e\n\u003cli\u003e개발하면서 공부를 더 많이 할 수 있다.\u003c/li\u003e\n\u003cli\u003e위키와 함께 합쳐두는 것보다는 따로따로 두는 것이 왠지 보기 깔끔할 것 같다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e단점\u003cul\u003e\n\u003cli\u003e기존 위키의 인증 정보를 새로운 통합 로그인 제공자로 옮겨야 한다.\u003c/li\u003e\n\u003cli\u003e오픈나무도 통합 인증을 지원하도록 수정해야 했다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e나는 두번째 방법을 택했다. 그 이유로는 위키를 수정하는 과정이 번거로울 것 같아 차라리 새로 개발하는 게 더 좋을 것 같았고, 그 과정 속에서 공부가 더 많이 될 것 같았다. 인증 통합에 이용할 표준으로는 \u003ca href=\"https://openid.net/specs/openid-connect-core-1_0.html\"\u003eOpenID Connect Core 1.0\u003c/a\u003e을 채택했는데, SAML2.0같은 다른 표준들은 복잡해 보였기 때문이다. (일단 SAML2.0은 XML을 써서 귀찮지만 OpenID Connect Core 1.0은 OAuth2.0 기반이고 JSON을 쓴다.)\u003c/p\u003e\n\u003ch2 id=\"프로토타이핑\"\u003e프로토타이핑\u003c/h2\u003e\n\u003cp\u003e두번째 방법을 택한 나는 일단 최단기간 안에 개발하기 위해 내게 익숙했던 언어와 프레임워크를 택했다. \u003ca href=\"https://www.typescriptlang.org/\"\u003eTypeScript\u003c/a\u003e 언어와 \u003ca href=\"https://github.com/koajs/koa\"\u003ekoajs\u003c/a\u003e 프레임워크를 이용하고, 템플릿 엔진으로 \u003ca href=\"https://github.com/koajs/koa\"\u003epugjs\u003c/a\u003e 라이브러리를 이용했다. OpenID Connect Core 1.0 개발은 \u003ca href=\"https://github.com/panva/node-oidc-provider\"\u003eoidc-provider\u003c/a\u003e 라이브러리를 이용했다.\u003c/p\u003e\n\u003cp\u003e근데 빠르게 개발한 것이라 그런가 문제가 있었다. 먼저 소스코드가 좀 많이 더러웠고, oidc-provider 라이브러리가 생각 이상으로 무거웠다. oidc-provider가 생성하는 세션과 홈페이지 자체적인 세션이 따로따로 노는 것도 약간 마음에 안 들었다.\u003c/p\u003e\n\u003cp\u003e그래도 일단 사이트를 만들긴 했으니 만든 사이트를 사용하고, 나중에 기회가 되면 사이트를 제대로 다시 만들기로 마음먹었다.\u003c/p\u003e\n\u003ch2 id=\"리빌딩\"\u003e리빌딩\u003c/h2\u003e\n\u003cp\u003e2020년 연말에 여유가 남아 사이트 재개발을 하기 시작했다. TypeScript를 이용하되 지난 번과 달리 프론트엔드랑 백엔드를 분리하기로 마음먹었다. 프로토타이핑때 백엔드랑 프론트엔드를 합친 \u0026quot;전통적인 방식\u0026quot;으로 개발했더니 소스코드가 영 보기 좀 그랬다.\u003c/p\u003e\n\u003cp\u003e그러려면 프론트엔드랑 백엔드 사이에 통신하는 API 스펙이 필요하다. 단순하게는 JSON 기반의 REST API를 이용하는 방법이 있다. 근데 이런 방식은 경험상 개발하다가도 스스로 API 스펙을 헷갈리기 쉽고, 문서화하기가 굉장히 귀찮았다.\u003c/p\u003e\n\u003cp\u003e그래서 어떻게 할까 생각하는데 문득 \u003ca href=\"https://www.oss.kr/notice/show/18f215a2-a650-4c46-aaab-b4cf7d41484e?page=2\"\u003e2020 오픈소스 컨트리뷰톤\u003c/a\u003e에서 참가했던 \u003ca href=\"https://github.com/dooboolab/hackatalk\"\u003eHackaTalk\u003c/a\u003e 프로젝트가 떠올랐다. HackaTalk의 서버 기술스택은 \u003ca href=\"https://www.prisma.io\"\u003ePrisma\u003c/a\u003e-\u003ca href=\"https://nexusjs.org/\"\u003eGraphQL Nexus\u003c/a\u003e로 이루어진 \u003ca href=\"https://graphql.org/\"\u003eGraphQL\u003c/a\u003e 기반의 기술스택이다. Prisma는 GraphQL 개발시에 쓰면 편한 ORM이고, GraphQL Nexus는 GraphQL Schema를 작성할 때 쓰는 Code-First 철학의 라이브러리이다. GraphQL Nexus를 쓰면 Nexus에서 TypeScript Type Definition 파일을 자동으로 생성해줘 코딩할 때 인텔리센스와 TypeScript 컴파일러의 도움을 받을 수 있다.\u003c/p\u003e\n\u003cp\u003e이런 기술스택을 쓰면 괜찮겠다는 생각이 들어서, 백엔드는 Prisma와 GraphQL Nexus 기반에 \u003ca href=\"https://github.com/prisma-labs/graphql-yoga\"\u003eGraphQL Yoga\u003c/a\u003e를 이용해 만들기로 했다. 프론트엔드는 \u003ca href=\"https://ko.nuxtjs.org/\"\u003eNuxt.js\u003c/a\u003e를 이용하고, GraphQL 요청은 \u003ca href=\"https://www.npmjs.com/package/@nuxtjs/apollo\"\u003e@nuxtjs/apollo\u003c/a\u003e를 이용했다.\u003c/p\u003e\n\u003cp\u003e또한 이번 개발때는 oidc-provider와 같은 라이브러리를 이용하지 않고 OAuth2와 OpenID Connect Core 부분을 직접 개발하기로 마음먹었다.\u003c/p\u003e\n\u003ch3 id=\"oauth2\"\u003eOAuth2?\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://tools.ietf.org/html/rfc6749\"\u003eOAuth2 (RFC6749)\u003c/a\u003e란 리소스 소유자(주로 사용자)와 리소스 서버(주로 API 제공자), 리소스를 이용하고자 하는 HTTP 서비스(이하 클라이언트, 주로 서드파티) 간의 상호작용을 정의한 표준이다. 정보통신표준화위원회 \u003ca href=\"http://committee.tta.or.kr/data/standard_view.jsp?order=t.standard_no\u0026amp;by=asc\u0026amp;pk_num=TTAE.IF-RFC6749\u0026amp;commit_code=PG504\"\u003eRFC6749 번역본\u003c/a\u003e의 한글 내용요약을 인용하면 다음과 같다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e공개 인증 2.0 프레임워크는 리소스 소유자를 대신하여 리소스 소유자와 HTTP 서비스간에 승인된 상호작용에 의하거나 또는 그 자신을 대신하여 얻은 접근권한을 제삼의 응용에게 제삼의 응용에게 허여하여, HTTP 서비스에 대한 제한적 접근을 획득하도록 제공을 한다. 본 표준은 공개 인증 1.0에 기술된 프로토콜을 대신한다.\u003c/p\u003e\n\u003cp\u003e-- 출처 : \u003ca href=\"http://committee.tta.or.kr/data/standard_view.jsp?order=t.standard_no\u0026amp;by=asc\u0026amp;pk_num=TTAE.IF-RFC6749\u0026amp;commit_code=PG504\"\u003eTTAE.IF-RFC6749\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOAuth2는 거의 모든 웹 서비스에서 API 인증 방식으로 쓰이는 범용적인 표준이다. OAuth2가 없을 적에는 클아이너트가 리소스 소유자(주로 사용자)의 접근이 제한된 리소스(예시를 들자면 이메일 주소 같은 것들)에 지속적으로 접근하려면 리소스 소유자의 자격증명(credentials, 주로 비밀번호)을 바람직하지 않은 방법(예시: 평문)으로 저장해야 하는 문제점이 있었다. 또한 클라이언트가 비밀번호를 평문으로 저장하는 경우, 추후 접근 허가를 철회하거나 서드파티를 통제하기도 어렵다는 문제점도 있었다.\u003c/p\u003e\n\u003cp\u003eOAuth2는 이러한 문제점을 해결하기 위해 \u003ccode\u003eAccess Token(엑세스 토큰)\u003c/code\u003e이란 개념을 도입한다. 액세스 토큰은 클라이언트가 접근이 제한된 리소스를 취득하기 위해 사용하는 자격증명으로, 토큰 그 자체로는 어떠한 의미도 지니지 않는다. 이 액세스 토큰은 OAuth2에서 정의하는 여러가지 방식에 따라 취득할 수 있는데, 리소스 소유자가 인증을 담당하는 Authorization 서버(혹은 리소스 서버, Authorization 서버와 리소스 서버는 동일할 수 있다.)에 직접 인증하는 방식이 거의 대부분이기에 서드파티에 자격증명을 줄 필요가 없다는 장점이 있다.\u003c/p\u003e\n\u003ch4 id=\"authorization-code-grant\"\u003eAuthorization Code Grant\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eAuthorization Code Grant\u003c/code\u003e는 클라이언트가 Access Token을 얻기 위한 방법 중 하나이다. 아래 그림은 RFC6749 Section 4.1의 Figure 3을 한국어로 옮긴 그림이다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://tools.ietf.org/html/rfc6749#section-4.1\"\u003e\u003cimg src=\"/img/rfc6749_section4.1.1_fig3.svg\" alt=\"RFC6749 Section 4.1 Figure 3: Authorization Code Flow 한국어 번역\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e그림의 설명하자면 다음과 같다. 먼저 클라이언트가 User-Agent(웹브라우저)를 클라이언트 식별자와 리다이렉션 주소가 담긴 Authorization Request 주소로 리다이렉트시키면(그림에서 (A) 단계), Authorization 서버에서는 사용자에게 인증을 요구한다(그림에서 (B) 단계). 사용자가 인증을 완료하면 Authorization 서버는 리다이렉트 주소에 Authorization Code를 \u003ccode\u003ecode\u003c/code\u003e 매개변수로 추가해 User-Agent를 그 주소로 리다이렉트시킨다. (그림에서 (C) 단계) 그러면 클라이언트는 \u003ccode\u003ecode\u003c/code\u003e 매개변수로 Authorization Code를 얻게 되고, 이 코드를 Authorization 서버에 보내 엑세스 토큰과 교환할 것을 요청한다. (그림에서 (D) 단계) 그러면 Authorization 서버는 Authorization Code를 확인하고 그 코드가 올바르다면 액세스 토큰을 발급해 클라이언트에게 제공하게 된다. (그림에서 (E) 단계)\u003c/p\u003e\n\u003cp\u003e쉽게 말해, Authorization 서버가 사용자를 확인하면, Authorziation 서버는 클라이언트에게 Authorization Code를 주고, 클라이언트는 그 Authorization Code를 엑세스 토큰과 교환하는 방식이다.\u003c/p\u003e\n\u003cp\u003eAuthorization Code Grant는, 코드를 주지 않고 바로 엑세스 토큰을 주는 Implicit Grant와 달리, 리소스 소유자에게 엑세스 토큰을 노출하지 않는다는 장점이 있다. 다만 Authorization Code Grant는 클라이언트 인증이 요구되므로 JavaScript 등으로 클라이언트 사이드에서 작동하는 웹 어플리케이션보다는 서버(백엔드)가 있는 웹 사이트에 적합하다.\u003c/p\u003e\n\u003ch4 id=\"oauth2-인증의-구현\"\u003eOAuth2 인증의 구현\u003c/h4\u003e\n\u003cp\u003eOAuth2 인증을 구현하기 위해 백엔드단에서 GraphQL 서버말고 HTTP 서버도 열어야 할 필요가 있다. 따라서 HTTP 서버를 열고 GraphQL 서버와 다른 포트에서 요청을 받도록 수정했다. (어처피 리버스 프록시 쓰면 포트 달라도 서비스하는 데엔 상관없다.)\u003c/p\u003e\n\u003cp\u003eOAuth2 인증을 구현하려면, 외적으로는 인증을 하는 Endpoint와(이하 \u003ccode\u003e인증 Endpoint\u003c/code\u003e, 보통 \u003ccode\u003e/authorize\u003c/code\u003e와 같은 이름으로 구현함) 토큰을 교환하거나 발급하는 Endpoint(\u003ccode\u003e/token\u003c/code\u003e과 같은 이름을 구현함.) 두가지를 구현해야 한다.\u003c/p\u003e\n\u003cp\u003e그런데 앞서 말했듯 프론트엔드와 백엔드가 분리되어 있다. 그러니 당연히 사용자의 인증정보(세션)도 프론트엔드단에서 관리하고 있으므로, 백엔드에서 프론트엔드를 거치고 않고 직접 받는 HTTP 서비스에서는 프론트엔드의 인증 정보를 바로 편하게 받을 수 없었다. (물론 가능은 하겠지만... \u0026#39;굳이?\u0026#39;라는 생각이 들었다. 그리고 그렇게 하면 코드가 생각보다 복잡해질 것 같았다.)\n그래서, oidc-provider 라이브러리가 \u003ccode\u003e/interaction/[Some ID Here]\u003c/code\u003e와 같이 리다이렉트하던 것에서 힌트를 받아 다음과 같이 구현했다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e인증 Endpoint에 요청이 들어오면\u003c/li\u003e\n\u003cli\u003e요청받은 내용을 전부 DB에 저장하고 그 DB 데이터의 Primary ID를 받아서\u003c/li\u003e\n\u003cli\u003e프론트엔드가 담당하는 페이지로 ID와 같이 전송한다. (예시 : \u003ccode\u003e/authorize_oauth2/[Some ID Here]\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e그러면 프론트엔드에서 GraphQL 서버로의 요청을 통해 인증 요청을 처리한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e즉, HTTP API 서버의 인증 Endpoint는 요청받은 매개변수를 DB에 저장해 프론트엔드로 넘기는 역할만 하고, 실질적인 인증 처리는 프론트엔드와 GraphQL 서버단에서 이루어지도록 하는 것이다. 이렇게 함으로써 인증 Endpoint와 관련된 문제를 간단히 해결했다.\u003c/p\u003e\n\u003ch3 id=\"openid-connect\"\u003eOpenID Connect\u003c/h3\u003e\n\u003cp\u003e이제 OpenID Connect를 구현해야 한다. OpenID Connect는 OAuth2 프로토콜 위에서 동작하는 표준으로, 사용자에 대한 간단한 정보를 얻고 사용자를 인증할 수 있도록 하는 간단한 레이어 표준이다. \u003ccode\u003eopenid\u003c/code\u003e scope를 포함한 OAuth2 Authorization Request를 보냄으로써 시작하며, \u003ca href=\"http://tools.ietf.org/html/draft-ietf-oauth-json-web-token\"\u003eJSON Web Token\u003c/a\u003e 표준을 이용해 사용자를 인증해주는 ID Token을 발급한다.\u003c/p\u003e\n\u003cp\u003e쉽게 말하면, 내가 Authorization Request를 보낼때 scope에 \u003ccode\u003eopenid\u003c/code\u003e도 포함시키면, 서버에서 액세스 토큰 줄때 ID 토큰도 같이 주고, 이 액세스 토큰과 함께 \u003ccode\u003euserinfo\u003c/code\u003e Endpoint(후술)에 접근하면 사용자에 관한 정보(닉네임이라던지)도 주는 것에 관한 표준이라는 것이다.\u003c/p\u003e\n\u003cp\u003eOpenID Connect를 사용하는 목적과 범위을 통합 인증으로만 극한한다면, \u003ca href=\"https://openid.net/specs/openid-connect-core-1_0.html\"\u003eOpenID Connect Core\u003c/a\u003e 표준의 일부분(\u003ca href=\"https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth\"\u003eSection 3.1\u003c/a\u003e, \u003ca href=\"https://openid.net/specs/openid-connect-core-1_0.html#UserInfo\"\u003eSection 5.3\u003c/a\u003e, \u003ca href=\"https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication\"\u003eSection 9\u003c/a\u003e, 갱신 토큰도 지원한다면 \u003ca href=\"https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokens\"\u003eSection 12\u003c/a\u003e도)과 \u003ca href=\"https://openid.net/specs/openid-connect-rpinitiated-1_0.html\"\u003eOpenID Connect RP-Initiated Logout 1.0 - draft 01\u003c/a\u003e만 구현해도 실사용에는 크게 무리가 없다. \u003ca href=\"https://openid.net/specs/openid-connect-discovery-1_0.html\"\u003eOpenID Connect Discovery\u003c/a\u003e에서 \u003ca href=\"https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig\"\u003eSection 4 (Obtaining OpenID Provider Configuration Information)\u003c/a\u003e도 구현하면 서드파티에서 통합 인증을 설정할 때 편하다. \u003ca href=\"https://openid.net/specs/openid-connect-registration-1_0.html\"\u003eOpenID Connect Dynamic Discovery\u003c/a\u003e는 전체적인 서비스 운영을 폐쇄적으로 할 생각이라면 굳이 구현할 필요가 없다.\u003c/p\u003e\n\u003cp\u003eOpenID Connect Core는 다음과 같이 기존 OAuth2 구현을 확장하고 추가적인 \u003ccode\u003euserinfo\u003c/code\u003e Endpoint와 jwks를 제공하는 Endpoint를 만들어 구현할 수 있다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eAuthorization request 처리시 OpenID Connect Core 스펙에서 정의하는 prompt 매개변수, id_token_hint 매개변수, login_hint 매개변수를 처리하도록 확장한다.\u003cul\u003e\n\u003cli\u003eprompt 매개변수는 간단하게 prompt=none인데 인증이 안 된 경우라면 무조건 \u003ccode\u003elogin_required\u003c/code\u003e 오류를 반환하도록 구현하면 된다.\u003c/li\u003e\n\u003cli\u003eid_token_hint나 login_hint는 id_token_hint와 login_hint에서 가리키는 사용자와 현재 로그인된 사용자가 다르다면 오류를 반환하도록 구현하면 된다.\u003c/li\u003e\n\u003cli\u003estate가 있다면 리다이렉트할 때 쿼리 매개변수로 state를 넣어 리다이렉트한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e토큰 Endpoint에서 엑세스 토큰을 발급할때 \u003ccode\u003eopenid\u003c/code\u003e scope가 포함됐다면 ID 토큰도 함께 발급한다.\u003cul\u003e\n\u003cli\u003eID Token 발급시에는 특별한 경우가 아니라면 RS256 알고리즘으로 서명해야 한다. (\u003ca href=\"https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\"\u003eOpenID Connect Core 1.0 Section 3.1.3.7. ID Token Validation 문단\u003c/a\u003e에서 \u003ccode\u003edefault of RS256\u003c/code\u003e라는 표현으로 명시하고 있음.)\u003c/li\u003e\n\u003cli\u003enonce가 있다면 id_token 발급할 때 nonce를 포함한다.\u003c/li\u003e\n\u003cli\u003estate가 있다면 리다이렉트할때 쿼리 매개변수로 state를 넣어 리다이렉트한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euserinfo\u003c/code\u003e endpoint는 액세스 토큰의 scope에 따라 적절한 claim(\u003ccode\u003ename\u003c/code\u003e이나 \u003ccode\u003enickname\u003c/code\u003e 같은 것들)들을 JSON 객체로 반환하도록 구현한다.\u003c/li\u003e\n\u003cli\u003ejwks를 반환하는 endpoint는 말 그대로 ID Token 발급시 사용하는 jwks의 공개키들을 jwks 형식으로 반환하도록 구현한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eRP-Initiated Logout도 구현하기로 했다면, 다음과 같은 행동을 하는 HTTP Endpoint를 하나 더 구현해야 된다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eid_token_hint 있으면 검증하고\u003c/li\u003e\n\u003cli\u003e사용자를 로그아웃시킨 뒤\u003c/li\u003e\n\u003cli\u003eid_token_hint와 post_logout_redirect_uri가 \u003cstrong\u003e동시에\u003c/strong\u003e 주어졌다면 post_logout_redirect_uri가 허가된 주소인지 검증하고, 만약 그렇다면 post_logout_redirect_uri로 리다이렉트한다.\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e동시에\u003c/strong\u003e가 중요하다. id_token_hint없이 post_logout_redirect_uri가 주어졌다면 무효한 요청이다.\u003c/li\u003e\n\u003cli\u003e요청 매개변수로 state가 주어졌다면 state도 같이 쿼리 매개변수로 붙어서 리다이렉트한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eRP-Initiated Logout 표준은 OP에서 로그아웃하는 것에 대한 표준이므로, 다른 RP들에 관해서는 언급하고 있지 않다. OP에서 로그아웃할 때 다른 RP들도 로그아웃하는 것을 원한다면 \u003ca href=\"https://openid.net/specs/openid-connect-session-1_0.html\"\u003eOpenID Connect Session Management 1.0\u003c/a\u003e이나 \u003ca href=\"https://openid.net/specs/openid-connect-backchannel-1_0.html\"\u003eOpenID Connect Back-Channel Logout\u003c/a\u003e, \u003ca href=\"https://openid.net/specs/openid-connect-frontchannel-1_0.html\"\u003eOpenID Connect Front-Channel Logout\u003c/a\u003e등의 Draft들 중 마음에 드는 것을 골라 구현하거나, 아니면 직접 자신의 방법으로 구현해야 한다.\u003c/p\u003e\n\u003cp\u003e추가적으로, OpenID Connect Discovery 표준도 구현하기로 했다면, 그냥 적절한 OpenID Provider Configuration Information을 반환하는 \u003ccode\u003e/.well-known/openid-configuration\u003c/code\u003e HTTP Endpoint를 구현하면 된다. 시간이 남으면 표준에서 제시하는 Webfinger 관련 API도 구현해도 되지만, 사이트 관리를 폐쇄적으로 할 계획이라면 굳이 그럴 필요가 없다.\u003c/p\u003e\n\u003ch2 id=\"구현-끝\"\u003e구현 끝\u003c/h2\u003e\n\u003cp\u003e위와 같이 구현하면 간단한 SSO 기능을 제공하는 사이트를 만들 수 있다. 이렇게 SSO를 제공하는 사이트에 회원관리 기능과 가입신청 받는 기능도 덧붙여서 간단한 동아리 회원관리 사이트를 만들었다.\u003c/p\u003e\n\u003cp\u003eNextjs로 SPA를 구현해서 그런가 깔끔하더라. 수정해야 할 게 지금도 좀 있긴 하지만 예전보단 보기 좋아졌다.\u003c/p\u003e\n\u003ch2 id=\"그래서-게시판은\"\u003e그래서 게시판은?\u003c/h2\u003e\n\u003cp\u003e게을려서 아직 안 만들었다. 언젠가 만들지 않을까?\n...농담이고, 사실 만들려고 했다가 \u0026#39;단체채팅방이 있는데 굳이 만들어야 할까?\u0026#39;라는 생각이 들어 만들지 않았다. 그래도 이 홈페이지를 개발하면서 많은 도움이 됐다.\u003c/p\u003e\n\u003cp\u003e끝\u003c/p\u003e\n"},"articleId":"oauth2_and_oidc","previousPost":{"name":"loremipsum","metadata":{"title":"Lorem ipsum","subtitle":"블로그 테스트를 위한 Lorem ipsum","author":"LiteHell","date":"2020-01-24T02:36:00+09:00"},"rendered":"\u003ch1 id=\"lorem-ipsum\"\u003eLorem ipsum\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003eLorem ipsum dolor sit amet, consectetur adipiscing elit.\u003c/strong\u003e \u003ca href=\"https://www.example.com\"\u003eAenean faucibus\u003c/a\u003e tristique \u003cem\u003edolor\u003c/em\u003e sit amet pharetra. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Nulla non aliquam ligula. Fusce at turpis enim. Praesent nec sagittis sapien, in euismod odio. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Praesent in ultricies lectus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Morbi eleifend quis ex in tempor. Donec vestibulum, leo id semper tempus, leo lacus semper quam, id tincidunt orci libero sed eros. Nam pretium ante in rutrum rutrum. Donec et bibendum metus. Vivamus tellus ipsum, condimentum in massa nec, egestas bibendum elit. Morbi tortor velit, elementum tincidunt iaculis sed, tristique vel tellus. Cras ultricies sed lorem non faucibus.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003ePraesent\u003c/th\u003e\n\u003cth\u003enec\u003c/th\u003e\n\u003cth\u003emetus\u003c/th\u003e\n\u003cth\u003ealiquet\u003c/th\u003e\n\u003cth\u003eDuis\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eaccumsan\u003c/td\u003e\n\u003ctd\u003erisus\u003c/td\u003e\n\u003ctd\u003equis\u003c/td\u003e\n\u003ctd\u003esodales\u003c/td\u003e\n\u003ctd\u003edignissim\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003epurus\u003c/td\u003e\n\u003ctd\u003eClass\u003c/td\u003e\n\u003ctd\u003eaptent\u003c/td\u003e\n\u003ctd\u003etaciti\u003c/td\u003e\n\u003ctd\u003epulvinar\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003esociosqu\u003c/td\u003e\n\u003ctd\u003ead\u003c/td\u003e\n\u003ctd\u003elitora\u003c/td\u003e\n\u003ctd\u003etorquent\u003c/td\u003e\n\u003ctd\u003eelit\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eper\u003c/td\u003e\n\u003ctd\u003econubia\u003c/td\u003e\n\u003ctd\u003enostra\u003c/td\u003e\n\u003ctd\u003eper\u003c/td\u003e\n\u003ctd\u003ein\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2 id=\"nulla-pharetra\"\u003eNulla pharetra\u003c/h2\u003e\n\u003cp\u003electus quis sapien tempor venenatis. Maecenas bibendum aliquam diam, sit amet semper massa sagittis a. Ut cursus fermentum erat, ac molestie orci. Fusce id enim bibendum, sollicitudin lacus nec, facilisis magna. Etiam volutpat maximus lorem condimentum varius. Cras suscipit pellentesque odio, quis vestibulum quam tristique eu. Pellentesque vulputate, neque sed ultrices blandit, urna velit facilisis mi, in dignissim tortor neque ac velit. Praesent laoreet facilisis augue, quis fringilla velit. Cras vel maximus quam, nec tempor lacus. Sed non dictum lectus. Nunc interdum nisl ante, nec condimentum turpis elementum non. Cras euismod massa nec nisi ultricies faucibus. Aliquam erat volutpat.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world!\u0026#x27;\u003c/span\u003e)\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"donec-quis-ullamcorper-nisi\"\u003eDonec quis ullamcorper nisi\u003c/h3\u003e\n\u003cp\u003eMauris scelerisque finibus dui, eu ultricies lorem ultricies vitae. Vivamus ante ante, vestibulum ac venenatis eget, iaculis nec enim. Sed laoreet augue blandit rutrum finibus. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam scelerisque, sapien non mollis tempus, diam metus congue metus, eget elementum lorem nisi non ex. Fusce interdum tortor ligula. Quisque sed iaculis dui, sed aliquet ante. Donec commodo non purus a tristique. In non mi augue. Sed sollicitudin odio neque, et tincidunt lectus pulvinar et. Curabitur lorem dolor, malesuada eu efficitur ut, pulvinar eu nunc. \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ePhasellus elementum sem in mauris tincidunt iaculis.\u003c/li\u003e\n\u003cli\u003eDonec pellentesque purus non est congue malesuada.\u003c/li\u003e\n\u003cli\u003eFusce pretium elit sed facilisis commodo.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"phasellus\"\u003ePhasellus\u003c/h4\u003e\n\u003cp\u003emolestie risus vitae lorem consequat, sed suscipit neque posuere. In fringilla tincidunt ante. Interdum et malesuada fames ac ante ipsum primis in faucibus. In maximus at odio eget tempus. Integer finibus neque massa, sit amet gravida est hendrerit quis. Vivamus ac orci mollis, porta magna non, viverra massa. Ut varius ex metus, sit amet mollis tortor lobortis id. Aliquam gravida blandit turpis, a egestas enim volutpat ut. \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInteger non tortor sit amet risus tempor sagittis \u003ccode\u003eeu id\u003c/code\u003e nisi.\u003c/li\u003e\n\u003cli\u003eNunc in purus sollicitudin, venenatis lacus at, tincidunt diam.\u003cul\u003e\n\u003cli\u003eSuspendisse eu magna pretium libero varius sodales nec id nulla.\u003c/li\u003e\n\u003cli\u003eIn in velit rhoncus, commodo dolor non, porttitor risus.\u003c/li\u003e\n\u003cli\u003eCurabitur nec risus malesuada, tincidunt turpis non, pharetra odio.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"sed-et-auctor-ex\"\u003eSed et auctor ex\u003c/h5\u003e\n\u003cp\u003eNullam ut finibus nunc. Proin elementum nisl eu dui hendrerit, vel varius neque egestas. Nunc elit neque, mattis vel lectus ut, commodo eleifend massa. Ut et lorem vestibulum, sodales erat pharetra, viverra mauris. Praesent fermentum pharetra odio in aliquet. Pellentesque nibh turpis, iaculis porttitor finibus a, vestibulum ac nisl. Aliquam vitae fringilla enim. Pellentesque elementum mi sem, at lobortis nisl euismod non. Fusce id fermentum diam. Mauris egestas pellentesque elit. Ut interdum massa eu nisl finibus, quis mollis tortor mattis. In aliquet congue augue, vitae fringilla libero vestibulum sit amet. Suspendisse id ante tincidunt, sollicitudin tellus a, tristique odio. Praesent vel pellentesque sapien, quis aliquet lectus. \u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMauris erat neque, feugiat sit amet felis a, sagittis feugiat turpis. Curabitur quis urna nec risus iaculis tincidunt. Quisque elit nibh, sodales vitae ante a, luctus efficitur est. Sed diam dolor, malesuada id aliquam eget, pellentesque id mauris. Aliquam quis diam ut velit euismod viverra. Pellentesque risus orci, sodales vel velit ac, vestibulum rhoncus magna. Morbi laoreet arcu et lectus tristique, sit amet posuere augue semper. Nunc suscipit, diam non semper rutrum, tellus orci fermentum tortor, in luctus metus eros vitae augue. \nFusce aliquam sit amet ligula ut auctor. Cras dictum magna ac volutpat consectetur. Donec ornare nulla ac mi auctor, varius posuere leo malesuada. Integer faucibus nisi at velit ultricies auctor quis in urna. Donec accumsan porttitor tortor, eget semper ex. Cras at volutpat nisi, in vulputate augue. Nam ultrices tincidunt sapien vitae finibus. Etiam urna sem, vestibulum sit amet erat quis, accumsan condimentum turpis. \u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eCras ac orci ac ligula feugiat condimentum eu quis mi. Nullam libero dolor, venenatis sed diam non, cursus aliquam massa. Integer vel neque eget est imperdiet molestie ut a risus. Ut a arcu est. Mauris non odio nunc. Fusce id augue dolor. Curabitur eget magna risus. \u003c/p\u003e\n\u003ch6 id=\"mauris-iaculis\"\u003eMauris iaculis,\u003c/h6\u003e\n\u003cp\u003equam vitae mollis convallis, mi urna pharetra dolor, hendrerit varius dui lacus ac elit. Donec maximus lacus id ullamcorper posuere. Nullam tincidunt venenatis eleifend. Integer consequat hendrerit metus non condimentum. Sed id nibh quam. Curabitur fermentum lacus ut velit maximus, sed aliquet dui elementum. Quisque ac maximus risus. Etiam fringilla ipsum leo, ut finibus justo venenatis id. Nulla id dapibus purus. Nullam rhoncus leo et enim gravida eleifend. Suspendisse arcu ipsum, venenatis sed luctus at, aliquet at turpis. Ut et ipsum a nunc ornare eleifend eu eu elit. Fusce fermentum mi sed ante placerat, sed placerat massa placerat. Vestibulum vulputate, felis eu gravida ultricies, ante metus tincidunt orci, eget volutpat erat purus id arcu. Integer vehicula ultricies varius. Donec lacinia ultricies nibh sit amet varius. \n\u003cimg src=\"/img/cloud.jpg\" alt=\"Cloud\"\u003e\u003c/p\u003e\n\u003ch2 id=\"aequare-vertar-victoria-suos-iugum-tu-nec\"\u003eAequare vertar Victoria suos iugum tu nec\u003c/h2\u003e\n\u003cp\u003eLorem markdownum attonitum quid. Sed diluvio, distulit facietque nabat\nmedicamine prohibebere dubitat dant viribus Neptunus audieris?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif (rawBiosDual) {\n    java += realCmykStorage;\n    payload_dynamic_markup = rosetta;\n    linux *= home - lte_flash_flops(animated_lcd_cycle, degaussPeopleware,\n            tftp_mode_mode);\n}\nif (character) {\n    cardData = spamCad;\n    reader.transfer_optical_program = 213527;\n    token_nntp += dropUddiPerl.hit(editor.hostBoot(leopardUnmountBcc, disk),\n            4, 781471);\n}\ndigital_pci_install += pharmingClipboardMemory;\nfile_cable.flops_wep(encodingIsaUps, 3, topologyVersion);\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"illi-exitium-sumere-succedit\"\u003eIlli exitium sumere succedit\u003c/h2\u003e\n\u003cp\u003eCederet dixit antrum conpulit Cleonae, hodierna arduus longa casa marisque.\nTalia custos fidem costis, enim, sic modo novercae \u003cstrong\u003ereperire positamque\u003c/strong\u003e agmen\nprotinus! Aevumque ipsum caelitibus sors quinque amor; nec se mea solita credere\nlumina leto corpore. Conorque subito, ducere prius aedificat deduxit inbellibus\nsolet habet superest genu recepta?\u003c/p\u003e\n\u003cp\u003eA triste corpore fontis marmore, reliquit et duobus: sub caput deserere vepre.\nNostra fiat fugiens in latet texitur heros vidi conubia! Ubi utile carissima\nvindicet gente plaustri illic, tyranno sit exercet tamen iamque.\u003c/p\u003e\n\u003ch2 id=\"superos-si-securus-delicta-exemplumque-tamen-inridet\"\u003eSuperos si securus delicta exemplumque tamen inridet\u003c/h2\u003e\n\u003cp\u003eMagni caede ad Euagrus dum quod, senioribus, alimenta. Potui et vero divae\nimagine moenia eventusque quondam volumine vires tamen. Nubigenasque sibi:\nnumina nostroque lanugine \u003ca href=\"http://comitum.io/leonis-et\"\u003emetuens repono\nnotissima\u003c/a\u003e a precari possumus \u003cem\u003eeripiat\u003c/em\u003e meae, sed?\nAliena et oreris, die faciunt erat mortales manusque colorem cuspide omnia et.\nGradive nec templo sati: quarum dedimus \u003cstrong\u003esaevarum versi novissima\u003c/strong\u003e quoque et\niuvenaliter confundimur placidissime longa \u003cem\u003ecantusque\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"ferox-nec-sono-resistite-capax-incubuit-et\"\u003eFerox nec sono resistite capax incubuit et\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eRepulsa praedivite\u003c/em\u003e urbemque tuae: moenibus animorum navita cum, ingreditur\nmutabile. Iactatam novat ignoscite puppim. Bene animi diva \u003cem\u003egeminato\u003c/em\u003e. Amissa\nconscendunt dubitabat, paro hunc sensit, obstipuit Xanthique quoque guttis, nec\ncapillos!\u003c/p\u003e\n\u003cp\u003eAdiacet hoc opem tepido fecerat hi videri oculis latrantibus meum: velatus\nrestabat. Uno caedit succurritis procul: quae viribus nomina ab funeribus forma;\nvulnera populos. Umerique accipe; arvo cuius tulit rapiunt haec; sensit tincta\nmarisque.\u003c/p\u003e\n"},"nextPost":{"name":"first_use_of_firebase","metadata":{"title":"Firebase 처음 써본 이야기","subtitle":"데이터베이스 스카마 설계하기 귀찮을 때","author":"LiteHell","date":"2021-02-28T22:40:29+09:00","category":"Dev","tags":["Firebase","React"]},"rendered":"\u003ch1 id=\"발단\"\u003e발단\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"/post/oauth2_and_oidc\"\u003e전 글\u003c/a\u003e에서 동아리 인증 시스템을 만들 때, 동아리 소개 홈페이지도 같이 만들었다. 동아리 홈페이지를 만들어두면 나중에 홍보할 때 써먹을 수 있겠다는 판단이 들어서였다. 그래서 그때 당시(2020년 초)에 \u003ca href=\"https://pages.github.com/\"\u003eGitHub Pages\u003c/a\u003e와 \u003ca href=\"https://startbootstrap.com/theme/creative\"\u003eCreative 템플릿\u003c/a\u003e을 이용해 간단히 제작했다.\u003c/p\u003e\n\u003cp\u003e그 다음 연도(2021년 초)에 회장이 바뀌고 회장 전화번호를 수정하면서 \u003ca href=\"https://getbootstrap.com\"\u003eBootstrap\u003c/a\u003e 의존성을 걷어내고 순수 CSS와 HTML, JS(+jQuery)로만 재작성했다. 그 때 당시에는 1페이지의 홈페이지로, 간단한 동아리 소개와 회장단 연락처, 동아리 가입신청 링크만 있었다.\u003c/p\u003e\n\u003cp\u003e이때 당시에는, 홈페이지 수정이 1년에 한 두번만 있을 것이라고 생각했었다. 그래서 그냥 간단하게 GitHub Pages를 이용해서 게시했다. 어처피 내가 곧 군대를 가게 될지라도 수정해주고 가면 될 것이라 판단도 있었다.\u003c/p\u003e\n\u003ch1 id=\"수정-가능한-형태\"\u003e수정 가능한 형태\u003c/h1\u003e\n\u003cp\u003e그러나 새 회장은 홈페이지를 보다 더 적극적으로 이용하고자 했다. 그래서 내게 홈페이지를 자신이 수정 가능하게 해달라는 부탁을 했고, 나는 공부도 해볼 겸 나쁘지 않겠다 싶어서 그 요청을 수락했다.\u003c/p\u003e\n\u003ch2 id=\"웹사이트-디자인\"\u003e웹사이트 디자인\u003c/h2\u003e\n\u003cp\u003e먼저 웹 사이트를 수정 가능한 형태로 하려면 웹 사이트 디자인을 먼저 생각해야 한다. 앞서 말한 2020년 초 디자인이 간단한 카드형태였는데, 그때의 디자인을 살리면 괜찮겠다고 생각했다. 그래서 웹 사이트를 \u0026quot;제목, 내용\u0026quot; 이 두가지로 이루어진 \u0026quot;카드\u0026quot;들의 집합으로 정의하고 디자인했다.\u003c/p\u003e\n\u003cp\u003e결과는 꽤 그럴싸하게 나왔다. 간단한 CSS 애니메이션을 주니 보기 좋더라. 나는 디자인 지식이 전무한 공학도이기 때문에 근사한 디자인보다는 그럴싸한 디자인이 최선이었다.\u003c/p\u003e\n\u003ch2 id=\"rdb를-써볼까\"\u003eRDB를 써볼까?\u003c/h2\u003e\n\u003cp\u003e처음에는 \u003ca href=\"https://www.mariadb.org\"\u003eMariaDB\u003c/a\u003e같은 관계형 데이터베이스를 이용하려 했다. 근데 MariaDB를 이용하려면 먼저 데이터베이스 스카마를 설계해야 하는 데 이게 너무 귀찮았다.\n그래서 \u003ca href=\"https://www.mongodb.com/\"\u003eMongoDB\u003c/a\u003e를 써볼까란 생각도 했었는데 MongoDB를 서버에 설치하는 것도 귀찮았다. 그래서 \u0026#39;어떻게 할까...\u0026#39; 생각하고 있었는데 마침 교내 학술동아리 발표에서 \u003ca href=\"https://firebase.google.com\"\u003eFirebase\u003c/a\u003e에 관해 말하더라. 생각해보니 Firebase를 써보는 것도 나쁘지 않겠다는 생각이 들었다.\u003c/p\u003e\n\u003ch1 id=\"firebase를-써보았다\"\u003eFirebase를 써보았다.\u003c/h1\u003e\n\u003cp\u003e그래서 Firebase를 썼다. Firebase는 Google에서 출시한 데이터베이스/스토리지/호스팅 등을 한 데 몪아놓은 서비스로, 번잡한 서버구성 없이 바로 사용할 수 있다는 것이 특징이다.\nFirebase의 데이터베이스는 두 가지 종류가 있다. 가장 먼저 나온 것이 실시간 데이터베이스이고, 그 다음에 나온 것이 Cloud Firestore이다. 실시간 데이터베이스는 데이터를 \u003cstrong\u003e하나의 JSON 트리\u003c/strong\u003e로 보고, Cloud Firestore를 데이터를 \u003cstrong\u003e여러개의 JSON 문서들의 집합\u003c/strong\u003e(MongoDB를 떠올리면 이해가 쉽다)로 본다.\n어처피 동아리 소개 홈페이지는 하나의 페이지로 이루어져 있기에, 하나의 페이지를 만드는데 필요한 데이터는 하나일 것이라고 생각했다. 따라서 실시간 데이터베이스를 채택했다.\u003c/p\u003e\n\u003ch2 id=\"thounghts-in-react\"\u003eThounghts in React\u003c/h2\u003e\n\u003cp\u003e이번 동아리 소개 홈페이지를 만들 때는 \u003ca href=\"https://reactjs.org\"\u003eReact.js\u003c/a\u003e를 채택했다. \u003ca href=\"/post/oauth2_and_oidc\"\u003e저번\u003c/a\u003e에는 Vue를 썼으니 이번에는 React를 써보자는 것이 그 이유였다.\n이번 홈페이지를 만드는 데 있어 복잡도가 그리 높지 않았기에, Redux와 같은 스토어를 이용하지 않았다. 따라서 데이터가 아래로 내려갔다가 위로 다시 올라오는 방식으로 모든 코드를 작성했다.\u003c/p\u003e\n\u003cp\u003e본 홈페이지에서 필요한 페이지들은 다음과 같다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/\u003c/code\u003e : 메인 페이지\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/edit\u003c/code\u003e : 편집 페이지\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/edit/preview\u003c/code\u003e : 편집할 때 미리보는 페이지\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e메인 페이지와 미리보기 페이지는 데이터를 편집할 필요가 없기 때문에 단방향의 데이터 흐름만 구현하면 된다. 따라서 해당 페이지들은 Firebase 데이터베이스에서 데이터를 받아 하위 컴포넌트에 전달하는 방식으로 이루어져 있다. 다만 약간의 차이점이 있다면 메인 페이지는 데이터를 한 번만 받고 (\u003ccode\u003eonce\u003c/code\u003e 메소드) 미리보기 페이지는 데이터가 바뀌면 다시 받는다는 점 (\u003ccode\u003eon\u003c/code\u003e 메소드)이 있다.\u003c/p\u003e\n\u003cp\u003e그러나 편집 페이지는 데이터를 수정해야 하므로 양방향의 데이터 흐름이 필요하다. 따라서 데이터를 하위 컴포넌트에 전달해 표현하고, 수정이 발생하면 하위 컴포넌트에서 상위 컴포넌트로 계속 올라가다 종착지에서 데이터를 수정하는 \u003ca href=\"https://ko.reactjs.org/docs/thinking-in-react.html\"\u003eReact스러운 사고방식\u003c/a\u003e으로 작성했다.\u003c/p\u003e\n\u003cp\u003e하위 컴포넌트에서 텍스트 입력 등 변경사항이 발생해 상위 컴포넌트로 올라갈 때 새로운 변경사항이 반영된 데이터를 같이 전달한다. 모든 하위 컴포넌트들은 자신이 담당하는 데이터만을 가지므로 이는 \u0026quot;웹사이트 전체 데이터\u0026quot;의 일부이다. 이 데이터를 전달받은 상위 컴포넌트는 이 전달받은 데이터를 자신이 관리하는 데이터(prop의 값)에 병합한 데이터를 자신의 상위 컴포넌트로 올려보낸다. 이 상위 컴포넌트들은 하위 컴포넌트보다 더 많은 데이터를 관리하므로, 데이터의 규모는 점점 커지게 된다. 따라서 이를 계속 반복하다 보면, 새로운 변경사항이 반영된 \u0026quot;웹사이트 전체의 데이터\u0026quot;를 받게 된다. 이 \u0026quot;웹사이트 전체의 데이터\u0026quot;를 Firebase 실시간 데이터베이스에 저장하게 함으로써 편집 기능을 구현했다.\u003c/p\u003e\n\u003cp\u003e데이터베이스에 저장한 이후의 데이터를 표현하는 방식에 관해서는, 데이터베이스에 값이 저장되는 순간 Firebase에서 value 이벤트를 발생시키고, 이에 연결된 이벤트 리스너가 페이지의 prop를 수정하게 된다. 따라서 페이지의 prop이 수정됨에 따라 하위 컴포넌트들의 prop도 같이 수정되게 되므로 별도의 특별한 코드가 필요하지 않았다.\u003c/p\u003e\n\u003ch2 id=\"파일-핸들링\"\u003e파일 핸들링\u003c/h2\u003e\n\u003cp\u003eFirebase는 파일 저장을 위한 Storage 기능도 지원한다. Storage에 저장할 때 mime-type만 지정하면 이미지 표시에는 딱히 큰 지장이 없으므로 파일 이름을 \u003ca href=\"https://github.com/ericelliott/cuid\"\u003ecuid\u003c/a\u003e 라이브러리를 이용해 난수로 저장하게 했다. 다만 그러면 편집 페이지에서 볼 때 불편한 점이 있으므로 커스텀 메타데이터로 본래 파일이름도 같이 저장하게 했다.\u003c/p\u003e\n\u003ch2 id=\"firebase와-인증-통합\"\u003eFirebase와 인증 통합\u003c/h2\u003e\n\u003cp\u003eFirebase에서 OpenID Connect를 지원했기에, 기존 동아리의 인증 시스템과 Firebase를 통합하는 것은 그리 어렵지 않았다. 다만 의외의 복병은 Firebase가 Id Token Authorization Grant만을 지원한다는 점이였다. 따라서 Authorization code grant만을 지원하던 인증 시스템을 수정하는 번거로움이 약간 있었다.\u003c/p\u003e\n\u003cp\u003eFirebase의 인증을 통합할때는 \u003ca href=\"https://cloud.google.com/identity-platform\"\u003eGoogle Identity Platform\u003c/a\u003e을 이용하면 된다. 데이터베이스나 스토리지의 보안 규칙을 작성할 때 \u003ccode\u003eauth.token.firebase.sign_in_attributes\u003c/code\u003e 속성으로 ID 토큰의 커스텀 속성에 접근할 수 있으므로 이를 이용해 기존 인증 시스템의 권한 관리도 통합할 수 있었다.\u003c/p\u003e\n\u003ch2 id=\"결론\"\u003e결론\u003c/h2\u003e\n\u003cp\u003eFirebase는 서비스를 빠르게 개발하는 데에 좋은 것 같다.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"oauth2_and_oidc"},"buildId":"C4IygSzdus1WQT9k-jkf-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>