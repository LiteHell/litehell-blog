<!DOCTYPE html><html lang="ko-KR"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><link rel="canonical" href="https://blog.litehell.info/post/bidrum_on_rust"/><link rel="alternate" type="application/rss+xml" title="RSS 2.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/rss"/><link rel="alternate" type=" application/atom+xml" title="Atom 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/atom"/><link rel="alternate" type="application/feed+json" title="Json 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/json"/><meta property="og:title" content="Rust와 SDL2"/><meta property="og:description" content="게임 개발에 Rust를 써보셨나요?"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="article"/><meta property="og:site_name" content="LiteHell의 블로그"/><meta property="og:url" content="https://blog.litehell.info/post/bidrum_on_rust"/><meta property="og:image" content="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><title>LiteHell의 블로그 - <!-- -->Rust와 SDL2</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/vs2015.min.css"/><meta name="next-head-count" content="16"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CZL0E8YDPW"></script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5916984077364289" crossorigin="anonymous"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-CZL0E8YDPW', { page_path: window.location.pathname });
            </script><link rel="preload" href="/_next/static/css/27d177a30947857b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27d177a30947857b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/088d29430e0ecbdb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/088d29430e0ecbdb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-ad45764ecfcae9e5.js" defer=""></script><script src="/_next/static/chunks/main-ee0cf4b7f81d7c24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a96cacb95f41a3ef.js" defer=""></script><script src="/_next/static/chunks/996-c5e5aa4c30f33066.js" defer=""></script><script src="/_next/static/chunks/503-25bfb158f613fce4.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-c55bde140ab34b85.js" defer=""></script><script src="/_next/static/ATEd0FxlIfOQZYNj1ewGd/_buildManifest.js" defer=""></script><script src="/_next/static/ATEd0FxlIfOQZYNj1ewGd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_body__O2_kC"><header class="Layout_header__M_IZ8"><div class="Layout_container__z4qWC"><h1><a href="/">LiteHell의 블로그</a></h1><div class="Layout_outLinks__XBNs_">외부고리 : <a href="https://litehell.info">Homepage</a><a href="https://github.com/LiteHell">GitHub</a><a href="https://linkedin.com/in/LiteHell">LinkedIn</a><a href="https://keybase.io/LiteHell">Keybase</a><a href="mailto:litehell@litehell.info">Email</a></div><div class="Layout_inLinks__f7gmD">내부고리 : <a href="/category">카테고리</a><a href="/tag">태그</a></div></div></header><main class="Layout_mainContainer__5WZfx"><div class="Layout_container__z4qWC"><div class="Blog_header__r4wcZ"><div class="Blog_title___OFu6"><h1>Rust와 SDL2</h1><h2>게임 개발에 Rust를 써보셨나요?</h2></div><p>8/11/2024, 2:35:24 PM<!-- -->에 <!-- -->LiteHell<!-- -->이(가) 작성<!-- -->함<br/><span>카테고리 : <a href="/category/Dev">Dev</a><br/></span><span>태그 : <span class="Blog_tag__RW5VK"><a href="/tag/Game">Game</a></span><br/></span></p></div><div class="Blog_seriesContainer__ii8Fj"><div class="Blog_seriesTitle__DCd_w">(시리즈) <!-- -->리듬게임 바이드럼 개발기</div><ul><li><a href="/post/bidrum_and_janggu_controller_prototyping">쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기</a></li><li class="Blog_now__E4xgg"><a href="/post/bidrum_on_rust">Rust와 SDL2</a></li></ul></div><section class="Blog_article__WZp3G"><h1 id="들어가는-글">들어가는 글</h1>
<p><em>※ 참고: 이 시리즈의 글은 시간순 작성을 최대한 목표하고 있으나, 글의 짜임새나 가독성을 위해 미리시점이나 과거시점의 이야기가 섞이거나 순서가 일부 달라질 수 있습니다.</em></p>
<p>내가 만들고 싶은 게임은 아케이드 리듬게임이였다. 마침 내 방에 라즈베리 파이(4B Rev 1.2)가 있어서, 라즈베리 파이로 게임을 구동하고 싶었다. Unity나 Unreal Engine으로 만든 게임이 라즈베리 파이 위에서 돌아갈까? 아마도 돌아가지 않을 것이다. 실제로 돌려본 적은 없지만 라즈베리 파이가 성능이 좋은 편은 아니니까.</p>
<p>그래서 필자는 마침 <a href="https://www.rust-lang.org/">Rust</a> 프로그래밍 언어를 한 번 써보고 싶은 생각도 있었기에, Rust로 직접 게임을 만들어보기로 결심했다. 게임 엔진을 쓰면 나중에 게임이 유명해졌을 때 라이선스비를 내야 한다는 것도 하나의 이유였다. (좀 과한 김칫국이긴 하지만...) 그래서 유니티니 언리얼이니 하는 게임 엔진을 쓰지 않고 Rust로 기초부터 쌓아올리기 시작했다.</p>
<h1 id="sdl2를-이용한-게임-프로그래밍">SDL2를 이용한 게임 프로그래밍</h1>
<p>Rust에는 <a href="https://github.com/Rust-SDL2/rust-sdl2">rust-sdl2</a>라는 라이브러리 바인딩이 있다. SDL2는 오디오, 키보드, 마우스, 그래픽, 조이스틱을 다를 수 있게 하는 크로스플랫폼 라이브러리이다. 즉, 그래픽이나 마우스 등에 대한 Direct3D/OpenGL 등의 운영체제/플랫폼 종속적인 API를 추상화하고 단일한 인터페이스로 통일하여 크로스 플랫폼으로 개발할 수 있게 하는 라이브러리이다.</p>
<p>따라서 SDL2를 이용하면 Mac OS X/Windows/Linux에서 크로스플랫폼으로 실행할 수 있고, 라이브러리도 별로 무겁지 않다. 그래서 SDL2를 이용하게 됐다.</p>
<h2 id="sdl2">SDL2</h2>
<p>SDL2는 rust-sdl 레포 내의 예제 코드를 보면서 따라하면 사용하기 쉽다. SDL2는 먼저 Window(창)을 만든 뒤, Window의 Canvas에 원하는 것을 그리고 렌더링하고 클리어하는 것을 반복한다. 이를 순서대로 나타내면 다음과 같다.</p>
<blockquote>
<p>(A) Window 생성 → (B) Window의 Canvas를 Clear한다 → (C) Canvas에 뭔가를 그린다. → (D) Window의 Canvas를 Present한다. → (E) 화면이 표시한다. → (F) B로 되돌아간다.</p>
</blockquote>
<p>학부 수준의 컴퓨터그래픽스 수업을 들었거나 OpenGL 프로그래밍을 조금이라도 맛보았다면 매우 이해하기 쉬울 것이다.</p>
<p>SDL2는 키보드나 조이스틱 인식을 위한 EventPump 기능을 제공한다. 키보드 인풋이 들어오면 EventPump에 Event가 생성된다. 게임은 이 EventPump에 Event가 있는지 확인하여 만약 Event가 있다면 해당 Event의 데이터를 활용해 키보드 인풋을 처리할 수 있다. 게임 특성상 이 EventPump은 디버깅 용으로만 주로 이용됐다.</p>
<h2 id="gamecommoncontext">GameCommonContext</h2>
<p>위에서 언급한 바에 같이 그래픽을 렌더링하기 위해서는 Canvas 객체에 대한 접근이 필요하다. 그래서 초기 게임 초기화시 Canvas와 Window, SDL Context 등을 담은 GameCommonContext 객체를 만들고 이를 함수간에 서로 주고받는 형태로 빠르게 게임을 구현했다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> kira::manager::AudioManager;
<span class="hljs-keyword">use</span> sdl2::{render::Canvas, EventPump, video::Window};

<span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GameCommonContext</span></span> {
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) coins: <span class="hljs-built_in">u32</span>,
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) price: <span class="hljs-built_in">u32</span>,
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) sdl_context: sdl2::Sdl,
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) audio_manager: AudioManager,
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) canvas: Canvas&lt;Window&gt;,
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) event_pump: EventPump,
}</code></pre>
<p>(속성은 나중에 게임이 개발되면 될 수록 더 늘어난다.)</p>
<p>그리고 이는 추후 대규모 리팩토링으로 Rust의 특징을 온몸으로 깨닫는 계기가 됐다.... 나중에 소유권이랑 lifetime 문제가 미친 듯이 터져나와서 그거 씨름하느라 엄청 고생하게 됐다.</p>
<h2 id="rust에서의-시리얼-통신">Rust에서의 시리얼 통신</h2>
<p>게임을 장구 하드웨어와 연동하기 위해서는 시리얼 통신이 필요하다.</p>
<p>Arduino Leonardo 등 HID 에뮬레이션을 지원하는 보드가 있으면 장구 하드웨어에서 키보드 인풋을 주도록 할 수도 있다. 그런데 당장 내 방에 있는 게 Arduino UNO 호환보드(흔히 &quot;짭두이노&quot;라고 불리는 보드)밖에 없었다. 그래서 시리얼 통신으로 구현했다. 나중의 미래에 레오나르도 보드를 사서 키보드 인풋으로도 구현해보긴 했는데.... 딱따구리마냥 장구 채를 갖다대기만 해도 장구 채를 미친듯이 연타한 것마냥 동작하는 버그가 있어서 그냥 시리얼 통신을 계속 쓰게 됐다.</p>
<p>Rust에서는 시리얼 통신을 어떻게 할까? 고맙게도 <a href="https://docs.rs/serialport/latest/serialport/">serialport</a>라는 라이브러리가 있다. 이를 이용해 장구 하드웨어와의 시리얼 통신 코드를 작성했다. 그리고 장구 하드웨어로부터 인풋을 읽는 코드를 멀티쓰레딩으로 분리하고 <code>AtomicU8</code>을 이용하여 게임 쓰레드와 인풋 쓰레드 간에 장구 인풋 상태를 서로 공유했다.</p>
<p>왜 뜬끔없이 <code>AtomicU8</code>이냐? 장구 컨트롤러의 상태를 나타내는 데에는 4개의 비트만 있으면 충분하다. 그래서 컨트롤러는 1바이트의 데이터를 무한히 연속적으로 보낸다. 이 1바이트를 해석하는 코드는 다음과 같다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse_janggu_bits</span></span>(bits: <span class="hljs-built_in">u8</span>) -&gt; JangguState {
    JangguState {
        궁채: <span class="hljs-keyword">if</span> bits &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span> {
            <span class="hljs-literal">Some</span>(DrumPane::채편)
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> bits &amp; <span class="hljs-number">2</span> != <span class="hljs-number">0</span> {
            <span class="hljs-literal">Some</span>(DrumPane::북편)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">None</span>
        },
        북채: <span class="hljs-keyword">if</span> bits &amp; <span class="hljs-number">4</span> != <span class="hljs-number">0</span> {
            <span class="hljs-literal">Some</span>(DrumPane::채편)
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> bits &amp; <span class="hljs-number">8</span> != <span class="hljs-number">0</span> {
            <span class="hljs-literal">Some</span>(DrumPane::북편)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">None</span>
        },
    }
}</code></pre>
<p>장구 컨트롤러와 연동하는 쓰레드는 컨트롤러로부터 시리얼 통신으로 받은 데이터를 바로 <code>GameCommonContext</code> 개체의 <code>janggu_bits_ptr</code> 필드에 저장한다.</p>
<pre><code class="hljs language-rust"><span class="hljs-comment">// ... (생략) ....</span>

<span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GameCommonContext</span></span> {
   <span class="hljs-comment">// ... (생략) ...</span>
   <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) janggu_bits_ptr: Arc&lt;AtomicU8&gt;,
}

<span class="hljs-keyword">impl</span> GameCommonContext {
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_janggu_state</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; JangguState {
        <span class="hljs-keyword">return</span> parse_janggu_bits(
            <span class="hljs-keyword">self</span>.janggu_bits_ptr
                .load(std::sync::atomic::Ordering::Relaxed),
        );
    }
}
</code></pre>
<p>게임 쓰레드에서 장구의 상태를 확인할 때는 <code>read_janggu_state</code> 메소드를 이용한다.</p>
<p>추후 미래에 <code>AtomicU8</code>을 없애고 Product-Consumer Lock으로 <code>JangguState</code> 객체를 직접 공유해보기도 했는데, 렉이 너무 심해서 그냥 <code>AtomicU8</code>을 계속 쓰게 됐다.</p>
<h1 id="결론">결론</h1>
<p>Rust를 이용한 게임 개발은 초창기에는 할만했는데 뒤로 갈수록 어려웠다. 소유권, 대여, lifetime 문제를 해결하느라 골머리를 참 많이 썩었다. 그래서 결론적으로 짧은 기간 안에 게임을 개발해야 한다면 Rust는 별로 좋은 선택이 아니지 않을까라는 생각이 들었다.</p>
</section><div class="Comments_blogComments__GRWmY"></div><nav class="Blog_postNav__ivy8_ Blog_hasBoth__3MRPr"><div class="Blog_leftAnchor__HhzIP"><a href="/post/bidrum_and_janggu_controller_prototyping"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기</div><div class="Blog_subtitle__RRFh7">학교 캡스톤디자인 작품으로 장구 리듬게임 만든 이야기</div></div></a></div><div class="Blog_rightAnchor__B9n7B"><a href="/post/caucalendar_1"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">학사일정 ICS 서비스 개발기 (上)</div><div class="Blog_subtitle__RRFh7">Javascript랑 함께 Docker로</div></div></a></div></nav></div></main><footer class="Layout_footer__bKkxe"><div class="Layout_container__z4qWC"><a href="https://www.gnu.org/licenses/agpl-3.0.en.html"><img alt="GNU Affero General License Version 3" src="https://www.gnu.org/graphics/agplv3-with-text-100x42.png" style="height:31px"/></a> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a><br/>Copyrights (C) 2020 ~ 2024 LiteHell, All rights reserved.<br/><div class="Layout_visibleOnPrintOnly__UK6Yl">LiteHell&#x27;s Blog - <a href="https://blog.litehell.info">https://blog.litehell.info</a><br/>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.<br/><br/>Url of this article: <a href="https://blog.litehell.info/post/bidrum_on_rust">https://blog.litehell.info/post/bidrum_on_rust</a><br/></div><div class="Layout_invisibleOnPrint__rdrDv">Fox Image : Copyrights (C) 2004 Shiretoko-Shari Torurist Association<br/><a href="/license">This blog is free software; For source code and more informations on license and copyrights, Click here.</a><br/><br/>Feeds : <a href="/feed/rss">RSS 2.0</a>,<!-- --> <a href="/feed/atom">Atom 1.0</a>, <a href="/feed/json">Json 1.0</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"metadata":{"title":"Rust와 SDL2","subtitle":"게임 개발에 Rust를 써보셨나요?","author":"LiteHell","date":"2024-08-11T14:35:24.968Z","category":"Dev","series":"bidrum","tags":["Game"]},"rendered":"\u003ch1 id=\"들어가는-글\"\u003e들어가는 글\u003c/h1\u003e\n\u003cp\u003e\u003cem\u003e※ 참고: 이 시리즈의 글은 시간순 작성을 최대한 목표하고 있으나, 글의 짜임새나 가독성을 위해 미리시점이나 과거시점의 이야기가 섞이거나 순서가 일부 달라질 수 있습니다.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e내가 만들고 싶은 게임은 아케이드 리듬게임이였다. 마침 내 방에 라즈베리 파이(4B Rev 1.2)가 있어서, 라즈베리 파이로 게임을 구동하고 싶었다. Unity나 Unreal Engine으로 만든 게임이 라즈베리 파이 위에서 돌아갈까? 아마도 돌아가지 않을 것이다. 실제로 돌려본 적은 없지만 라즈베리 파이가 성능이 좋은 편은 아니니까.\u003c/p\u003e\n\u003cp\u003e그래서 필자는 마침 \u003ca href=\"https://www.rust-lang.org/\"\u003eRust\u003c/a\u003e 프로그래밍 언어를 한 번 써보고 싶은 생각도 있었기에, Rust로 직접 게임을 만들어보기로 결심했다. 게임 엔진을 쓰면 나중에 게임이 유명해졌을 때 라이선스비를 내야 한다는 것도 하나의 이유였다. (좀 과한 김칫국이긴 하지만...) 그래서 유니티니 언리얼이니 하는 게임 엔진을 쓰지 않고 Rust로 기초부터 쌓아올리기 시작했다.\u003c/p\u003e\n\u003ch1 id=\"sdl2를-이용한-게임-프로그래밍\"\u003eSDL2를 이용한 게임 프로그래밍\u003c/h1\u003e\n\u003cp\u003eRust에는 \u003ca href=\"https://github.com/Rust-SDL2/rust-sdl2\"\u003erust-sdl2\u003c/a\u003e라는 라이브러리 바인딩이 있다. SDL2는 오디오, 키보드, 마우스, 그래픽, 조이스틱을 다를 수 있게 하는 크로스플랫폼 라이브러리이다. 즉, 그래픽이나 마우스 등에 대한 Direct3D/OpenGL 등의 운영체제/플랫폼 종속적인 API를 추상화하고 단일한 인터페이스로 통일하여 크로스 플랫폼으로 개발할 수 있게 하는 라이브러리이다.\u003c/p\u003e\n\u003cp\u003e따라서 SDL2를 이용하면 Mac OS X/Windows/Linux에서 크로스플랫폼으로 실행할 수 있고, 라이브러리도 별로 무겁지 않다. 그래서 SDL2를 이용하게 됐다.\u003c/p\u003e\n\u003ch2 id=\"sdl2\"\u003eSDL2\u003c/h2\u003e\n\u003cp\u003eSDL2는 rust-sdl 레포 내의 예제 코드를 보면서 따라하면 사용하기 쉽다. SDL2는 먼저 Window(창)을 만든 뒤, Window의 Canvas에 원하는 것을 그리고 렌더링하고 클리어하는 것을 반복한다. 이를 순서대로 나타내면 다음과 같다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e(A) Window 생성 → (B) Window의 Canvas를 Clear한다 → (C) Canvas에 뭔가를 그린다. → (D) Window의 Canvas를 Present한다. → (E) 화면이 표시한다. → (F) B로 되돌아간다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e학부 수준의 컴퓨터그래픽스 수업을 들었거나 OpenGL 프로그래밍을 조금이라도 맛보았다면 매우 이해하기 쉬울 것이다.\u003c/p\u003e\n\u003cp\u003eSDL2는 키보드나 조이스틱 인식을 위한 EventPump 기능을 제공한다. 키보드 인풋이 들어오면 EventPump에 Event가 생성된다. 게임은 이 EventPump에 Event가 있는지 확인하여 만약 Event가 있다면 해당 Event의 데이터를 활용해 키보드 인풋을 처리할 수 있다. 게임 특성상 이 EventPump은 디버깅 용으로만 주로 이용됐다.\u003c/p\u003e\n\u003ch2 id=\"gamecommoncontext\"\u003eGameCommonContext\u003c/h2\u003e\n\u003cp\u003e위에서 언급한 바에 같이 그래픽을 렌더링하기 위해서는 Canvas 객체에 대한 접근이 필요하다. 그래서 초기 게임 초기화시 Canvas와 Window, SDL Context 등을 담은 GameCommonContext 객체를 만들고 이를 함수간에 서로 주고받는 형태로 빠르게 게임을 구현했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e kira::manager::AudioManager;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e sdl2::{render::Canvas, EventPump, video::Window};\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eGameCommonContext\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) coins: \u003cspan class=\"hljs-built_in\"\u003eu32\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) price: \u003cspan class=\"hljs-built_in\"\u003eu32\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) sdl_context: sdl2::Sdl,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) audio_manager: AudioManager,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) canvas: Canvas\u0026lt;Window\u0026gt;,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) event_pump: EventPump,\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(속성은 나중에 게임이 개발되면 될 수록 더 늘어난다.)\u003c/p\u003e\n\u003cp\u003e그리고 이는 추후 대규모 리팩토링으로 Rust의 특징을 온몸으로 깨닫는 계기가 됐다.... 나중에 소유권이랑 lifetime 문제가 미친 듯이 터져나와서 그거 씨름하느라 엄청 고생하게 됐다.\u003c/p\u003e\n\u003ch2 id=\"rust에서의-시리얼-통신\"\u003eRust에서의 시리얼 통신\u003c/h2\u003e\n\u003cp\u003e게임을 장구 하드웨어와 연동하기 위해서는 시리얼 통신이 필요하다.\u003c/p\u003e\n\u003cp\u003eArduino Leonardo 등 HID 에뮬레이션을 지원하는 보드가 있으면 장구 하드웨어에서 키보드 인풋을 주도록 할 수도 있다. 그런데 당장 내 방에 있는 게 Arduino UNO 호환보드(흔히 \u0026quot;짭두이노\u0026quot;라고 불리는 보드)밖에 없었다. 그래서 시리얼 통신으로 구현했다. 나중의 미래에 레오나르도 보드를 사서 키보드 인풋으로도 구현해보긴 했는데.... 딱따구리마냥 장구 채를 갖다대기만 해도 장구 채를 미친듯이 연타한 것마냥 동작하는 버그가 있어서 그냥 시리얼 통신을 계속 쓰게 됐다.\u003c/p\u003e\n\u003cp\u003eRust에서는 시리얼 통신을 어떻게 할까? 고맙게도 \u003ca href=\"https://docs.rs/serialport/latest/serialport/\"\u003eserialport\u003c/a\u003e라는 라이브러리가 있다. 이를 이용해 장구 하드웨어와의 시리얼 통신 코드를 작성했다. 그리고 장구 하드웨어로부터 인풋을 읽는 코드를 멀티쓰레딩으로 분리하고 \u003ccode\u003eAtomicU8\u003c/code\u003e을 이용하여 게임 쓰레드와 인풋 쓰레드 간에 장구 인풋 상태를 서로 공유했다.\u003c/p\u003e\n\u003cp\u003e왜 뜬끔없이 \u003ccode\u003eAtomicU8\u003c/code\u003e이냐? 장구 컨트롤러의 상태를 나타내는 데에는 4개의 비트만 있으면 충분하다. 그래서 컨트롤러는 1바이트의 데이터를 무한히 연속적으로 보낸다. 이 1바이트를 해석하는 코드는 다음과 같다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eparse_janggu_bits\u003c/span\u003e\u003c/span\u003e(bits: \u003cspan class=\"hljs-built_in\"\u003eu8\u003c/span\u003e) -\u0026gt; JangguState {\n    JangguState {\n        궁채: \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::채편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::북편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n        },\n        북채: \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::채편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::북편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n        },\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e장구 컨트롤러와 연동하는 쓰레드는 컨트롤러로부터 시리얼 통신으로 받은 데이터를 바로 \u003ccode\u003eGameCommonContext\u003c/code\u003e 개체의 \u003ccode\u003ejanggu_bits_ptr\u003c/code\u003e 필드에 저장한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ... (생략) ....\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eGameCommonContext\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-comment\"\u003e// ... (생략) ...\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) janggu_bits_ptr: Arc\u0026lt;AtomicU8\u0026gt;,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e GameCommonContext {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eread_janggu_state\u003c/span\u003e\u003c/span\u003e(\u0026amp;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) -\u0026gt; JangguState {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e parse_janggu_bits(\n            \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.janggu_bits_ptr\n                .load(std::sync::atomic::Ordering::Relaxed),\n        );\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e게임 쓰레드에서 장구의 상태를 확인할 때는 \u003ccode\u003eread_janggu_state\u003c/code\u003e 메소드를 이용한다.\u003c/p\u003e\n\u003cp\u003e추후 미래에 \u003ccode\u003eAtomicU8\u003c/code\u003e을 없애고 Product-Consumer Lock으로 \u003ccode\u003eJangguState\u003c/code\u003e 객체를 직접 공유해보기도 했는데, 렉이 너무 심해서 그냥 \u003ccode\u003eAtomicU8\u003c/code\u003e을 계속 쓰게 됐다.\u003c/p\u003e\n\u003ch1 id=\"결론\"\u003e결론\u003c/h1\u003e\n\u003cp\u003eRust를 이용한 게임 개발은 초창기에는 할만했는데 뒤로 갈수록 어려웠다. 소유권, 대여, lifetime 문제를 해결하느라 골머리를 참 많이 썩었다. 그래서 결론적으로 짧은 기간 안에 게임을 개발해야 한다면 Rust는 별로 좋은 선택이 아니지 않을까라는 생각이 들었다.\u003c/p\u003e\n"},"articleId":"bidrum_on_rust","series":[{"title":"쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기","articleId":"bidrum_and_janggu_controller_prototyping"},{"title":"Rust와 SDL2","articleId":"bidrum_on_rust"}],"seriesName":"리듬게임 바이드럼 개발기","previousPost":{"name":"bidrum_and_janggu_controller_prototyping","metadata":{"title":"쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기","subtitle":"학교 캡스톤디자인 작품으로 장구 리듬게임 만든 이야기","author":"LiteHell","date":"2024-07-19T12:53:12.021Z","series":"bidrum","seriesName":"리듬게임 바이드럼 개발기","category":"Dev","tags":["Game"]},"rendered":"\u003ch1 id=\"서문\"\u003e서문\u003c/h1\u003e\n\u003cp\u003e문득 장구를 이용한 리듬 게임을 만들고 싶었다. 태고의 달인도 있는데 장구의 달인이 안 될 이유가 있을까? 그래서 군대 있을 때 계속 장구 게임을 상상만 하다가 복학하고 3학년 2학기에 캡스톤디자인 과목을 듣게 됐다.\u003c/p\u003e\n\u003cp\u003e3학년 2학기 캡스톤디자인 과목에서 게임 아이디어를 제시했지만, 다른 팀원들은 리스크가 너무 크다고 반대했다. 지금 막 개강했는데 하드웨어 개발부터 시작하면 십중팔구 프로젝트가 망할 것이라는 지적이였다. 반박하기에는 너무나도 맞는 말이였다. 그래서 그냥 받아들이고 \u0026quot;알고모여\u0026quot;라는 웹 어플리케이션 프로젝트를 하게 됐다. 의외로 교수님의 평가가 계속 호평이여서 손쉽게 A+를 받았다.\u003c/p\u003e\n\u003cp\u003e중앙대학교는 캡스톤디자인을 2번 해야 졸업이 가능하다. 그래서 4학년 1학기에도 캡스톤디자인을 해야 했는데, 이때 게임 아이디어를 다시 꺼내고 싶었다. 그러나 하드웨어도 없이 빈손으로 아이디어를 꺼낸다면 또다시 팀원들로부터 리스크 우려를 받을 것 같았다. 그래서 일단 프로토타이핑을 해서 설득해야 되겠단 판단이 들었다. 판단이 이루어졌으면 바로 실천해야 하지 않겠는가? 바로 당근마켓으로 45,000원짜리 어린이 장구를 샀고, 곧이어 아두이노랑 쿠킹호일, 그리고 몇가지 부품을 구매했다.\u003c/p\u003e\n\u003ch1 id=\"프로토타이핑\"\u003e프로토타이핑\u003c/h1\u003e\n\u003ch2 id=\"유선과-무선\"\u003e유선과 무선\u003c/h2\u003e\n\u003cp\u003e내가 만드는 게임은 단순히 타격 여부만을 인식하지 않는다. \u0026quot;어떤 채로 어떤 면이 타격됐는가\u0026quot;를 인식한다. 즉, 다시 말해 열편으로 궁편을 친다면 \u0026quot;궁편이 타격됐다\u0026quot;라는 정보가 아닌 \u0026quot;열편으로 궁편이 타격됐다\u0026quot;라는 정보가 인식된다.\u003c/p\u003e\n\u003cp\u003e이를 구현하려면 채에도 센서가 있어야 된다. 그리고 이 센서는 게임 본체랑 연결되어야 한다. 어떻게 연결한 것인가? 무선과 유선 두가지 방법이 있다.\u003c/p\u003e\n\u003cp\u003e무선과 유선 각 두 가지 방법의 장단점은 다음과 같다.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003e무선\u003c/th\u003e\n\u003cth\u003e유선\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e장점\u003c/td\u003e\n\u003ctd\u003e선이 걸리지 않음\u003c/td\u003e\n\u003ctd\u003e정확도가 매우 높고 딜레이가 낮음\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e단점\u003c/td\u003e\n\u003ctd\u003e너무 낮은 정확도 및 높은 딜레이\u003c/td\u003e\n\u003ctd\u003e선이 걸리적거림\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e무선 통신은 정확도가 너무 낮다는 단점이 있다. 무선으로 채의 위치를 측정한다고 가정해보자. \u003ca href=\"https://www.inpixon.com/technology/standards/ultra-wideband\"\u003eInpixion\u003c/a\u003e의 자료에서의 무선 위치 측정 시스템의 정확도와 레어턴시는 다음과 같다.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003eUWB\u003c/th\u003e\n\u003cth\u003eChirp (CSS)\u003c/th\u003e\n\u003cth\u003eBLE\u003c/th\u003e\n\u003cth\u003eWi-Fi\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e정확도\u003c/td\u003e\n\u003ctd\u003e10~50 cm\u003c/td\u003e\n\u003ctd\u003e1~2m\u003c/td\u003e\n\u003ctd\u003e\u0026lt; 5 m\u003c/td\u003e\n\u003ctd\u003e10 m\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e레이턴시\u003c/td\u003e\n\u003ctd\u003e\u0026lt; 1 ms\u003c/td\u003e\n\u003ctd\u003e\u0026lt; 1 ms\u003c/td\u003e\n\u003ctd\u003e3~5s\u003c/td\u003e\n\u003ctd\u003e3~5s\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e정확도가 너무 낮아서 무선 위치 측정 시스템은 쓸 수가 없다. 블루투스와 와이파이는 레이턴시때문에 리듬게임 컨트롤러로 쓸 수조차 없다.\u003c/p\u003e\n\u003cp\u003e\u0026#39;그렇다면 무선이되 다른 방법을 쓰면 되는 것 아닌가?\u0026#39;라는 생각이 들 수도 있는데, 내 머리로는 그렇게 할 수 있는 방법이 딱히 떠오르지 않았다. 그래서 그냥 유선으로 연결하기로 하고, 걸리적거리는 문제는 나중에 해결하기로 했다.\u003c/p\u003e\n\u003ch2 id=\"시분할\"\u003e시분할\u003c/h2\u003e\n\u003cp\u003e자, 이제 유선으로 채의 종류를 인식하기로 했다. 장구는 두 개의 채와 두 개의 접촉면이 있다. 이 경우 가능한 경우의 수는 총 몇 가지인가? 답은 아래 표에서 볼 수 있듯 9가지이다. 두 개의 채로 하나의 접촉면을 동시에 치는 경우(아래 표에서 5번, 9번)도 고려해야 하므로 9가지이다.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003e궁채\u003c/th\u003e\n\u003cth\u003e북채\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e6\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e7\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e8\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e9\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e전기는 색깔이 없다. 접촉면에서 흐르는 전기가 궁채에서 흐르는 전기인지 북채에서 흐르는 전기인지 알 수 없다. 그렇다면 접촉면에 닿은 채가 어떤 채인지 어떻게 구분해야 할까? 필자는 FDM(주파수 분할)과 TDM(시분할)을 생각했다. 처음엔 FDM을 생각했었는데, 아두이노로 구현하기에는 난이도가 높을 것 같아 비교적 구현이 손쉬운 TDM으로 결정했다.\u003c/p\u003e\n\u003ch3 id=\"알고리즘\"\u003e알고리즘\u003c/h3\u003e\n\u003cp\u003e시분할 알고리즘은 매우 단순하다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e궁채에 전기를 흘리고 북채에 전기를 흘리지 않는다.\u003c/li\u003e\n\u003cli\u003e북면에 전기가 흐르는 지 확인한다. 북면에 전기가 흐르면 궁채는 북면에 접촉하고 있다.\u003c/li\u003e\n\u003cli\u003e궁면에 전기가 흐르는 지 확인한다. 궁면에 전기가 흐르면 궁채는 궁면에 접촉하고 있다.\u003c/li\u003e\n\u003cli\u003e북채에 전기를 흘리고 궁채에 전기를 흘리지 않는다.\u003c/li\u003e\n\u003cli\u003e북면에 전기가 흐르는 지 확인한다. 북면에 전기가 흐르면 북채는 북면에 접촉하고 있다.\u003c/li\u003e\n\u003cli\u003e궁면에 전기가 흐르는 지 확인한다. 궁면에 전기가 흐르면 북채는 궁면에 접촉하고 있다.\u003c/li\u003e\n\u003cli\u003e2, 3, 5, 6번에서의 정보를 종합하면 어떤 채가 어떤 접촉면에 접촉하고 있는 지 알 고 있다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이를 도식도로 나타내면 다음과 같다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/bidrum/controller-algorithm.png\" alt=\"알고리즘의 도식도\"\u003e\u003c/p\u003e\n\u003cp\u003e위를 실제 회로로 구현하기 위해서는 특정 회로를 신호로 열거나 닫을 수 있어야 한다.\u003c/p\u003e\n\u003ch3 id=\"릴레이\"\u003e릴레이\u003c/h3\u003e\n\u003cp\u003e특정 회로를 신호로 열거나 닫는 대표적인 부품은 릴레이이다. 릴레이는 일종의 스위치 역할을 하는 부품으로, 전자석을 이용하여 회로를 열거나 닫는다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/bidrum/relay.jpg\" alt=\"아두이노 릴레이 모듈 사진\"\u003e\u003c/p\u003e\n\u003cp\u003e매우 직관적이고 만들기 쉬워서 처음에 릴레이를 시도했었다. 그러나 문제가 있었다. 릴레이는 딜레이가 너무 크고(5ms) 결정적으로 딱따구리 같은 소음이 난다. 위 알고리즘을 빠르게 무한반복해야 하는 특성상 릴레이 열고닫기를 반복하니 전자석 딱딱거리는 소리가 무한히 들리는 것이었다.\u003c/p\u003e\n\u003ch3 id=\"트랜지스터\"\u003e트랜지스터\u003c/h3\u003e\n\u003cp\u003e그래서 주변 분들의 조언을 받아 트랜지스터를 이용했다. 주변 분께 딜레이가 1ms이하인 릴레이가 있나고 여쭤보니, 그 분께서 그런 릴레이는 없으니 트랜지스터를 쓰라고 답변해주신 것이 큰 도움이 됐다. 트랜지스터는 라디오 만들 때나(증폭) 쓰는 건 줄 알았는데 검색해보니 트랜지스터도 스위치처럼 쓸 수 있음을 알게 됐다.\u003c/p\u003e\n\u003cp\u003eNPN 트랜지스터와 저항으로 약간의 시행착오를 겪으니 잘 인식됐다. 트랜지스터를 이용한 회로는 아래와 같다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/bidrum/janggu_prototype_circuit_1.png\" alt=\"트랜지스터를 이용한 아두이노 컨트롤러 회로\"\u003e\u003c/p\u003e\n\u003cp\u003e위 회로에서 궁채, 열채, 북편, 채편 기호는 각각의 부위에 붙은 전도체를 의미한다.\u003c/p\u003e\n\u003ch2 id=\"전도체\"\u003e전도체\u003c/h2\u003e\n\u003cp\u003e전기가 흘려야 하니 채와 접촉면에는 전도체 물질을 부착해야 한다. 뭘 붙일까 고민하다가 \u003ca href=\"https://blog.naver.com/b4crazy1/221481730264\"\u003e펌프 발판을 수작업으로 제작할 때 은박지를 이용했다는 글\u003c/a\u003e이 생각났다. 그래서 다이소에서 쿠킹호일을 사다가 붙였다. 내구성은 썩 좋은 것 같진 않았지만 꽤 잘 인식됐다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/bidrum/janggu_prototype_1.jpg\" alt=\"장구 컨트롤러 프토토타입 사진\"\u003e\u003c/p\u003e\n\u003cp\u003e사진은 위와 같다. 사진에는 보이지 않지만, 장구의 면에도 은박지가 부착되어 있다.\u003c/p\u003e\n\u003ch1 id=\"결론\"\u003e결론\u003c/h1\u003e\n\u003cp\u003e쿠킹호일과 NPN 트랜지스터, 저항, 그리고 아두이노를 이용해 장구 컨트롤러를 만들었다. 내구성은 썩 좋지 않았지만 인식은 잘 됐다. 2023년 겨울방학의 일이었다.\u003c/p\u003e\n"},"nextPost":{"name":"caucalendar_1","metadata":{"title":"학사일정 ICS 서비스 개발기 (上)","subtitle":"Javascript랑 함께 Docker로","author":"LiteHell","date":"2024-09-15T13:06:50.914Z","category":"Dev","series":"puang_network","seriesName":"학사일정/RSS/시간표 미리보기 서비스 개발기"},"rendered":"\u003ch1 id=\"들어가는-글\"\u003e들어가는 글\u003c/h1\u003e\n\u003cp\u003e나는 캘린더 앱을 적극적으로 활용한다. 시간이나 약속을 머릿속으로만 관리하면 잘 잊어버리기 때문에 캘린더 앱을 적극적으로 활용하고 있다.\u003c/p\u003e\n\u003cp\u003e그렇게 캘린더 앱을 적극적으로 쓰다가 대학교에 입학했다. 시험기간이나 수강정정기간 같은 것도 캘린더 앱에 뜨면 좋겠는데 이걸 직접 추가하는 건 귀찮았다. 그래서 \u003ca href=\"https://www.cau.ac.kr/cms/FR_CON/index.do?MENU_ID=590\"\u003e중앙대학교 학사일정 페이지\u003c/a\u003e를 크롤링하는 어플리케이션을 작성했다. 그리고 캘린더 앱과 내 어플리케이션을 연동하는 데에는 iCalendar 파일 포맷을 이용했다.\u003c/p\u003e\n\u003ch2 id=\"icalendar\"\u003eiCalendar\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://calendar.google.com\"\u003eGoogle Calendar\u003c/a\u003e나 \u003ca href=\"https://outlook.com\"\u003eMS Outlook\u003c/a\u003e, 혹은 필자가 이용하는 \u003ca href=\"https://www.fastmail.com\"\u003eFastMail\u003c/a\u003e에서는 캘린더 기능을 제공한다. 이 캘린더 서비스들은 기본적으로 특정한 iCalendar 주소를 구독하는 기능을 지원한다. 즉, 다시 말해 필자가 구글 캘린더나 아웃룩에 iCalendar 파일 주소를 추가하면, 구글 캘린더나 아웃룩 서버가 주기적으로 iCalendar 주소에 접속해 동기화한다.\u003c/p\u003e\n\u003cp\u003eiCalendar 파일은 다음과 같은 형식으로 되어있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBEGIN:VCALENDAR\nVERSION:2.0\nTIMEZONE-ID:Asia/Seoul\nX-WR-TIMEZONE:Asia/Seoul\nX-WR-CALNAME:중앙대학교 학사일정\nX-WR-CALDESC:calendar.puang.network에서 제공하는 중앙대학교 학사일정\nCALSCALE:GREGORIAN\nPRODID:adamgibbons/ics\nMETHOD:PUBLISH\nX-PUBLISHED-TTL:PT1H\nBEGIN:VTIMEZONE\nTZID:Asia/Seoul\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Seoul\nX-LIC-LOCATION:Asia/Seoul\nBEGIN:STANDARD\nTZOFFSETFROM:+0900\nTZOFFSETTO:+0900\nTZNAME:KST\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\nBEGIN:VEVENT\nUID:552361268d864ef42fff1bee5d295e073f7ab2b2@calendar.puang.network\nSUMMARY:신정(공휴일)\nDTSTAMP:20240825T081930Z\nDTSTART;TZID=Asia/Seoul;VALUE=DATE:20220101\nEND:VEVENT\nBEGIN:VEVENT\nUID:eb57cfcaf7345c4ad83d1e7537dd81016db2d8a7@calendar.puang.network\nSUMMARY:2022년 1학기 재입학 원서접수\nDTSTAMP:20240825T081930Z\nDTSTART;TZID=Asia/Seoul;VALUE=DATE:20220103\nDTEND;TZID=Asia/Seoul;VALUE=DATE:20220107\nEND:VEVENT\nEND:VCALENDAR\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같은 식으로 iCalendar 아이템(\u003ccode\u003eVCALENDAR\u003c/code\u003e) 속에 여러 일정(\u003ccode\u003eVEVENT\u003c/code\u003e)들이 나열되어 있다. iCalendar 형식은 할일(\u003ccode\u003eVTODO\u003c/code\u003e)이나 일기(\u003ccode\u003eVJOURNAL\u003c/code\u003e)도 지원하지만 이 글에서는 다루지 않는다.\u003c/p\u003e\n\u003ch2 id=\"koajs를-이용한-첫-버전\"\u003e\u003ca href=\"https://koajs.com/\"\u003eKoa.js\u003c/a\u003e를 이용한 첫 버전\u003c/h2\u003e\n\u003cp\u003e첫 버전은 \u003ca href=\"https://koajs.com/\"\u003eKoa 프레임워크\u003c/a\u003e를 이용하여 간단하게 작성했다. 원래 이전에는 \u003ca href=\"https://expressjs.com/\"\u003eexpress\u003c/a\u003e를 썼었는데, express는 \u003ccode\u003easync\u003c/code\u003e 함수 핸들러가 바로 지원되지 않아서 약간 귀찮다는 단점이 있었기에 Koa 프레임워크를 이용했다.\u003c/p\u003e\n\u003cp\u003e이 프로그램에서 중요한 것은 iCalendar 파일을 제공하는 것이다. 따라서 그 외의 요소는 모두 부수적인 것이다. 그렇기에 프론트엔드는 다음과 같이 디자인이 극단적으로 되어있어도 상관없었다. (사진은 첫 커밋 버전의 메인 페이지이다.)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/puang_network/caucalendar_first_commit_html.png\" alt=\"첫 커밋 버전의 caucalendar.online 프로젝트 프론트엔드\"\u003e\u003c/p\u003e\n\u003cp\u003e다만 그래도 위처럼 만드는 건 좀 심하니 \u003ca href=\"https://bulma.io\"\u003ebulma CSS 프레임워크\u003c/a\u003e를 이용해 아래와 같이 간단히 꾸몄다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/puang_network/caucalendar_bulma_frontend.png\" alt=\"bulma 프레임워크를 이용한 caucalendar.online 프로젝트 프론트엔드\"\u003e\u003c/p\u003e\n\u003cp\u003e이때가 2019년 5~6월쯤이였다. 이때의 구조도는 다음과 같다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/puang_network/caucalendar_vps_nodejs.png\" alt=\"서비스 구조도\"\u003e\u003c/p\u003e\n\u003cp\u003e당시 가상서버에서는 여러 웹서비스가 구동되고 있었기에, Host를 확인하여 알맞은 웹서비스로 트래픽을 전달해야 했다. 따라서 Nginx로 리버스 프록시가 동작하고 있었다.\u003c/p\u003e\n\u003cp\u003e위 사진에서 \u003ca href=\"https://pm2.io\"\u003ePM2\u003c/a\u003e는 프로세스가 꺼지면 다시 켜주는 역할을 한다. \u003ca href=\"https://github.com/librewiki/liberty-engine\"\u003e리브레위키의 리버티엔진\u003c/a\u003e에서 쓰길래 써봤다.\u003c/p\u003e\n\u003ch2 id=\"크롤링-스크립트-분리\"\u003e크롤링 스크립트 분리\u003c/h2\u003e\n\u003cp\u003e초기에는 크롤링을 분리하기 귀찮아서, 그냥 요청이 들어올 때마다 학교 홈페이지에 접속해 학사일정 iCalendar 파일(이하 \u0026quot;ics 파일\u0026quot;)을 제공했다. 그랬더니 어느순간 학교에서 서버 ip를 차단했다. 이게 2019년 11월 쯤의 일이였다.\u003c/p\u003e\n\u003cp\u003e그래서 크롤링하는 코드를 별도의 파일로 분리하고, crontab을 이용해 크롤링 스크립트가 주기적으로 실행되게 했다. 크롤링된 데이터는 \u003ca href=\"https://sequelize.org/\"\u003eSequelize\u003c/a\u003e ORM을 이용해 저장했다.\u003c/p\u003e\n\u003ch2 id=\"github-action\"\u003eGitHub Action\u003c/h2\u003e\n\u003cp\u003e학사일정 서비스에 버그가 생겼다고 캘린더 앱에서 잘 보이던 일정이 갑자기 사라지진 않는다. 그래서 동작에 이상이 생겨도 기존에 쓰던 사람들은 티가 잘 안난다.\u003c/p\u003e\n\u003cp\u003e그래서 동작이 정상적으로 이루어지는 지 주기적으로 확인하기 위해 다음과 같이 GitHub Action을 추가했다.\n푸시나 커밋시가 아닌 특정 주기에 따라 반복되는 GitHub CI로 테스트가 주기적으로 이루어지도록 했다.\u003c/p\u003e\n\u003cp\u003e따라서 이를 통해 학교 홈페이지의 갑작스런 디자인/API 변경에도 대응할 수 있었다. \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yml\"\u003e\u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eand\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etest\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003eon:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eschedule:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecron:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;0 19 * * *\u0026#x27;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003epush:\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003ejobs:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ebuild:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eruns-on:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu-latest\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003esteps:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eactions/checkout@v3\u003c/span\u003e\n\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuild\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edocker\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ebuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--target\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etest\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e푸시나 커밋시가 아닌 cron으로 GitHub CI를 추가하여 학교 홈페이지의 갑작스런 디자인/API 변경에도 대응할 수 있도록 했다.\u003c/p\u003e\n\u003ch2 id=\"도커라이징\"\u003e도커라이징\u003c/h2\u003e\n\u003cp\u003e개인서버에서 돌아가던 서비스들을 다 도커 컨테이너에 감싸는 작업을 했었다. 그때 학사일정 ics 서비스도 도커 컨테이너로 감쌌다. crontab을 이용해 따로 돌아가던 크롤링 스크립트는 어플리케이션에 다시 집어넣어서, 어플리케이션 실행시 크롤링이 자동으로 주기적으로 실행되도록 수정했다. Docker에서 crontab을 쓰려면 약간 귀찮기 때문이다.\u003c/p\u003e\n\u003cp\u003e처음에는 \u003ccode\u003enode:14\u003c/code\u003e 도커 이미지를 기반으로 썼는데 값싼 가상서버에서 쓰기에는 디스크를 너무 많이 차지했다. 그래서 나중에 Alpine Linux 기반 도커를 기반으로 바꿨다. Alpine Linux 기반 이미지를 쓰니 디스크 소비량을 줄일 수 있었다. 이때가 2021년 2~3월인가 그랬을 것이다.\u003c/p\u003e\n\u003ch2 id=\"go-언어로의-재작성\"\u003eGo 언어로의 재작성\u003c/h2\u003e\n\u003cp\u003e그렇게 Javascript로 작성해서 잘 쓰다가 문득 이런 생각이 들었다. \u0026#39;Go를 쓰면 더 빠르지 않을까?\u0026#39; Javascript는 인터프리터 언어이고, Go는 컴파일 언어이니, 알고리즘의 효율성이 유사하다는 가정하에 Go가 더 빠를 수도 있지 않을까란 생각이 들었다. 물론 Go 언어를 한 번 써보고 싶은 생각도 없진 않았다.\u003c/p\u003e\n\u003cp\u003e그래서 Go 언어로 학사일정 서비스를 재작성했다. 크롤러는 다음과 같이 고루틴을 이용하여 비동기적으로 동시에 구동되도록 했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;time\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecrawlWorker\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e {\n        time.Sleep(time.Hour * \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n        fetchAllYears()\n    }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003esetupCrawller\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ego\u003c/span\u003e crawlWorker()\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"docker를-이용한-테스팅\"\u003eDocker를 이용한 테스팅\u003c/h2\u003e\n\u003cp\u003eDigiCert CA 인증서와 관련된 문제가 있어 해당 CA 인증서를 추가하여 문제를 해결했었다. 물론 HTTP 요청시 인증서 오류를 모두 무시하도록 하는 방법도 있지만, 그 방법은 보안이 취약해지기에 채택하지 않았다.\u003c/p\u003e\n\u003cp\u003e다만 이렇게 CA 인증서를 추가하는 식으로 해결할 시에는 \u003ccode\u003ego test -v\u003c/code\u003e 명령어만으로 테스트를 할 수 없다는 문제점이 있었다. 그래서 \u003ca href=\"/post/docker_for_testing\"\u003eDocker를 테스트에도 활용할 수 있도록 다음과 같이 Dockerfile을 수정했다.\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dockerfile\"\u003e\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e golang:alpine AS base\n\n\u003cspan class=\"hljs-keyword\"\u003eWORKDIR\u003c/span\u003e\u003cspan class=\"bash\"\u003e /app\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# To avoid tls error from swedu.cau.ac.kr\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e digicert-ca.pem /usr/\u003cspan class=\"hljs-built_in\"\u003elocal\u003c/span\u003e/share/ca-certificates/digicert-ca.crt\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e cat /usr/\u003cspan class=\"hljs-built_in\"\u003elocal\u003c/span\u003e/share/ca-certificates/digicert-ca.crt \u0026gt;\u0026gt; /etc/ssl/certs/ca-certificates.crt\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e go.mod go.sum ./\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e go mod download \u0026amp;\u0026amp; go mod verify\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e static ./static\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e *.go ./\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e base AS deployment\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e go build -v -o /app/app\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;/app/app\u0026quot;\u003c/span\u003e]\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e base As test\n\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e go \u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e -v ./...\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"서버리스\"\u003e서버리스\u003c/h2\u003e\n\u003cp\u003e위와 같이 만들어서 굴리다가 추후 AWS Lambda 함수를 이용한 서버리스로 재작성했다. 이에 대해선 다음 글에서 이어서 작성하도록 하겠다.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"bidrum_on_rust"},"buildId":"ATEd0FxlIfOQZYNj1ewGd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>