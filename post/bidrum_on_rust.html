<!DOCTYPE html><html lang="ko-KR"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><link rel="canonical" href="https://blog.litehell.info/post/bidrum_on_rust"/><link rel="alternate" type="application/rss+xml" title="RSS 2.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/rss"/><link rel="alternate" type=" application/atom+xml" title="Atom 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/atom"/><link rel="alternate" type="application/feed+json" title="Json 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/json"/><meta property="og:title" content="Rust와 SDL2"/><meta property="og:description" content="게임 개발에 Rust를 써보셨나요?"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="article"/><meta property="og:site_name" content="LiteHell의 블로그"/><meta property="og:url" content="https://blog.litehell.info/post/bidrum_on_rust"/><meta property="og:image" content="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><title>LiteHell의 블로그 - <!-- -->Rust와 SDL2</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/vs2015.min.css"/><meta name="next-head-count" content="16"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CZL0E8YDPW"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-CZL0E8YDPW', { page_path: window.location.pathname });
            </script><link rel="preload" href="/_next/static/css/27d177a30947857b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27d177a30947857b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/088d29430e0ecbdb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/088d29430e0ecbdb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-ad45764ecfcae9e5.js" defer=""></script><script src="/_next/static/chunks/main-ee0cf4b7f81d7c24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a96cacb95f41a3ef.js" defer=""></script><script src="/_next/static/chunks/996-c5e5aa4c30f33066.js" defer=""></script><script src="/_next/static/chunks/503-25bfb158f613fce4.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-b722ca2857677f7b.js" defer=""></script><script src="/_next/static/npDcIhLhS3jfUpUcNDMEy/_buildManifest.js" defer=""></script><script src="/_next/static/npDcIhLhS3jfUpUcNDMEy/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_body__O2_kC"><header class="Layout_header__M_IZ8"><div class="Layout_container__z4qWC"><h1><a href="/">LiteHell의 블로그</a></h1><div class="Layout_outLinks__XBNs_">외부고리 : <a href="https://litehell.info">Homepage</a><a href="https://github.com/LiteHell">GitHub</a><a href="https://linkedin.com/in/LiteHell">LinkedIn</a><a href="https://keybase.io/LiteHell">Keybase</a><a href="mailto:litehell@litehell.info">Email</a></div><div class="Layout_inLinks__f7gmD">내부고리 : <a href="/category">카테고리</a><a href="/tag">태그</a></div></div></header><main class="Layout_mainContainer__5WZfx"><div class="Layout_container__z4qWC"><div class="Blog_header__r4wcZ"><div class="Blog_title___OFu6"><h1>Rust와 SDL2</h1><h2>게임 개발에 Rust를 써보셨나요?</h2></div><p>8/11/2024, 2:35:24 PM<!-- -->에 <!-- -->LiteHell<!-- -->이(가) 작성<!-- -->함<br/><span>카테고리 : <a href="/category/Dev">Dev</a><br/></span><span>태그 : <span class="Blog_tag__RW5VK"><a href="/tag/Game">Game</a></span><br/></span></p></div><div class="Blog_seriesContainer__ii8Fj"><div class="Blog_seriesTitle__DCd_w">(시리즈) <!-- -->리듬게임 바이드럼 개발기</div><ul><li><a href="/post/bidrum_and_janggu_controller_prototyping">쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기</a></li><li class="Blog_now__E4xgg"><a href="/post/bidrum_on_rust">Rust와 SDL2</a></li></ul></div><section class="Blog_article__WZp3G"><h1 id="들어가는-글">들어가는 글</h1>
<p><em>※ 참고: 이 시리즈의 글은 시간순 작성을 최대한 목표하고 있으나, 글의 짜임새나 가독성을 위해 미리시점이나 과거시점의 이야기가 섞이거나 순서가 일부 달라질 수 있습니다.</em></p>
<p>내가 만들고 싶은 게임은 아케이드 리듬게임이였다. 마침 내 방에 라즈베리 파이(4B Rev 1.2)가 있어서, 라즈베리 파이로 게임을 구동하고 싶었다. Unity나 Unreal Engine으로 만든 게임이 라즈베리 파이 위에서 돌아갈까? 아마도 돌아가지 않을 것이다. 실제로 돌려본 적은 없지만 라즈베리 파이가 성능이 좋은 편은 아니니까.</p>
<p>그래서 필자는 마침 <a href="https://www.rust-lang.org/">Rust</a> 프로그래밍 언어를 한 번 써보고 싶은 생각도 있었기에, Rust로 직접 게임을 만들어보기로 결심했다. 게임 엔진을 쓰면 나중에 게임이 유명해졌을 때 라이선스비를 내야 한다는 것도 하나의 이유였다. (좀 과한 김칫국이긴 하지만...) 그래서 유니티니 언리얼이니 하는 게임 엔진을 쓰지 않고 Rust로 기초부터 쌓아올리기 시작했다.</p>
<h1 id="sdl2를-이용한-게임-프로그래밍">SDL2를 이용한 게임 프로그래밍</h1>
<p>Rust에는 <a href="https://github.com/Rust-SDL2/rust-sdl2">rust-sdl2</a>라는 라이브러리 바인딩이 있다. SDL2는 오디오, 키보드, 마우스, 그래픽, 조이스틱을 다를 수 있게 하는 크로스플랫폼 라이브러리이다. 즉, 그래픽이나 마우스 등에 대한 Direct3D/OpenGL 등의 운영체제/플랫폼 종속적인 API를 추상화하고 단일한 인터페이스로 통일하여 크로스 플랫폼으로 개발할 수 있게 하는 라이브러리이다.</p>
<p>따라서 SDL2를 이용하면 Mac OS X/Windows/Linux에서 크로스플랫폼으로 실행할 수 있고, 라이브러리도 별로 무겁지 않다. 그래서 SDL2를 이용하게 됐다.</p>
<h2 id="sdl2">SDL2</h2>
<p>SDL2는 rust-sdl 레포 내의 예제 코드를 보면서 따라하면 사용하기 쉽다. SDL2는 먼저 Window(창)을 만든 뒤, Window의 Canvas에 원하는 것을 그리고 렌더링하고 클리어하는 것을 반복한다. 이를 순서대로 나타내면 다음과 같다.</p>
<blockquote>
<p>(A) Window 생성 → (B) Window의 Canvas를 Clear한다 → (C) Canvas에 뭔가를 그린다. → (D) Window의 Canvas를 Present한다. → (E) 화면이 표시한다. → (F) B로 되돌아간다.</p>
</blockquote>
<p>학부 수준의 컴퓨터그래픽스 수업을 들었거나 OpenGL 프로그래밍을 조금이라도 맛보았다면 매우 이해하기 쉬울 것이다.</p>
<p>SDL2는 키보드나 조이스틱 인식을 위한 EventPump 기능을 제공한다. 키보드 인풋이 들어오면 EventPump에 Event가 생성된다. 게임은 이 EventPump에 Event가 있는지 확인하여 만약 Event가 있다면 해당 Event의 데이터를 활용해 키보드 인풋을 처리할 수 있다. 게임 특성상 이 EventPump은 디버깅 용으로만 주로 이용됐다.</p>
<h2 id="gamecommoncontext">GameCommonContext</h2>
<p>위에서 언급한 바에 같이 그래픽을 렌더링하기 위해서는 Canvas 객체에 대한 접근이 필요하다. 그래서 초기 게임 초기화시 Canvas와 Window, SDL Context 등을 담은 GameCommonContext 객체를 만들고 이를 함수간에 서로 주고받는 형태로 빠르게 게임을 구현했다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> kira::manager::AudioManager;
<span class="hljs-keyword">use</span> sdl2::{render::Canvas, EventPump, video::Window};

<span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GameCommonContext</span></span> {
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) coins: <span class="hljs-built_in">u32</span>,
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) price: <span class="hljs-built_in">u32</span>,
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) sdl_context: sdl2::Sdl,
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) audio_manager: AudioManager,
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) canvas: Canvas&lt;Window&gt;,
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) event_pump: EventPump,
}</code></pre>
<p>(속성은 나중에 게임이 개발되면 될 수록 더 늘어난다.)</p>
<p>그리고 이는 추후 대규모 리팩토링으로 Rust의 특징을 온몸으로 깨닫는 계기가 됐다.... 나중에 소유권이랑 lifetime 문제가 미친 듯이 터져나와서 그거 씨름하느라 엄청 고생하게 됐다.</p>
<h2 id="rust에서의-시리얼-통신">Rust에서의 시리얼 통신</h2>
<p>게임을 장구 하드웨어와 연동하기 위해서는 시리얼 통신이 필요하다.</p>
<p>Arduino Leonardo 등 HID 에뮬레이션을 지원하는 보드가 있으면 장구 하드웨어에서 키보드 인풋을 주도록 할 수도 있다. 그런데 당장 내 방에 있는 게 Arduino UNO 호환보드(흔히 &quot;짭두이노&quot;라고 불리는 보드)밖에 없었다. 그래서 시리얼 통신으로 구현했다. 나중의 미래에 레오나르도 보드를 사서 키보드 인풋으로도 구현해보긴 했는데.... 딱따구리마냥 장구 채를 갖다대기만 해도 장구 채를 미친듯이 연타한 것마냥 동작하는 버그가 있어서 그냥 시리얼 통신을 계속 쓰게 됐다.</p>
<p>Rust에서는 시리얼 통신을 어떻게 할까? 고맙게도 <a href="https://docs.rs/serialport/latest/serialport/">serialport</a>라는 라이브러리가 있다. 이를 이용해 장구 하드웨어와의 시리얼 통신 코드를 작성했다. 그리고 장구 하드웨어로부터 인풋을 읽는 코드를 멀티쓰레딩으로 분리하고 <code>AtomicU8</code>을 이용하여 게임 쓰레드와 인풋 쓰레드 간에 장구 인풋 상태를 서로 공유했다.</p>
<p>왜 뜬끔없이 <code>AtomicU8</code>이냐? 장구 컨트롤러의 상태를 나타내는 데에는 4개의 비트만 있으면 충분하다. 그래서 컨트롤러는 1바이트의 데이터를 무한히 연속적으로 보낸다. 이 1바이트를 해석하는 코드는 다음과 같다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse_janggu_bits</span></span>(bits: <span class="hljs-built_in">u8</span>) -&gt; JangguState {
    JangguState {
        궁채: <span class="hljs-keyword">if</span> bits &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span> {
            <span class="hljs-literal">Some</span>(DrumPane::채편)
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> bits &amp; <span class="hljs-number">2</span> != <span class="hljs-number">0</span> {
            <span class="hljs-literal">Some</span>(DrumPane::북편)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">None</span>
        },
        북채: <span class="hljs-keyword">if</span> bits &amp; <span class="hljs-number">4</span> != <span class="hljs-number">0</span> {
            <span class="hljs-literal">Some</span>(DrumPane::채편)
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> bits &amp; <span class="hljs-number">8</span> != <span class="hljs-number">0</span> {
            <span class="hljs-literal">Some</span>(DrumPane::북편)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">None</span>
        },
    }
}</code></pre>
<p>장구 컨트롤러와 연동하는 쓰레드는 컨트롤러로부터 시리얼 통신으로 받은 데이터를 바로 <code>GameCommonContext</code> 개체의 <code>janggu_bits_ptr</code> 필드에 저장한다.</p>
<pre><code class="hljs language-rust"><span class="hljs-comment">// ... (생략) ....</span>

<span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GameCommonContext</span></span> {
   <span class="hljs-comment">// ... (생략) ...</span>
   <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) janggu_bits_ptr: Arc&lt;AtomicU8&gt;,
}

<span class="hljs-keyword">impl</span> GameCommonContext {
    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_janggu_state</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; JangguState {
        <span class="hljs-keyword">return</span> parse_janggu_bits(
            <span class="hljs-keyword">self</span>.janggu_bits_ptr
                .load(std::sync::atomic::Ordering::Relaxed),
        );
    }
}
</code></pre>
<p>게임 쓰레드에서 장구의 상태를 확인할 때는 <code>read_janggu_state</code> 메소드를 이용한다.</p>
<p>추후 미래에 <code>AtomicU8</code>을 없애고 Product-Consumer Lock으로 <code>JangguState</code> 객체를 직접 공유해보기도 했는데, 렉이 너무 심해서 그냥 <code>AtomicU8</code>을 계속 쓰게 됐다.</p>
<h1 id="결론">결론</h1>
<p>Rust를 이용한 게임 개발은 초창기에는 할만했는데 뒤로 갈수록 어려웠다. 소유권, 대여, lifetime 문제를 해결하느라 골머리를 참 많이 썩었다. 그래서 결론적으로 짧은 기간 안에 게임을 개발해야 한다면 Rust는 별로 좋은 선택이 아니지 않을까라는 생각이 들었다.</p>
</section><div class="Comments_blogComments__GRWmY"></div><nav class="Blog_postNav__ivy8_"><div class="Blog_leftAnchor__HhzIP"><a href="/post/bidrum_and_janggu_controller_prototyping"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기</div><div class="Blog_subtitle__RRFh7">학교 캡스톤디자인 작품으로 장구 리듬게임 만든 이야기</div></div></a></div><div class="Blog_nothing__mDnAo"></div></nav></div></main><footer class="Layout_footer__bKkxe"><div class="Layout_container__z4qWC"><a href="https://www.gnu.org/licenses/agpl-3.0.en.html"><img alt="GNU Affero General License Version 3" src="https://www.gnu.org/graphics/agplv3-with-text-100x42.png" style="height:31px"/></a> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a><br/>Copyrights (C) 2020 LiteHell, All rights reserved.<br/><div class="Layout_visibleOnPrintOnly__UK6Yl">LiteHell&#x27;s Blog - <a href="https://blog.litehell.info">https://blog.litehell.info</a><br/>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.<br/><br/>Url of this article: <a href="https://blog.litehell.info/post/bidrum_on_rust">https://blog.litehell.info/post/bidrum_on_rust</a><br/></div><div class="Layout_invisibleOnPrint__rdrDv">Fox Image : Copyrights (C) 2004 Shiretoko-Shari Torurist Association<br/><a href="/license">This blog is free software; For source code and more informations on license and copyrights, Click here.</a><br/><br/>Feeds : <a href="/feed/rss">RSS 2.0</a>,<!-- --> <a href="/feed/atom">Atom 1.0</a>, <a href="/feed/json">Json 1.0</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"metadata":{"title":"Rust와 SDL2","subtitle":"게임 개발에 Rust를 써보셨나요?","author":"LiteHell","date":"2024-08-11T14:35:24.968Z","category":"Dev","series":"bidrum","tags":["Game"]},"rendered":"\u003ch1 id=\"들어가는-글\"\u003e들어가는 글\u003c/h1\u003e\n\u003cp\u003e\u003cem\u003e※ 참고: 이 시리즈의 글은 시간순 작성을 최대한 목표하고 있으나, 글의 짜임새나 가독성을 위해 미리시점이나 과거시점의 이야기가 섞이거나 순서가 일부 달라질 수 있습니다.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e내가 만들고 싶은 게임은 아케이드 리듬게임이였다. 마침 내 방에 라즈베리 파이(4B Rev 1.2)가 있어서, 라즈베리 파이로 게임을 구동하고 싶었다. Unity나 Unreal Engine으로 만든 게임이 라즈베리 파이 위에서 돌아갈까? 아마도 돌아가지 않을 것이다. 실제로 돌려본 적은 없지만 라즈베리 파이가 성능이 좋은 편은 아니니까.\u003c/p\u003e\n\u003cp\u003e그래서 필자는 마침 \u003ca href=\"https://www.rust-lang.org/\"\u003eRust\u003c/a\u003e 프로그래밍 언어를 한 번 써보고 싶은 생각도 있었기에, Rust로 직접 게임을 만들어보기로 결심했다. 게임 엔진을 쓰면 나중에 게임이 유명해졌을 때 라이선스비를 내야 한다는 것도 하나의 이유였다. (좀 과한 김칫국이긴 하지만...) 그래서 유니티니 언리얼이니 하는 게임 엔진을 쓰지 않고 Rust로 기초부터 쌓아올리기 시작했다.\u003c/p\u003e\n\u003ch1 id=\"sdl2를-이용한-게임-프로그래밍\"\u003eSDL2를 이용한 게임 프로그래밍\u003c/h1\u003e\n\u003cp\u003eRust에는 \u003ca href=\"https://github.com/Rust-SDL2/rust-sdl2\"\u003erust-sdl2\u003c/a\u003e라는 라이브러리 바인딩이 있다. SDL2는 오디오, 키보드, 마우스, 그래픽, 조이스틱을 다를 수 있게 하는 크로스플랫폼 라이브러리이다. 즉, 그래픽이나 마우스 등에 대한 Direct3D/OpenGL 등의 운영체제/플랫폼 종속적인 API를 추상화하고 단일한 인터페이스로 통일하여 크로스 플랫폼으로 개발할 수 있게 하는 라이브러리이다.\u003c/p\u003e\n\u003cp\u003e따라서 SDL2를 이용하면 Mac OS X/Windows/Linux에서 크로스플랫폼으로 실행할 수 있고, 라이브러리도 별로 무겁지 않다. 그래서 SDL2를 이용하게 됐다.\u003c/p\u003e\n\u003ch2 id=\"sdl2\"\u003eSDL2\u003c/h2\u003e\n\u003cp\u003eSDL2는 rust-sdl 레포 내의 예제 코드를 보면서 따라하면 사용하기 쉽다. SDL2는 먼저 Window(창)을 만든 뒤, Window의 Canvas에 원하는 것을 그리고 렌더링하고 클리어하는 것을 반복한다. 이를 순서대로 나타내면 다음과 같다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e(A) Window 생성 → (B) Window의 Canvas를 Clear한다 → (C) Canvas에 뭔가를 그린다. → (D) Window의 Canvas를 Present한다. → (E) 화면이 표시한다. → (F) B로 되돌아간다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e학부 수준의 컴퓨터그래픽스 수업을 들었거나 OpenGL 프로그래밍을 조금이라도 맛보았다면 매우 이해하기 쉬울 것이다.\u003c/p\u003e\n\u003cp\u003eSDL2는 키보드나 조이스틱 인식을 위한 EventPump 기능을 제공한다. 키보드 인풋이 들어오면 EventPump에 Event가 생성된다. 게임은 이 EventPump에 Event가 있는지 확인하여 만약 Event가 있다면 해당 Event의 데이터를 활용해 키보드 인풋을 처리할 수 있다. 게임 특성상 이 EventPump은 디버깅 용으로만 주로 이용됐다.\u003c/p\u003e\n\u003ch2 id=\"gamecommoncontext\"\u003eGameCommonContext\u003c/h2\u003e\n\u003cp\u003e위에서 언급한 바에 같이 그래픽을 렌더링하기 위해서는 Canvas 객체에 대한 접근이 필요하다. 그래서 초기 게임 초기화시 Canvas와 Window, SDL Context 등을 담은 GameCommonContext 객체를 만들고 이를 함수간에 서로 주고받는 형태로 빠르게 게임을 구현했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e kira::manager::AudioManager;\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e sdl2::{render::Canvas, EventPump, video::Window};\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eGameCommonContext\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) coins: \u003cspan class=\"hljs-built_in\"\u003eu32\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) price: \u003cspan class=\"hljs-built_in\"\u003eu32\u003c/span\u003e,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) sdl_context: sdl2::Sdl,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) audio_manager: AudioManager,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) canvas: Canvas\u0026lt;Window\u0026gt;,\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) event_pump: EventPump,\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(속성은 나중에 게임이 개발되면 될 수록 더 늘어난다.)\u003c/p\u003e\n\u003cp\u003e그리고 이는 추후 대규모 리팩토링으로 Rust의 특징을 온몸으로 깨닫는 계기가 됐다.... 나중에 소유권이랑 lifetime 문제가 미친 듯이 터져나와서 그거 씨름하느라 엄청 고생하게 됐다.\u003c/p\u003e\n\u003ch2 id=\"rust에서의-시리얼-통신\"\u003eRust에서의 시리얼 통신\u003c/h2\u003e\n\u003cp\u003e게임을 장구 하드웨어와 연동하기 위해서는 시리얼 통신이 필요하다.\u003c/p\u003e\n\u003cp\u003eArduino Leonardo 등 HID 에뮬레이션을 지원하는 보드가 있으면 장구 하드웨어에서 키보드 인풋을 주도록 할 수도 있다. 그런데 당장 내 방에 있는 게 Arduino UNO 호환보드(흔히 \u0026quot;짭두이노\u0026quot;라고 불리는 보드)밖에 없었다. 그래서 시리얼 통신으로 구현했다. 나중의 미래에 레오나르도 보드를 사서 키보드 인풋으로도 구현해보긴 했는데.... 딱따구리마냥 장구 채를 갖다대기만 해도 장구 채를 미친듯이 연타한 것마냥 동작하는 버그가 있어서 그냥 시리얼 통신을 계속 쓰게 됐다.\u003c/p\u003e\n\u003cp\u003eRust에서는 시리얼 통신을 어떻게 할까? 고맙게도 \u003ca href=\"https://docs.rs/serialport/latest/serialport/\"\u003eserialport\u003c/a\u003e라는 라이브러리가 있다. 이를 이용해 장구 하드웨어와의 시리얼 통신 코드를 작성했다. 그리고 장구 하드웨어로부터 인풋을 읽는 코드를 멀티쓰레딩으로 분리하고 \u003ccode\u003eAtomicU8\u003c/code\u003e을 이용하여 게임 쓰레드와 인풋 쓰레드 간에 장구 인풋 상태를 서로 공유했다.\u003c/p\u003e\n\u003cp\u003e왜 뜬끔없이 \u003ccode\u003eAtomicU8\u003c/code\u003e이냐? 장구 컨트롤러의 상태를 나타내는 데에는 4개의 비트만 있으면 충분하다. 그래서 컨트롤러는 1바이트의 데이터를 무한히 연속적으로 보낸다. 이 1바이트를 해석하는 코드는 다음과 같다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eparse_janggu_bits\u003c/span\u003e\u003c/span\u003e(bits: \u003cspan class=\"hljs-built_in\"\u003eu8\u003c/span\u003e) -\u0026gt; JangguState {\n    JangguState {\n        궁채: \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::채편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::북편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n        },\n        북채: \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::채편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e bits \u0026amp; \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eSome\u003c/span\u003e(DrumPane::북편)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n        },\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e장구 컨트롤러와 연동하는 쓰레드는 컨트롤러로부터 시리얼 통신으로 받은 데이터를 바로 \u003ccode\u003eGameCommonContext\u003c/code\u003e 개체의 \u003ccode\u003ejanggu_bits_ptr\u003c/code\u003e 필드에 저장한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ... (생략) ....\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eGameCommonContext\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-comment\"\u003e// ... (생략) ...\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) janggu_bits_ptr: Arc\u0026lt;AtomicU8\u0026gt;,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e GameCommonContext {\n    \u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ecrate\u003c/span\u003e) \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eread_janggu_state\u003c/span\u003e\u003c/span\u003e(\u0026amp;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) -\u0026gt; JangguState {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e parse_janggu_bits(\n            \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.janggu_bits_ptr\n                .load(std::sync::atomic::Ordering::Relaxed),\n        );\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e게임 쓰레드에서 장구의 상태를 확인할 때는 \u003ccode\u003eread_janggu_state\u003c/code\u003e 메소드를 이용한다.\u003c/p\u003e\n\u003cp\u003e추후 미래에 \u003ccode\u003eAtomicU8\u003c/code\u003e을 없애고 Product-Consumer Lock으로 \u003ccode\u003eJangguState\u003c/code\u003e 객체를 직접 공유해보기도 했는데, 렉이 너무 심해서 그냥 \u003ccode\u003eAtomicU8\u003c/code\u003e을 계속 쓰게 됐다.\u003c/p\u003e\n\u003ch1 id=\"결론\"\u003e결론\u003c/h1\u003e\n\u003cp\u003eRust를 이용한 게임 개발은 초창기에는 할만했는데 뒤로 갈수록 어려웠다. 소유권, 대여, lifetime 문제를 해결하느라 골머리를 참 많이 썩었다. 그래서 결론적으로 짧은 기간 안에 게임을 개발해야 한다면 Rust는 별로 좋은 선택이 아니지 않을까라는 생각이 들었다.\u003c/p\u003e\n"},"articleId":"bidrum_on_rust","series":[{"title":"쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기","articleId":"bidrum_and_janggu_controller_prototyping"},{"title":"Rust와 SDL2","articleId":"bidrum_on_rust"}],"seriesName":"리듬게임 바이드럼 개발기","previousPost":{"name":"bidrum_and_janggu_controller_prototyping","metadata":{"title":"쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기","subtitle":"학교 캡스톤디자인 작품으로 장구 리듬게임 만든 이야기","author":"LiteHell","date":"2024-07-19T12:53:12.021Z","series":"bidrum","seriesName":"리듬게임 바이드럼 개발기","category":"Dev","tags":["Game"]},"rendered":"\u003ch1 id=\"서문\"\u003e서문\u003c/h1\u003e\n\u003cp\u003e문득 장구를 이용한 리듬 게임을 만들고 싶었다. 태고의 달인도 있는데 장구의 달인이 안 될 이유가 있을까? 그래서 군대 있을 때 계속 장구 게임을 상상만 하다가 복학하고 3학년 2학기에 캡스톤디자인 과목을 듣게 됐다.\u003c/p\u003e\n\u003cp\u003e3학년 2학기 캡스톤디자인 과목에서 게임 아이디어를 제시했지만, 다른 팀원들은 리스크가 너무 크다고 반대했다. 지금 막 개강했는데 하드웨어 개발부터 시작하면 십중팔구 프로젝트가 망할 것이라는 지적이였다. 반박하기에는 너무나도 맞는 말이였다. 그래서 그냥 받아들이고 \u0026quot;알고모여\u0026quot;라는 웹 어플리케이션 프로젝트를 하게 됐다. 의외로 교수님의 평가가 계속 호평이여서 손쉽게 A+를 받았다.\u003c/p\u003e\n\u003cp\u003e중앙대학교는 캡스톤디자인을 2번 해야 졸업이 가능하다. 그래서 4학년 1학기에도 캡스톤디자인을 해야 했는데, 이때 게임 아이디어를 다시 꺼내고 싶었다. 그러나 하드웨어도 없이 빈손으로 아이디어를 꺼낸다면 또다시 팀원들로부터 리스크 우려를 받을 것 같았다. 그래서 일단 프로토타이핑을 해서 설득해야 되겠단 판단이 들었다. 판단이 이루어졌으면 바로 실천해야 하지 않겠는가? 바로 당근마켓으로 45,000원짜리 어린이 장구를 샀고, 곧이어 아두이노랑 쿠킹호일, 그리고 몇가지 부품을 구매했다.\u003c/p\u003e\n\u003ch1 id=\"프로토타이핑\"\u003e프로토타이핑\u003c/h1\u003e\n\u003ch2 id=\"유선과-무선\"\u003e유선과 무선\u003c/h2\u003e\n\u003cp\u003e내가 만드는 게임은 단순히 타격 여부만을 인식하지 않는다. \u0026quot;어떤 채로 어떤 면이 타격됐는가\u0026quot;를 인식한다. 즉, 다시 말해 열편으로 궁편을 친다면 \u0026quot;궁편이 타격됐다\u0026quot;라는 정보가 아닌 \u0026quot;열편으로 궁편이 타격됐다\u0026quot;라는 정보가 인식된다.\u003c/p\u003e\n\u003cp\u003e이를 구현하려면 채에도 센서가 있어야 된다. 그리고 이 센서는 게임 본체랑 연결되어야 한다. 어떻게 연결한 것인가? 무선과 유선 두가지 방법이 있다.\u003c/p\u003e\n\u003cp\u003e무선과 유선 각 두 가지 방법의 장단점은 다음과 같다.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003e무선\u003c/th\u003e\n\u003cth\u003e유선\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e장점\u003c/td\u003e\n\u003ctd\u003e선이 걸리지 않음\u003c/td\u003e\n\u003ctd\u003e정확도가 매우 높고 딜레이가 낮음\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e단점\u003c/td\u003e\n\u003ctd\u003e너무 낮은 정확도 및 높은 딜레이\u003c/td\u003e\n\u003ctd\u003e선이 걸리적거림\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e무선 통신은 정확도가 너무 낮다는 단점이 있다. 무선으로 채의 위치를 측정한다고 가정해보자. \u003ca href=\"https://www.inpixon.com/technology/standards/ultra-wideband\"\u003eInpixion\u003c/a\u003e의 자료에서의 무선 위치 측정 시스템의 정확도와 레어턴시는 다음과 같다.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003eUWB\u003c/th\u003e\n\u003cth\u003eChirp (CSS)\u003c/th\u003e\n\u003cth\u003eBLE\u003c/th\u003e\n\u003cth\u003eWi-Fi\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e정확도\u003c/td\u003e\n\u003ctd\u003e10~50 cm\u003c/td\u003e\n\u003ctd\u003e1~2m\u003c/td\u003e\n\u003ctd\u003e\u0026lt; 5 m\u003c/td\u003e\n\u003ctd\u003e10 m\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e레이턴시\u003c/td\u003e\n\u003ctd\u003e\u0026lt; 1 ms\u003c/td\u003e\n\u003ctd\u003e\u0026lt; 1 ms\u003c/td\u003e\n\u003ctd\u003e3~5s\u003c/td\u003e\n\u003ctd\u003e3~5s\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e정확도가 너무 낮아서 무선 위치 측정 시스템은 쓸 수가 없다. 블루투스와 와이파이는 레이턴시때문에 리듬게임 컨트롤러로 쓸 수조차 없다.\u003c/p\u003e\n\u003cp\u003e\u0026#39;그렇다면 무선이되 다른 방법을 쓰면 되는 것 아닌가?\u0026#39;라는 생각이 들 수도 있는데, 내 머리로는 그렇게 할 수 있는 방법이 딱히 떠오르지 않았다. 그래서 그냥 유선으로 연결하기로 하고, 걸리적거리는 문제는 나중에 해결하기로 했다.\u003c/p\u003e\n\u003ch2 id=\"시분할\"\u003e시분할\u003c/h2\u003e\n\u003cp\u003e자, 이제 유선으로 채의 종류를 인식하기로 했다. 장구는 두 개의 채와 두 개의 접촉면이 있다. 이 경우 가능한 경우의 수는 총 몇 가지인가? 답은 아래 표에서 볼 수 있듯 9가지이다. 두 개의 채로 하나의 접촉면을 동시에 치는 경우(아래 표에서 5번, 9번)도 고려해야 하므로 9가지이다.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003e궁채\u003c/th\u003e\n\u003cth\u003e북채\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e6\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e7\u003c/td\u003e\n\u003ctd\u003eX\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e8\u003c/td\u003e\n\u003ctd\u003e궁면\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e9\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003ctd\u003e북면\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e전기는 색깔이 없다. 접촉면에서 흐르는 전기가 궁채에서 흐르는 전기인지 북채에서 흐르는 전기인지 알 수 없다. 그렇다면 접촉면에 닿은 채가 어떤 채인지 어떻게 구분해야 할까? 필자는 FDM(주파수 분할)과 TDM(시분할)을 생각했다. 처음엔 FDM을 생각했었는데, 아두이노로 구현하기에는 난이도가 높을 것 같아 비교적 구현이 손쉬운 TDM으로 결정했다.\u003c/p\u003e\n\u003ch3 id=\"알고리즘\"\u003e알고리즘\u003c/h3\u003e\n\u003cp\u003e시분할 알고리즘은 매우 단순하다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e궁채에 전기를 흘리고 북채에 전기를 흘리지 않는다.\u003c/li\u003e\n\u003cli\u003e북면에 전기가 흐르는 지 확인한다. 북면에 전기가 흐르면 궁채는 북면에 접촉하고 있다.\u003c/li\u003e\n\u003cli\u003e궁면에 전기가 흐르는 지 확인한다. 궁면에 전기가 흐르면 궁채는 궁면에 접촉하고 있다.\u003c/li\u003e\n\u003cli\u003e북채에 전기를 흘리고 궁채에 전기를 흘리지 않는다.\u003c/li\u003e\n\u003cli\u003e북면에 전기가 흐르는 지 확인한다. 북면에 전기가 흐르면 북채는 북면에 접촉하고 있다.\u003c/li\u003e\n\u003cli\u003e궁면에 전기가 흐르는 지 확인한다. 궁면에 전기가 흐르면 북채는 궁면에 접촉하고 있다.\u003c/li\u003e\n\u003cli\u003e2, 3, 5, 6번에서의 정보를 종합하면 어떤 채가 어떤 접촉면에 접촉하고 있는 지 알 고 있다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이를 도식도로 나타내면 다음과 같다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/bidrum/controller-algorithm.png\" alt=\"알고리즘의 도식도\"\u003e\u003c/p\u003e\n\u003cp\u003e위를 실제 회로로 구현하기 위해서는 특정 회로를 신호로 열거나 닫을 수 있어야 한다.\u003c/p\u003e\n\u003ch3 id=\"릴레이\"\u003e릴레이\u003c/h3\u003e\n\u003cp\u003e특정 회로를 신호로 열거나 닫는 대표적인 부품은 릴레이이다. 릴레이는 일종의 스위치 역할을 하는 부품으로, 전자석을 이용하여 회로를 열거나 닫는다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/bidrum/relay.jpg\" alt=\"아두이노 릴레이 모듈 사진\"\u003e\u003c/p\u003e\n\u003cp\u003e매우 직관적이고 만들기 쉬워서 처음에 릴레이를 시도했었다. 그러나 문제가 있었다. 릴레이는 딜레이가 너무 크고(5ms) 결정적으로 딱따구리 같은 소음이 난다. 위 알고리즘을 빠르게 무한반복해야 하는 특성상 릴레이 열고닫기를 반복하니 전자석 딱딱거리는 소리가 무한히 들리는 것이었다.\u003c/p\u003e\n\u003ch3 id=\"트랜지스터\"\u003e트랜지스터\u003c/h3\u003e\n\u003cp\u003e그래서 주변 분들의 조언을 받아 트랜지스터를 이용했다. 주변 분께 딜레이가 1ms이하인 릴레이가 있나고 여쭤보니, 그 분께서 그런 릴레이는 없으니 트랜지스터를 쓰라고 답변해주신 것이 큰 도움이 됐다. 트랜지스터는 라디오 만들 때나(증폭) 쓰는 건 줄 알았는데 검색해보니 트랜지스터도 스위치처럼 쓸 수 있음을 알게 됐다.\u003c/p\u003e\n\u003cp\u003eNPN 트랜지스터와 저항으로 약간의 시행착오를 겪으니 잘 인식됐다. 트랜지스터를 이용한 회로는 아래와 같다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/bidrum/janggu_prototype_circuit_1.png\" alt=\"트랜지스터를 이용한 아두이노 컨트롤러 회로\"\u003e\u003c/p\u003e\n\u003cp\u003e위 회로에서 궁채, 열채, 북편, 채편 기호는 각각의 부위에 붙은 전도체를 의미한다.\u003c/p\u003e\n\u003ch2 id=\"전도체\"\u003e전도체\u003c/h2\u003e\n\u003cp\u003e전기가 흘려야 하니 채와 접촉면에는 전도체 물질을 부착해야 한다. 뭘 붙일까 고민하다가 \u003ca href=\"https://blog.naver.com/b4crazy1/221481730264\"\u003e펌프 발판을 수작업으로 제작할 때 은박지를 이용했다는 글\u003c/a\u003e이 생각났다. 그래서 다이소에서 쿠킹호일을 사다가 붙였다. 내구성은 썩 좋은 것 같진 않았지만 꽤 잘 인식됐다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/bidrum/janggu_prototype_1.jpg\" alt=\"장구 컨트롤러 프토토타입 사진\"\u003e\u003c/p\u003e\n\u003cp\u003e사진은 위와 같다. 사진에는 보이지 않지만, 장구의 면에도 은박지가 부착되어 있다.\u003c/p\u003e\n\u003ch1 id=\"결론\"\u003e결론\u003c/h1\u003e\n\u003cp\u003e쿠킹호일과 NPN 트랜지스터, 저항, 그리고 아두이노를 이용해 장구 컨트롤러를 만들었다. 내구성은 썩 좋지 않았지만 인식은 잘 됐다. 2023년 겨울방학의 일이었다.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"bidrum_on_rust"},"buildId":"npDcIhLhS3jfUpUcNDMEy","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>