<!doctypehtml><html lang=ko><link href=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 rel=icon><link href=https://blog.litehell.info/post/bidrum_on_rust rel=canonical><link href=https://blog.litehell.info/post/bidrum_on_rust hreflang=ko rel=alternate><link href=https://blog.litehell.info/post/bidrum_on_rust hreflang=en rel=alternate><link title="RSS 2.0 Feed for LiteHell's blog"href=https://blog.litehell.info/feed/rss rel=alternate type=application/rss+xml><link title="Atom 1.0 Feed for LiteHell's blog"type="	application/atom+xml"href=https://blog.litehell.info/feed/atom rel=alternate><link title="Json 1.0 Feed for LiteHell's blog"href=https://blog.litehell.info/feed/json rel=alternate type=application/feed+json><link href=https://esm.sh/@wooorm/starry-night@3/style/both.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap rel=stylesheet><meta content="Rust와 SDL2"property=og:title><meta content="게임 개발에 Rust를 써보셨나요?"property=og:description><meta content=ko property=og:locale><meta content=blog property=og:type><meta content="LiteHell의 블로그"property=og:site_name><meta content=https://blog.litehell.info/post/bidrum_on_rust property=og:url><meta content=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 property=og:image><meta content=width=device-width,initial-scale=1 name=viewport><style>html,body{margin:0;padding:0;font-family:Noto Sans KR,sans-serif}</style><title>LiteHell의 블로그 - Rust와 SDL2</title><body><link as=image href=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 rel=preload><link as=image href=https://i.creativecommons.org/l/by-sa/4.0/88x31.png rel=preload><link as=image href=https://www.gnu.org/graphics/agplv3-with-text-100x42.png rel=preload><style data-emotion="css 1nfpw07">.css-1nfpw07{--top-padding:max(40px,3rem);--vertical-padding:max(20px,2em);padding:var(--top-padding)var(--vertical-padding)0em var(--vertical-padding);box-sizing:border-box;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;align-items:center;min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-1nfpw07>*{width:100%}@media (width>=1024px){.css-1nfpw07>*{max-width:960px}}.css-1nfpw07 main{-webkit-flex:1;-ms-flex:1;flex:1}.css-1nfpw07 footer{border-top:1px solid #727272;margin:2rem 0 0;padding:1.5rem 0}</style><div class=css-1nfpw07><style data-emotion="css 1fkv74n">.css-1fkv74n{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;align-items:center;gap:2rem;padding-bottom:1.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}@media (width<=25rem){.css-1fkv74n{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}}.css-1fkv74n .profileImg a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.css-1fkv74n .profileImg img{border-radius:4rem;width:8rem;height:8rem;box-shadow:0 3px 6px #00000029,0 3px 6px #0000003b}.css-1fkv74n .title h1{word-break:keep-all;margin:0 0 .5rem;padding:0;font-size:2rem;line-height:2.5rem}.css-1fkv74n .title h1 a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.css-1fkv74n .links{margin:0;padding:0;font-size:.9rem;line-height:1.2rem}@media (width<=1023px){.css-1fkv74n .title h1{font-size:1.5rem;line-height:2rem}.css-1fkv74n .rounded img{border-radius:3.5rem 3.4rem;width:7rem;height:7rem}}</style><header class=css-1fkv74n><div class=profileImg><a href=/><img alt="LiteHell의 Gravatar 아이콘"src=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1></a></div><div class=title><h1><a href=/>LiteHell의 블로그</a></h1><p class=links>외부고리: <a href=https://github.com/litehell>GitHub</a>, <a href=https://yeonjin.name/portfolio>Portfolio</a><br>내부고리: <a href=/categories>카테고리</a>, <a href=/tags>태그</a><br>다른 언어: <a href=https://blog-en.litehell.info hreflang=en>영어 (English)</a></p><style data-emotion="css u1wea8">.css-u1wea8{color:#5e5e5e;font-size:75%}</style><p class=css-u1wea8>글 쓸 때는 AI를 안 씁니다. 전부 직접 씁니다. 만약 오탈자나 어색한 문장이 있다면 퇴고를 대충해서 그런거니 양해 부탁드립니다.</div></header><main><div><style data-emotion="css 1v4sk1e">.css-1v4sk1e{border-bottom:1px solid #999;margin-bottom:.8rem;padding:1.5rem 0 2rem}.css-1v4sk1e .title{margin-bottom:.25rem}.css-1v4sk1e .title *{margin:0;padding:0;display:inline}.css-1v4sk1e .title h2{font-size:2rem;line-height:2.1rem}.css-1v4sk1e .title h3{margin-left:1rem;font-size:1rem;font-weight:200;line-height:1rem}.css-1v4sk1e .datetime{color:#666;margin:0;padding:0}.css-1v4sk1e .links .description{color:#666}</style><div class=css-1v4sk1e><div class=title><h2>Rust와 SDL2</h2><h3>게임 개발에 Rust를 써보셨나요?</h3></div><p class=datetime>2024. 8. 11. 오후 11:35:24에 LiteHell이(가) 작성함.<div class=links><div class=link><span class=description>카테고리: </span><a href=/category/Dev>Dev</a></div><div class=link><span class=description>태그: </span><a href=/tag/Game>Game</a></div></div></div><style data-emotion="css 1wotv8h">.css-1wotv8h{background:#ddd;border:1px solid #666;border-radius:4px;padding:1em}.css-1wotv8h .title,.css-1wotv8h .active{font-weight:600}.css-1wotv8h ul{margin:1em 0 0}</style><nav class=css-1wotv8h><div class=title>(시리즈) 리듬게임 바이드럼 개발기</div><ul><li><a href=/post/my_first_patent>내 첫 특허 출원기</a><li><a class=active href=/post/bidrum_on_rust>Rust와 SDL2</a><li><a href=/post/bidrum_and_janggu_controller_prototyping>쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기</a></ul></nav><style data-emotion="css 1gzdrlg">.css-1gzdrlg{padding:10px;font-size:1rem;line-height:180%}.css-1gzdrlg pre{background:#f0f0f0;border-radius:6px;padding:.5em 1em;overflow-x:auto}.css-1gzdrlg code{font-family:monoscape}.css-1gzdrlg h1{margin:1.8rem 0;font-size:1.8rem}.css-1gzdrlg h1:before{content:"# ";color:#a19c91}.css-1gzdrlg h2{margin:1.6rem 0;font-size:1.6rem}.css-1gzdrlg h2:before{content:"## ";color:#a19c91}.css-1gzdrlg h3{margin:1.4rem 0;font-size:1.4rem}.css-1gzdrlg h3:before{content:"### ";color:#a19c91}.css-1gzdrlg h4{margin:1.2rem 0;font-size:1.2rem}.css-1gzdrlg h5{margin:1.15rem 0;font-size:1.15rem}.css-1gzdrlg h5:before{content:"> ";color:#a19c91}.css-1gzdrlg h6{margin:1.1rem 0;font-size:1.1rem}.css-1gzdrlg h6:before{content:">> ";color:#a19c91}.css-1gzdrlg img,.css-1gzdrlg iframe{max-width:80%;margin:0 auto;display:block}.css-1gzdrlg table{white-space:nowrap;border-collapse:collapse;display:block;overflow-x:auto}.css-1gzdrlg table td,.css-1gzdrlg table tr,.css-1gzdrlg table th{border:1px solid gray}.css-1gzdrlg table th{font-weight:700}.css-1gzdrlg table th,.css-1gzdrlg table td{padding:5px 10px}.css-1gzdrlg table thead{background:#d8d8d8}.css-1gzdrlg blockquote{background:#c2c2c2;border-left:5px solid #4e4e4e;margin:25px 10px 25px 30px;padding:10px 50px}.css-1gzdrlg ul li,.css-1gzdrlg ol li{margin:6px 0}</style><article class=css-1gzdrlg><h1>들어가는 글</h1><p><em>※ 참고: 이 시리즈의 글은 시간순 작성을 최대한 목표하고 있으나, 글의 짜임새나 가독성을 위해 미리시점이나 과거시점의 이야기가 섞이거나 순서가 일부 달라질 수 있습니다.</em><p>내가 만들고 싶은 게임은 아케이드 리듬게임이였다. 마침 내 방에 라즈베리 파이(4B Rev 1.2)가 있어서, 라즈베리 파이로 게임을 구동하고 싶었다. Unity나 Unreal Engine으로 만든 게임이 라즈베리 파이 위에서 돌아갈까? 아마도 돌아가지 않을 것이다. 실제로 돌려본 적은 없지만 라즈베리 파이가 성능이 좋은 편은 아니니까.<p>그래서 필자는 마침 <a href=https://www.rust-lang.org/>Rust</a> 프로그래밍 언어를 한 번 써보고 싶은 생각도 있었기에, Rust로 직접 게임을 만들어보기로 결심했다. 게임 엔진을 쓰면 나중에 게임이 유명해졌을 때 라이선스비를 내야 한다는 것도 하나의 이유였다. (좀 과한 김칫국이긴 하지만...) 그래서 유니티니 언리얼이니 하는 게임 엔진을 쓰지 않고 Rust로 기초부터 쌓아올리기 시작했다.<h1>SDL2를 이용한 게임 프로그래밍</h1><p>Rust에는 <a href=https://github.com/Rust-SDL2/rust-sdl2>rust-sdl2</a>라는 라이브러리 바인딩이 있다. SDL2는 오디오, 키보드, 마우스, 그래픽, 조이스틱을 다를 수 있게 하는 크로스플랫폼 라이브러리이다. 즉, 그래픽이나 마우스 등에 대한 Direct3D/OpenGL 등의 운영체제/플랫폼 종속적인 API를 추상화하고 단일한 인터페이스로 통일하여 크로스 플랫폼으로 개발할 수 있게 하는 라이브러리이다.<p>따라서 SDL2를 이용하면 Mac OS X/Windows/Linux에서 크로스플랫폼으로 실행할 수 있고, 라이브러리도 별로 무겁지 않다. 그래서 SDL2를 이용하게 됐다.<h2>SDL2</h2><p>SDL2는 rust-sdl 레포 내의 예제 코드를 보면서 따라하면 사용하기 쉽다. SDL2는 먼저 Window(창)을 만든 뒤, Window의 Canvas에 원하는 것을 그리고 렌더링하고 클리어하는 것을 반복한다. 이를 순서대로 나타내면 다음과 같다.<blockquote><p>(A) Window 생성 → (B) Window의 Canvas를 Clear한다 → (C) Canvas에 뭔가를 그린다. → (D) Window의 Canvas를 Present한다. → (E) 화면이 표시한다. → (F) B로 되돌아간다.</blockquote><p>학부 수준의 컴퓨터그래픽스 수업을 들었거나 OpenGL 프로그래밍을 조금이라도 맛보았다면 매우 이해하기 쉬울 것이다.<p>SDL2는 키보드나 조이스틱 인식을 위한 EventPump 기능을 제공한다. 키보드 인풋이 들어오면 EventPump에 Event가 생성된다. 게임은 이 EventPump에 Event가 있는지 확인하여 만약 Event가 있다면 해당 Event의 데이터를 활용해 키보드 인풋을 처리할 수 있다. 게임 특성상 이 EventPump은 디버깅 용으로만 주로 이용됐다.<h2>GameCommonContext</h2><p>위에서 언급한 바에 같이 그래픽을 렌더링하기 위해서는 Canvas 객체에 대한 접근이 필요하다. 그래서 초기 게임 초기화시 Canvas와 Window, SDL Context 등을 담은 GameCommonContext 객체를 만들고 이를 함수간에 서로 주고받는 형태로 빠르게 게임을 구현했다.<pre><code class=language-rust><span class=pl-k>use</span> <span class=pl-en>kira</span><span class=pl-k>::</span><span class=pl-en>manager</span><span class=pl-k>::</span><span class=pl-en>AudioManager</span>;
<span class=pl-k>use</span> <span class=pl-en>sdl2</span><span class=pl-k>::</span>{<span class=pl-en>render</span><span class=pl-k>::</span><span class=pl-en>Canvas</span>, <span class=pl-en>EventPump</span>, <span class=pl-en>video</span><span class=pl-k>::</span><span class=pl-en>Window</span>};

<span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-k>struct</span> <span class=pl-en>GameCommonContext</span> {
    <span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-smi>coins</span><span class=pl-k>:</span> <span class=pl-en>u32</span>,
    <span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-smi>price</span><span class=pl-k>:</span> <span class=pl-en>u32</span>,
    <span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-smi>sdl_context</span><span class=pl-k>:</span> <span class=pl-en>sdl2</span><span class=pl-k>::</span><span class=pl-en>Sdl</span>,
    <span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-smi>audio_manager</span><span class=pl-k>:</span> <span class=pl-en>AudioManager</span>,
    <span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-smi>canvas</span><span class=pl-k>:</span> <span class=pl-en>Canvas</span><<span class=pl-en>Window</span>>,
    <span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-smi>event_pump</span><span class=pl-k>:</span> <span class=pl-en>EventPump</span>,
}
</code></pre><p>(속성은 나중에 게임이 개발되면 될 수록 더 늘어난다.)<p>그리고 이는 추후 대규모 리팩토링으로 Rust의 특징을 온몸으로 깨닫는 계기가 됐다.... 나중에 소유권이랑 lifetime 문제가 미친 듯이 터져나와서 그거 씨름하느라 엄청 고생하게 됐다.<h2>Rust에서의 시리얼 통신</h2><p>게임을 장구 하드웨어와 연동하기 위해서는 시리얼 통신이 필요하다.<p>Arduino Leonardo 등 HID 에뮬레이션을 지원하는 보드가 있으면 장구 하드웨어에서 키보드 인풋을 주도록 할 수도 있다. 그런데 당장 내 방에 있는 게 Arduino UNO 호환보드(흔히 "짭두이노"라고 불리는 보드)밖에 없었다. 그래서 시리얼 통신으로 구현했다. 나중의 미래에 레오나르도 보드를 사서 키보드 인풋으로도 구현해보긴 했는데.... 딱따구리마냥 장구 채를 갖다대기만 해도 장구 채를 미친듯이 연타한 것마냥 동작하는 버그가 있어서 그냥 시리얼 통신을 계속 쓰게 됐다.<p>Rust에서는 시리얼 통신을 어떻게 할까? 고맙게도 <a href=https://docs.rs/serialport/latest/serialport/>serialport</a>라는 라이브러리가 있다. 이를 이용해 장구 하드웨어와의 시리얼 통신 코드를 작성했다. 그리고 장구 하드웨어로부터 인풋을 읽는 코드를 멀티쓰레딩으로 분리하고 <code>AtomicU8</code>을 이용하여 게임 쓰레드와 인풋 쓰레드 간에 장구 인풋 상태를 서로 공유했다.<p>왜 뜬끔없이 <code>AtomicU8</code>이냐? 장구 컨트롤러의 상태를 나타내는 데에는 4개의 비트만 있으면 충분하다. 그래서 컨트롤러는 1바이트의 데이터를 무한히 연속적으로 보낸다. 이 1바이트를 해석하는 코드는 다음과 같다.<pre><code class=language-rust><span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-k>fn</span> <span class=pl-en>parse_janggu_bits</span>(<span class=pl-smi>bits</span><span class=pl-k>:</span> <span class=pl-en>u8</span>) <span class=pl-k>-></span> <span class=pl-en>JangguState</span> {
    <span class=pl-en>JangguState</span> {
        궁채<span class=pl-k>:</span> <span class=pl-k>if</span> <span class=pl-smi>bits</span> <span class=pl-k>&</span> <span class=pl-c1>1</span> <span class=pl-k>!=</span> <span class=pl-c1>0</span> {
            <span class=pl-en>Some</span>(<span class=pl-en>DrumPane</span><span class=pl-k>::</span>채편)
        } <span class=pl-k>else</span> <span class=pl-k>if</span> <span class=pl-smi>bits</span> <span class=pl-k>&</span> <span class=pl-c1>2</span> <span class=pl-k>!=</span> <span class=pl-c1>0</span> {
            <span class=pl-en>Some</span>(<span class=pl-en>DrumPane</span><span class=pl-k>::</span>북편)
        } <span class=pl-k>else</span> {
            <span class=pl-en>None</span>
        },
        북채<span class=pl-k>:</span> <span class=pl-k>if</span> <span class=pl-smi>bits</span> <span class=pl-k>&</span> <span class=pl-c1>4</span> <span class=pl-k>!=</span> <span class=pl-c1>0</span> {
            <span class=pl-en>Some</span>(<span class=pl-en>DrumPane</span><span class=pl-k>::</span>채편)
        } <span class=pl-k>else</span> <span class=pl-k>if</span> <span class=pl-smi>bits</span> <span class=pl-k>&</span> <span class=pl-c1>8</span> <span class=pl-k>!=</span> <span class=pl-c1>0</span> {
            <span class=pl-en>Some</span>(<span class=pl-en>DrumPane</span><span class=pl-k>::</span>북편)
        } <span class=pl-k>else</span> {
            <span class=pl-en>None</span>
        },
    }
}
</code></pre><p>장구 컨트롤러와 연동하는 쓰레드는 컨트롤러로부터 시리얼 통신으로 받은 데이터를 바로 <code>GameCommonContext</code> 개체의 <code>janggu_bits_ptr</code> 필드에 저장한다.<pre><code class=language-rust><span class=pl-c>// ... (생략) ....</span>

<span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-k>struct</span> <span class=pl-en>GameCommonContext</span> {
   <span class=pl-c>// ... (생략) ...</span>
   <span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-smi>janggu_bits_ptr</span><span class=pl-k>:</span> <span class=pl-en>Arc</span><<span class=pl-en>AtomicU8</span>>,
}

<span class=pl-k>impl</span> <span class=pl-en>GameCommonContext</span> {
    <span class=pl-k>pub</span>(<span class=pl-k>crate</span>) <span class=pl-k>fn</span> <span class=pl-en>read_janggu_state</span>(<span class=pl-k>&</span><span class=pl-c1>self</span>) <span class=pl-k>-></span> <span class=pl-en>JangguState</span> {
        <span class=pl-k>return</span> <span class=pl-en>parse_janggu_bits</span>(
            <span class=pl-c1>self</span><span class=pl-k>.</span>janggu_bits_ptr
                <span class=pl-k>.</span><span class=pl-en>load</span>(<span class=pl-en>std</span><span class=pl-k>::</span><span class=pl-en>sync</span><span class=pl-k>::</span><span class=pl-en>atomic</span><span class=pl-k>::</span><span class=pl-en>Ordering</span><span class=pl-k>::</span><span class=pl-en>Relaxed</span>),
        );
    }
}

</code></pre><p>게임 쓰레드에서 장구의 상태를 확인할 때는 <code>read_janggu_state</code> 메소드를 이용한다.<p>추후 미래에 <code>AtomicU8</code>을 없애고 Product-Consumer Lock으로 <code>JangguState</code> 객체를 직접 공유해보기도 했는데, 렉이 너무 심해서 그냥 <code>AtomicU8</code>을 계속 쓰게 됐다.<h1>결론</h1><p>Rust를 이용한 게임 개발은 초창기에는 할만했는데 뒤로 갈수록 어려웠다. 소유권, 대여, lifetime 문제를 해결하느라 골머리를 참 많이 썩었다. 그래서 결론적으로 짧은 기간 안에 게임을 개발해야 한다면 Rust는 별로 좋은 선택이 아니지 않을까라는 생각이 들었다.</article><style data-emotion="css ly0ba3">.css-ly0ba3 .utterances{max-width:100%!important}</style><div class=css-ly0ba3><script label="blog comment"async crossorigin issue-term=og:title repo=LiteHell/litehell-blog src=https://utteranc.es/client.js theme=github-light></script></div><style data-emotion="css eyxei3">.css-eyxei3{-webkit-box-flex-wrap:wrap;-webkit-flex-flow:wrap;-ms-flex-flow:wrap;flex-flow:wrap;justify-content:space-between;gap:1em .5em;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-eyxei3 a{-webkit-text-decoration:none;text-decoration:none}.css-eyxei3 .inner{vertical-align:top;display:inline-block}.css-eyxei3 .inner .title{font-size:1.3em;line-height:1.3rem}.css-eyxei3 .inner .subtitle{margin-top:.2rem;font-size:1rem;font-weight:200;line-height:1rem}.css-eyxei3 .inner .date{font-size:.8em;font-weight:200;line-height:.8rem}.css-eyxei3 .next,.css-eyxei3 .previous{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;gap:.5em;width:max-content;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-eyxei3 .next.next,.css-eyxei3 .previous.next{text-align:right;margin-left:auto}.css-eyxei3 .next.previous,.css-eyxei3 .previous.previous{text-align:left}.css-eyxei3 .next .inner,.css-eyxei3 .previous .inner{-webkit-flex:1;-ms-flex:1;flex:1}</style><nav class=css-eyxei3><a class=previous href=/post/caucalendar_1><div class=arrow>❮</div><div class=inner><div class=title>학사일정 ICS 서비스 개발기 (上)</div><div class=subtitle>Javascript랑 함께 Docker로</div><div class=date>2024. 9. 15. 오후 10:06:50</div></div></a><a class=next href=/post/bidrum_and_janggu_controller_prototyping><div class=inner><div class=title>쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기</div><div class=subtitle>학교 캡스톤디자인 작품으로 장구 리듬게임 만든 이야기</div><div class=date>2024. 7. 19. 오후 9:53:12</div></div><div class=arrow>❯</div></a></nav></div></main><style data-emotion="css 19fp2wc">.css-19fp2wc{font-size:.75rem;line-height:.9rem}.css-19fp2wc p{margin:0 0 1em;padding:0}.css-19fp2wc .badges{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;gap:1em;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-19fp2wc .badges img{border-width:0;width:auto;height:3em}</style><footer class=css-19fp2wc><p>Copyright (C) 2020 ~ 2025 Yeonjin Shin (a.k.a. LiteHell), All rights reserved.<br><a href=/license>This blog is free software; For source code and more informations on license and copyrights, Click here.</a><p>Feeds: <a href=/feed/rss>RSS 2.0</a>, <a href=/feed/atom>Atom</a>, <a href=/feed/json>JSON</a><div class=badges><a href=http://creativecommons.org/licenses/by-sa/4.0/ rel=license><img alt="Creative Commons License"src=https://i.creativecommons.org/l/by-sa/4.0/88x31.png><a href=https://www.gnu.org/licenses/agpl-3.0.en.html><img alt="GNU Affero General License Version 3"src=https://www.gnu.org/graphics/agplv3-with-text-100x42.png></a></a></div></footer></div>