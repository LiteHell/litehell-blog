<!DOCTYPE html><html lang="ko-KR"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><link rel="canonical" href="https://blog.litehell.info/post/reinventing_scroll"/><link rel="alternate" type="application/rss+xml" title="RSS 2.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/rss"/><link rel="alternate" type=" application/atom+xml" title="Atom 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/atom"/><link rel="alternate" type="application/feed+json" title="Json 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/json"/><meta property="og:title" content="무한 스크롤 구현하기"/><meta property="og:description" content="신나는 바퀴의 재발명"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="article"/><meta property="og:site_name" content="LiteHell의 블로그"/><meta property="og:url" content="https://blog.litehell.info/post/reinventing_scroll"/><meta property="og:image" content="https://blog.litehell.info/img/reinventing_scroll/screenshot_1.jpg"/><title>LiteHell의 블로그 - <!-- -->무한 스크롤 구현하기</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/vs2015.min.css"/><meta name="next-head-count" content="16"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CZL0E8YDPW"></script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5916984077364289" crossorigin="anonymous"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-CZL0E8YDPW', { page_path: window.location.pathname });
            </script><link rel="preload" href="/_next/static/css/27d177a30947857b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27d177a30947857b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/088d29430e0ecbdb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/088d29430e0ecbdb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-ad45764ecfcae9e5.js" defer=""></script><script src="/_next/static/chunks/main-ee0cf4b7f81d7c24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a96cacb95f41a3ef.js" defer=""></script><script src="/_next/static/chunks/996-c5e5aa4c30f33066.js" defer=""></script><script src="/_next/static/chunks/503-25bfb158f613fce4.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-c55bde140ab34b85.js" defer=""></script><script src="/_next/static/C4IygSzdus1WQT9k-jkf-/_buildManifest.js" defer=""></script><script src="/_next/static/C4IygSzdus1WQT9k-jkf-/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_body__O2_kC"><header class="Layout_header__M_IZ8"><div class="Layout_container__z4qWC"><h1><a href="/">LiteHell의 블로그</a></h1><div class="Layout_outLinks__XBNs_">외부고리 : <a href="https://litehell.info">Homepage</a><a href="https://github.com/LiteHell">GitHub</a><a href="https://linkedin.com/in/LiteHell">LinkedIn</a><a href="https://keybase.io/LiteHell">Keybase</a><a href="mailto:litehell@litehell.info">Email</a></div><div class="Layout_inLinks__f7gmD">내부고리 : <a href="/category">카테고리</a><a href="/tag">태그</a></div></div></header><main class="Layout_mainContainer__5WZfx"><div class="Layout_container__z4qWC"><div class="Blog_header__r4wcZ"><div class="Blog_title___OFu6"><h1>무한 스크롤 구현하기</h1><h2>신나는 바퀴의 재발명</h2></div><p>3/13/2025, 2:57:39 PM<!-- -->에 <!-- -->LiteHell<!-- -->이(가) 작성<!-- -->함<br/><span>카테고리 : <a href="/category/Dev">Dev</a><br/></span><span>태그 : <span class="Blog_tag__RW5VK"><a href="/tag/CSS">CSS</a></span><span class="Blog_tag__RW5VK"><a href="/tag/Frontend">Frontend</a></span><br/></span></p></div><section class="Blog_article__WZp3G"><h1 id="서론">서론</h1>
<p>이 글은 내가 <a href="http://www.shuru.co.kr">주식회사 슈르</a>에서 인턴으로 일하던 2023년 12월 ~ 2024년 2월 사이의 이야기이다.</p>
<p>이때 나는 <a href="https://youtu.be/6WZ5jjVXeF0">고인물테스트</a>(<del><a href="https://goinmultest.pro">https://goinmultest.pro</a></del>, 현재는 운영종료)의 프론트엔드를 개발하고 있었다. (관련 글: <a href="/post/retrospective_of_2024#%ED%95%98%EA%B3%84%EB%B0%A9%ED%95%99-%EC%9D%B8%ED%84%B4%EC%8B%AD">2024년의 회고</a>) 여기서 스크롤 관련하여 삽질을 엄청 많이 하게 됐는데 이에 대하여 다루고자 한다.</p>
<h1 id="본문">본문</h1>
<h2 id="ui-컨셉">UI 컨셉</h2>
<p><a href="https://youtu.be/6WZ5jjVXeF0?t=89">영상</a>을 보자.</p>
<iframe width="912" height="513" src="https://www.youtube.com/embed/6WZ5jjVXeF0" title="✨이벤트有✨ 덕질 하다하다 &#39;이것&#39;까지 만든 슈르네!! 근황" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

<p>영상을 보면 메인 페이지가 다음과 같이 생겼다.</p>
<p><img src="/img/reinventing_scroll/screenshot_1.jpg" alt="메인 페이지"></p>
<p>맨 위 &quot;웹툰&quot;, &quot;HOME&quot;, &quot;K-POP&quot; 버튼은 <strong>카테고리 버튼</strong>이다. 어떤 <strong>카테고리 버튼</strong>이 선택되냐에 따라 아래 표시되는 게시글이 달라진다.</p>
<p><img src="/img/reinventing_scroll/category_nav_button_animation.webp" alt="카테고리 버튼 애니메이션"></p>
<p>컨텐츠는 좌우 방향으로 무한히 스크롤되야 한다. 예를 들자면 왼쪽으로 스크롤을 엄청 많이 해도 끊임없이 컨텐츠가 반복되야 한다.</p>
<p>또한 하단 컨텐츠는 정중앙에 스내핑되야 한다. 영상을 잘 보면 컨텐츠가 스내핑되고 있는 것을 알 수 있다.</p>
<p>이러한 UI를 CSS, JS(추후 화가 나서 TS로 재작성했다), HTML만으로 구현해야 했다.</p>
<h2 id="라이브러리">라이브러리</h2>
<p>남의 돈이 가장 좋듯 코드도 남이 만든 코드를 갖다 쓰는 게 가장 좋다.</p>
<p>저런 UI랑 비슷한 UI는 Carousel이다. (아닐 수도 있다. 만약 필자가 틀리다면 알려주면 감사하겠다.) 그래서 라이브러리르 찾아볼까 했는데</p>
<ol>
<li>컨텐츠가 좌우가 아닌 상하로도 스크롤이 되야하는 특성상 (위 사진 참고) 마음에 드는 라이브러리가 딱히 없었고</li>
<li>라이브러리 괜찮은 건 React로 된 게 많은데 React를 쓰지않고 만들고 있었다.</li>
</ol>
<p>그래서 라이브러리를 딱히 쓰지 않게 됐다. 왜 React나 Vue를 쓰지 않는 지 궁금하다면 <a href="/post/retrospective_of_2024#%ED%95%98%EA%B3%84%EB%B0%A9%ED%95%99-%EC%9D%B8%ED%84%B4%EC%8B%AD">2024년의 회고</a> 글을 보라.</p>
<h2 id="네이티브-스크롤">네이티브 스크롤</h2>
<p>라이브러리가 아무리 노력해도 웹 브라우저가 제공하는 스크롤 기능을 이길 수 없다. 그렇기 때문에 가능하다면 웹 브라우저의 스크롤 기능을 활용하는 게 이득이다.</p>
<p>...이상적으로는 그렇다. 내가 Safari 혐오가 생긴 게 이때부터였다.</p>
<p>처음에 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_scroll_snap">CSS의 <code>scroll-snap</code> 기능</a>을 써보려 했는데 얘는 Gecko랑 Blink에서의 동작이 서로 달랐다. 그러니 패스.</p>
<p>지금 시점에서 정확히 기억나진 않지만 네이티브 스크롤만으로 해결하려 하니 사파리에서 버그가 나거나 크롬에서 버그가 나거나 둘 중 하나인 케이스가 너무 많았다. 아무리 해결하려 해도 답이 없더라....</p>
<p>그래서 결국 네이티브 스크롤을 쓰지 않고 바퀴를 재발명하게 됐다.</p>
<h2 id="좌우-무제한-스크롤의-재발명">좌우 무제한 스크롤의 재발명</h2>
<p>이제 스크롤을 재발명하기로 했다. 어떻게?</p>
<h3 id="컨테이너와-아이템">컨테이너와 아이템</h3>
<p>(이 글에서의 컨텐츠 = 이미지에서의 &quot;post&quot;이다.)</p>
<p>일단 카테고리 버튼은 신경쓰지 말고 컨텐츠만 집중해보자. 컨테이너의 자식을 아이템이라 하자. 아래와 같이 컨테이너와 아이템이 있다. 핑크색이 컨테이너고 청록색이 아이템이다. 컨테이너 바깥에 위치한 아이템은 보이지 않으며, 컨텐츠 컨테이너의 너비와 컨텐츠 아이템의 너비는 항상 동일하다고 가정하자.</p>
<p><img src="/img/reinventing_scroll/container_and_items_1.png" alt="컨테이너와 아이템들"></p>
<p>이용자가 좌우로 스크롤을 하면 이용자의 스크롤에 따라 아이템들의 위치를 모두 동일하게 이동시킨다.</p>
<p><img src="/img/reinventing_scroll/container_and_items_2.png" alt="이동된 컨테이너와 아이템들"></p>
<p>그러면 컨테이너 외부의 아이템은 보이지 않으므로, 이용자에게는 좌우 스크롤이 되는 것처럼 보여진다.</p>
<h3 id="css와-transform">CSS와 transform</h3>
<p><code>position</code>이 <code>absolute</code>인 요소는 조상 요소중 <code>position</code>이 <code>relative</code>이거나 <code>absolute</code>인 가장 가까운 요소를 기준으로 위치가 결정된다는 것은 CSS 상식이다.</p>
<p>컨테이너의 <code>position</code>을 <code>relative</code>로 하고, 아이템에 다음과 같은 CSS를 적용하자.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">absolute</span>;
<span class="hljs-selector-tag">top</span>: 0<span class="hljs-selector-tag">px</span>;
<span class="hljs-selector-tag">left</span>: 50%;</code></pre>
<p>그러면 사진과 같이 모든 아이템이 컨테이너의 정중앙으로 정렬된다.</p>
<p><img src="/img/reinventing_scroll/container_and_items_centered.png" alt="정중앙에 위치된 아이템들"></p>
<p>우리 이제 여기서 생각을 잠깐 해보자. 저 정중앙에 위치된 아이템을 좌우로 각각 &quot;적절히&quot; 이동시키면 아래와 같은 이미지들을 구현할 수 있지 않을까?</p>
<p><img src="/img/reinventing_scroll/container_and_items_1.png" alt="컨테이너와 아이템들"></p>
<p><img src="/img/reinventing_scroll/container_and_items_2.png" alt="이동된 컨테이너와 아이템들"></p>
<p>여기서 <code>transform</code>이 등장한다. <code>transform</code>에 <code>translateX</code> 함수를 이용하면 특정 HTML 요소를 X축으로 이동시킬 수 있다.</p>
<p>위 이미지를 프레임이라 할 때, 컨텐츠 아이템들의 X축 위치는 다음 두가지 정보로부터 유도될 수 있음은 자명하다. </p>
<ol>
<li>컨테이너의 정중앙에 가장 가까운 컨텐츠가 어떤 컨텐츠인지</li>
<li>1번의 컨텐츠가 컨테이너의 정중앙으로부터 얼마나 떨어져 있는지의 방향(왼쪽/오른쪽)과 거리를 가진 값</li>
</ol>
<p>이에 대하여 코드에 상세히 설명한 주석이 있다. 그 주석은 다음과 같다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
         * 2개의 예시로 알아보는 translate값 계산 알고리즘
         * 참고: 모든 예시에서 root의 너비=child를 가정함.
         *
         * 첫번째 예시
         *           ________________
         * 1. 위와 같이 너비 16px의 root가 있다고 가정한다.
         *
         *           __AAAAAAAAAAAAAA(AA) ※ 괄호안은 root 영역의 바깥에 있으므로 보이지 않는다.
         * 2. basisChildOffset=2, basisChildIndex=(A의 index)라고 가정하고
         *    basisChild의 translate값을 2로 설정한다.
         *
         * 3. root 영역을 보자. root 영역의 왼쪽에는 2px의 여백이 있으며 오른쪽에는 여백이 없다.
         *
         *           (BBBBBBBBBBBBBB)BBAAAAAAAAAAAAAA(AA) ※ 괄호안은 root 영역의 바깥에 있으므로 보이지 않는다.
         * 4. 왼쪽 여백을 채우기 위해 A의 왼쪽에 B가 나타나도록 B의 translate값을 설정한다.
         *
         *           BBAAAAAAAAAAAAAA
         * 5, 끝!
         *
         * 두번째 예시
         *          ________
         * `1. 위와 같이 너비 8px의 root가 있고, 3개의 child A, B, C가 있다고 가정한다.
         *
         *          ________                                (AAAAAAAA) ※ 괄호안은 root 영역의 바깥에 있으므로 보이지 않는다.
         *  2. basisChildOffset=36, basisChildIndex=(A의 offset)라고 가정하고
         *     basisChild의 translate값을 40으로 설정한다.
         *
         *  3. root 영역이 비어있다.
         *
         *          ________                        (CCCCCCCCAAAAAAAA) ※ 괄호안은 root 영역의 바깥에 있으므로 보이지 않는다.
         *          ________                (BBBBBBBBCCCCCCCCAAAAAAAA)
         *          ________        (AAAAAAAABBBBBBBBCCCCCCCC)
         *          ________(CCCCCCCCAAAAAAAABBBBBBBB)
         *          BBBBBBBB(CCCCCCCCAAAAAAAA)
         *  4. 위와 같이 루프를 돌면서 root영역을 채운다.
         *
         *          BBBBBBBB
         * 5. 끝!
         */</span></code></pre>
<p>위 주석을 요약하면 다음과 같다.</p>
<ol>
<li>위에서 말한 두가지 정보로 정중앙에서 가장 가까운 아이템을 X축 이동시킨다.</li>
<li>컨테이너의 영역을 꽉 채울 때까지 아이템을 하나하나씩 X축으로 이동시킨다.</li>
</ol>
<p>이제 스크롤의 의미가 바꿨다. 스크롤은 이용자의 상호작용에 따라 &quot;컨테이너의 정중앙에서 가장 가까운 아이템과 컨테이너와의 거리&quot;를 적절히 변경하는 방식으로 구현될 수 있다.</p>
<p>(&quot;컨테이너의 정중앙에서 가장 가까운 아이템의 종류&quot;는 내부적으로 자동 정규화(normalization)된다고 가정하자)</p>
<h3 id="관성-스크롤">관성 스크롤</h3>
<p>스크롤을 재발명한다는 것은 관성 스크롤(&quot;Kinetic scrolling&quot;, &quot;Inertial scrolling&quot;, 혹은 &quot;Momentum scrolling&quot;이라 불린다)을 재발명하는 것과 같다.</p>
<p>이에 대해서는 Ariya Hidayat씨의 <a href="https://ariya.io/2013/08/javascript-kinetic-scrolling-part-1">Javascript Kinetic Scrolling</a>의 도움을 매우 많이 받았다. 이용자가 X축으로 이동한 만큼 스크롤하되 내부적으로는 속도를 계산한다. 속도를 계산할 때는 이동평균하여 값이 튀지 않도록 보정한다.</p>
<p>터치가 끝났을 때 속도와 터치 방향을 확인하여 속도가 특정값 이상이고 방향이 알맞다면 다음 아이템으로 자동 스크롤하고 아닌 경우에는 원래 아이템으로 자동 스크롤하도록 구현한다. (어처피 스내핑해야 하므로 이렇게 구현해도 상관없다.)</p>
<h2 id="컨텐츠-내부에서의-상하-스크롤">컨텐츠 내부에서의 상하 스크롤</h2>
<p><a href="https://github.com/idiotWu/smooth-scrollbar">smooth-scrollbar</a> 라이브러리를 갖다 붙였거나 브라우저의 네이티브 스크롤를 이용하거나 둘 중 하나였던 거 같은데 정확히는 기억나지 않는다.</p>
<h2 id="카테고리-버튼과의-연동">카테고리 버튼과의 연동</h2>
<p>카테고리 버튼도 좌우로 스크롤 가능하고, 이용자가 스크롤하는 만큼 컨텐츠도 좌우로 움직여졌으면 좋겠다는 요구사항이 있었다.</p>
<p>그러면 컨텐츠와 카테코리 버튼의 상태가 양방향으로 연결되야 한다. 카테고리 버튼이 좌우로 스크롤되면 컨텐츠도 좌우로 스크롤되고, 컨텐츠가 좌우로 스크롤되면 카테고리 버튼도 스크롤되야 한다.</p>
<p>근데 이렇게 하니 버그가 기가 막히더라. 그래서 그냥 컨텐츠가 좌우로 스크롤될 때만 카테고리 버튼이 같이 스크롤되도록 하고, 카테고리 버튼은 그냥 이용자가 직접 좌우 스크롤할 수 없도록 막았다. (위에 첨부한 사진을 자세히 보면 버튼을 스크롤하는 것이 아닌 &quot;클릭&quot;하고 있다는 걸 알 수 있다.)</p>
<h1 id="결론">결론</h1>
<p>이때를 기점으로 사파리 혐오가 생겼다. 버그 잡느라 되게 힘들었는데 그래도 돌이켜보면 재미있는 경험이었다.</p>
<p>잔버그 고치는 데 시간을 많이 썼다. 다만 커밋 로그 하나하나 보면서 블로그 글 쓰고 싶진 않아서 이 글에서는 생략했다.</p>
<p>웹에서 네이티브 어플리케이션 수준의 UX/UI를 구현하는 건 매우 힘들다는 걸 느끼게 됐다. 세상 일이 참 쉽지가 않다.</p>
<p>비록 퇴사했지만 언제나 번창했으면 좋겠다.</p>
</section><div class="Comments_blogComments__GRWmY"></div><nav class="Blog_postNav__ivy8_"><div class="Blog_leftAnchor__HhzIP"><a href="/post/cups_monochrome_printing_bug"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">리눅스에서 인쇄가 흑백으로만 되는 CUPS 버그</div><div class="Blog_subtitle__RRFh7">아니 왜 색이 안나와</div></div></a></div><div class="Blog_nothing__mDnAo"></div></nav></div></main><footer class="Layout_footer__bKkxe"><div class="Layout_container__z4qWC"><a href="https://www.gnu.org/licenses/agpl-3.0.en.html"><img alt="GNU Affero General License Version 3" src="https://www.gnu.org/graphics/agplv3-with-text-100x42.png" style="height:31px"/></a> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a><br/>Copyrights (C) 2020 ~ 2024 LiteHell, All rights reserved.<br/><div class="Layout_visibleOnPrintOnly__UK6Yl">LiteHell&#x27;s Blog - <a href="https://blog.litehell.info">https://blog.litehell.info</a><br/>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.<br/><br/>Url of this article: <a href="https://blog.litehell.info/post/reinventing_scroll">https://blog.litehell.info/post/reinventing_scroll</a><br/></div><div class="Layout_invisibleOnPrint__rdrDv">Fox Image : Copyrights (C) 2004 Shiretoko-Shari Torurist Association<br/><a href="/license">This blog is free software; For source code and more informations on license and copyrights, Click here.</a><br/><br/>Feeds : <a href="/feed/rss">RSS 2.0</a>,<!-- --> <a href="/feed/atom">Atom 1.0</a>, <a href="/feed/json">Json 1.0</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"metadata":{"title":"무한 스크롤 구현하기","subtitle":"신나는 바퀴의 재발명","author":"LiteHell","date":"2025-03-13T14:57:39.688Z","category":"Dev","tags":["CSS","Frontend"]},"rendered":"\u003ch1 id=\"서론\"\u003e서론\u003c/h1\u003e\n\u003cp\u003e이 글은 내가 \u003ca href=\"http://www.shuru.co.kr\"\u003e주식회사 슈르\u003c/a\u003e에서 인턴으로 일하던 2023년 12월 ~ 2024년 2월 사이의 이야기이다.\u003c/p\u003e\n\u003cp\u003e이때 나는 \u003ca href=\"https://youtu.be/6WZ5jjVXeF0\"\u003e고인물테스트\u003c/a\u003e(\u003cdel\u003e\u003ca href=\"https://goinmultest.pro\"\u003ehttps://goinmultest.pro\u003c/a\u003e\u003c/del\u003e, 현재는 운영종료)의 프론트엔드를 개발하고 있었다. (관련 글: \u003ca href=\"/post/retrospective_of_2024#%ED%95%98%EA%B3%84%EB%B0%A9%ED%95%99-%EC%9D%B8%ED%84%B4%EC%8B%AD\"\u003e2024년의 회고\u003c/a\u003e) 여기서 스크롤 관련하여 삽질을 엄청 많이 하게 됐는데 이에 대하여 다루고자 한다.\u003c/p\u003e\n\u003ch1 id=\"본문\"\u003e본문\u003c/h1\u003e\n\u003ch2 id=\"ui-컨셉\"\u003eUI 컨셉\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://youtu.be/6WZ5jjVXeF0?t=89\"\u003e영상\u003c/a\u003e을 보자.\u003c/p\u003e\n\u003ciframe width=\"912\" height=\"513\" src=\"https://www.youtube.com/embed/6WZ5jjVXeF0\" title=\"✨이벤트有✨ 덕질 하다하다 \u0026#39;이것\u0026#39;까지 만든 슈르네!! 근황\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen\u003e\u003c/iframe\u003e\n\n\u003cp\u003e영상을 보면 메인 페이지가 다음과 같이 생겼다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/reinventing_scroll/screenshot_1.jpg\" alt=\"메인 페이지\"\u003e\u003c/p\u003e\n\u003cp\u003e맨 위 \u0026quot;웹툰\u0026quot;, \u0026quot;HOME\u0026quot;, \u0026quot;K-POP\u0026quot; 버튼은 \u003cstrong\u003e카테고리 버튼\u003c/strong\u003e이다. 어떤 \u003cstrong\u003e카테고리 버튼\u003c/strong\u003e이 선택되냐에 따라 아래 표시되는 게시글이 달라진다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/reinventing_scroll/category_nav_button_animation.webp\" alt=\"카테고리 버튼 애니메이션\"\u003e\u003c/p\u003e\n\u003cp\u003e컨텐츠는 좌우 방향으로 무한히 스크롤되야 한다. 예를 들자면 왼쪽으로 스크롤을 엄청 많이 해도 끊임없이 컨텐츠가 반복되야 한다.\u003c/p\u003e\n\u003cp\u003e또한 하단 컨텐츠는 정중앙에 스내핑되야 한다. 영상을 잘 보면 컨텐츠가 스내핑되고 있는 것을 알 수 있다.\u003c/p\u003e\n\u003cp\u003e이러한 UI를 CSS, JS(추후 화가 나서 TS로 재작성했다), HTML만으로 구현해야 했다.\u003c/p\u003e\n\u003ch2 id=\"라이브러리\"\u003e라이브러리\u003c/h2\u003e\n\u003cp\u003e남의 돈이 가장 좋듯 코드도 남이 만든 코드를 갖다 쓰는 게 가장 좋다.\u003c/p\u003e\n\u003cp\u003e저런 UI랑 비슷한 UI는 Carousel이다. (아닐 수도 있다. 만약 필자가 틀리다면 알려주면 감사하겠다.) 그래서 라이브러리르 찾아볼까 했는데\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e컨텐츠가 좌우가 아닌 상하로도 스크롤이 되야하는 특성상 (위 사진 참고) 마음에 드는 라이브러리가 딱히 없었고\u003c/li\u003e\n\u003cli\u003e라이브러리 괜찮은 건 React로 된 게 많은데 React를 쓰지않고 만들고 있었다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e그래서 라이브러리를 딱히 쓰지 않게 됐다. 왜 React나 Vue를 쓰지 않는 지 궁금하다면 \u003ca href=\"/post/retrospective_of_2024#%ED%95%98%EA%B3%84%EB%B0%A9%ED%95%99-%EC%9D%B8%ED%84%B4%EC%8B%AD\"\u003e2024년의 회고\u003c/a\u003e 글을 보라.\u003c/p\u003e\n\u003ch2 id=\"네이티브-스크롤\"\u003e네이티브 스크롤\u003c/h2\u003e\n\u003cp\u003e라이브러리가 아무리 노력해도 웹 브라우저가 제공하는 스크롤 기능을 이길 수 없다. 그렇기 때문에 가능하다면 웹 브라우저의 스크롤 기능을 활용하는 게 이득이다.\u003c/p\u003e\n\u003cp\u003e...이상적으로는 그렇다. 내가 Safari 혐오가 생긴 게 이때부터였다.\u003c/p\u003e\n\u003cp\u003e처음에 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_scroll_snap\"\u003eCSS의 \u003ccode\u003escroll-snap\u003c/code\u003e 기능\u003c/a\u003e을 써보려 했는데 얘는 Gecko랑 Blink에서의 동작이 서로 달랐다. 그러니 패스.\u003c/p\u003e\n\u003cp\u003e지금 시점에서 정확히 기억나진 않지만 네이티브 스크롤만으로 해결하려 하니 사파리에서 버그가 나거나 크롬에서 버그가 나거나 둘 중 하나인 케이스가 너무 많았다. 아무리 해결하려 해도 답이 없더라....\u003c/p\u003e\n\u003cp\u003e그래서 결국 네이티브 스크롤을 쓰지 않고 바퀴를 재발명하게 됐다.\u003c/p\u003e\n\u003ch2 id=\"좌우-무제한-스크롤의-재발명\"\u003e좌우 무제한 스크롤의 재발명\u003c/h2\u003e\n\u003cp\u003e이제 스크롤을 재발명하기로 했다. 어떻게?\u003c/p\u003e\n\u003ch3 id=\"컨테이너와-아이템\"\u003e컨테이너와 아이템\u003c/h3\u003e\n\u003cp\u003e(이 글에서의 컨텐츠 = 이미지에서의 \u0026quot;post\u0026quot;이다.)\u003c/p\u003e\n\u003cp\u003e일단 카테고리 버튼은 신경쓰지 말고 컨텐츠만 집중해보자. 컨테이너의 자식을 아이템이라 하자. 아래와 같이 컨테이너와 아이템이 있다. 핑크색이 컨테이너고 청록색이 아이템이다. 컨테이너 바깥에 위치한 아이템은 보이지 않으며, 컨텐츠 컨테이너의 너비와 컨텐츠 아이템의 너비는 항상 동일하다고 가정하자.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/reinventing_scroll/container_and_items_1.png\" alt=\"컨테이너와 아이템들\"\u003e\u003c/p\u003e\n\u003cp\u003e이용자가 좌우로 스크롤을 하면 이용자의 스크롤에 따라 아이템들의 위치를 모두 동일하게 이동시킨다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/reinventing_scroll/container_and_items_2.png\" alt=\"이동된 컨테이너와 아이템들\"\u003e\u003c/p\u003e\n\u003cp\u003e그러면 컨테이너 외부의 아이템은 보이지 않으므로, 이용자에게는 좌우 스크롤이 되는 것처럼 보여진다.\u003c/p\u003e\n\u003ch3 id=\"css와-transform\"\u003eCSS와 transform\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eposition\u003c/code\u003e이 \u003ccode\u003eabsolute\u003c/code\u003e인 요소는 조상 요소중 \u003ccode\u003eposition\u003c/code\u003e이 \u003ccode\u003erelative\u003c/code\u003e이거나 \u003ccode\u003eabsolute\u003c/code\u003e인 가장 가까운 요소를 기준으로 위치가 결정된다는 것은 CSS 상식이다.\u003c/p\u003e\n\u003cp\u003e컨테이너의 \u003ccode\u003eposition\u003c/code\u003e을 \u003ccode\u003erelative\u003c/code\u003e로 하고, 아이템에 다음과 같은 CSS를 적용하자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-css\"\u003e\u003cspan class=\"hljs-selector-tag\"\u003eposition\u003c/span\u003e: \u003cspan class=\"hljs-selector-tag\"\u003eabsolute\u003c/span\u003e;\n\u003cspan class=\"hljs-selector-tag\"\u003etop\u003c/span\u003e: 0\u003cspan class=\"hljs-selector-tag\"\u003epx\u003c/span\u003e;\n\u003cspan class=\"hljs-selector-tag\"\u003eleft\u003c/span\u003e: 50%;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 사진과 같이 모든 아이템이 컨테이너의 정중앙으로 정렬된다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/reinventing_scroll/container_and_items_centered.png\" alt=\"정중앙에 위치된 아이템들\"\u003e\u003c/p\u003e\n\u003cp\u003e우리 이제 여기서 생각을 잠깐 해보자. 저 정중앙에 위치된 아이템을 좌우로 각각 \u0026quot;적절히\u0026quot; 이동시키면 아래와 같은 이미지들을 구현할 수 있지 않을까?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/reinventing_scroll/container_and_items_1.png\" alt=\"컨테이너와 아이템들\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/reinventing_scroll/container_and_items_2.png\" alt=\"이동된 컨테이너와 아이템들\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 \u003ccode\u003etransform\u003c/code\u003e이 등장한다. \u003ccode\u003etransform\u003c/code\u003e에 \u003ccode\u003etranslateX\u003c/code\u003e 함수를 이용하면 특정 HTML 요소를 X축으로 이동시킬 수 있다.\u003c/p\u003e\n\u003cp\u003e위 이미지를 프레임이라 할 때, 컨텐츠 아이템들의 X축 위치는 다음 두가지 정보로부터 유도될 수 있음은 자명하다. \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e컨테이너의 정중앙에 가장 가까운 컨텐츠가 어떤 컨텐츠인지\u003c/li\u003e\n\u003cli\u003e1번의 컨텐츠가 컨테이너의 정중앙으로부터 얼마나 떨어져 있는지의 방향(왼쪽/오른쪽)과 거리를 가진 값\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이에 대하여 코드에 상세히 설명한 주석이 있다. 그 주석은 다음과 같다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n         * 2개의 예시로 알아보는 translate값 계산 알고리즘\n         * 참고: 모든 예시에서 root의 너비=child를 가정함.\n         *\n         * 첫번째 예시\n         *           ________________\n         * 1. 위와 같이 너비 16px의 root가 있다고 가정한다.\n         *\n         *           __AAAAAAAAAAAAAA(AA) ※ 괄호안은 root 영역의 바깥에 있으므로 보이지 않는다.\n         * 2. basisChildOffset=2, basisChildIndex=(A의 index)라고 가정하고\n         *    basisChild의 translate값을 2로 설정한다.\n         *\n         * 3. root 영역을 보자. root 영역의 왼쪽에는 2px의 여백이 있으며 오른쪽에는 여백이 없다.\n         *\n         *           (BBBBBBBBBBBBBB)BBAAAAAAAAAAAAAA(AA) ※ 괄호안은 root 영역의 바깥에 있으므로 보이지 않는다.\n         * 4. 왼쪽 여백을 채우기 위해 A의 왼쪽에 B가 나타나도록 B의 translate값을 설정한다.\n         *\n         *           BBAAAAAAAAAAAAAA\n         * 5, 끝!\n         *\n         * 두번째 예시\n         *          ________\n         * `1. 위와 같이 너비 8px의 root가 있고, 3개의 child A, B, C가 있다고 가정한다.\n         *\n         *          ________                                (AAAAAAAA) ※ 괄호안은 root 영역의 바깥에 있으므로 보이지 않는다.\n         *  2. basisChildOffset=36, basisChildIndex=(A의 offset)라고 가정하고\n         *     basisChild의 translate값을 40으로 설정한다.\n         *\n         *  3. root 영역이 비어있다.\n         *\n         *          ________                        (CCCCCCCCAAAAAAAA) ※ 괄호안은 root 영역의 바깥에 있으므로 보이지 않는다.\n         *          ________                (BBBBBBBBCCCCCCCCAAAAAAAA)\n         *          ________        (AAAAAAAABBBBBBBBCCCCCCCC)\n         *          ________(CCCCCCCCAAAAAAAABBBBBBBB)\n         *          BBBBBBBB(CCCCCCCCAAAAAAAA)\n         *  4. 위와 같이 루프를 돌면서 root영역을 채운다.\n         *\n         *          BBBBBBBB\n         * 5. 끝!\n         */\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 주석을 요약하면 다음과 같다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e위에서 말한 두가지 정보로 정중앙에서 가장 가까운 아이템을 X축 이동시킨다.\u003c/li\u003e\n\u003cli\u003e컨테이너의 영역을 꽉 채울 때까지 아이템을 하나하나씩 X축으로 이동시킨다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이제 스크롤의 의미가 바꿨다. 스크롤은 이용자의 상호작용에 따라 \u0026quot;컨테이너의 정중앙에서 가장 가까운 아이템과 컨테이너와의 거리\u0026quot;를 적절히 변경하는 방식으로 구현될 수 있다.\u003c/p\u003e\n\u003cp\u003e(\u0026quot;컨테이너의 정중앙에서 가장 가까운 아이템의 종류\u0026quot;는 내부적으로 자동 정규화(normalization)된다고 가정하자)\u003c/p\u003e\n\u003ch3 id=\"관성-스크롤\"\u003e관성 스크롤\u003c/h3\u003e\n\u003cp\u003e스크롤을 재발명한다는 것은 관성 스크롤(\u0026quot;Kinetic scrolling\u0026quot;, \u0026quot;Inertial scrolling\u0026quot;, 혹은 \u0026quot;Momentum scrolling\u0026quot;이라 불린다)을 재발명하는 것과 같다.\u003c/p\u003e\n\u003cp\u003e이에 대해서는 Ariya Hidayat씨의 \u003ca href=\"https://ariya.io/2013/08/javascript-kinetic-scrolling-part-1\"\u003eJavascript Kinetic Scrolling\u003c/a\u003e의 도움을 매우 많이 받았다. 이용자가 X축으로 이동한 만큼 스크롤하되 내부적으로는 속도를 계산한다. 속도를 계산할 때는 이동평균하여 값이 튀지 않도록 보정한다.\u003c/p\u003e\n\u003cp\u003e터치가 끝났을 때 속도와 터치 방향을 확인하여 속도가 특정값 이상이고 방향이 알맞다면 다음 아이템으로 자동 스크롤하고 아닌 경우에는 원래 아이템으로 자동 스크롤하도록 구현한다. (어처피 스내핑해야 하므로 이렇게 구현해도 상관없다.)\u003c/p\u003e\n\u003ch2 id=\"컨텐츠-내부에서의-상하-스크롤\"\u003e컨텐츠 내부에서의 상하 스크롤\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/idiotWu/smooth-scrollbar\"\u003esmooth-scrollbar\u003c/a\u003e 라이브러리를 갖다 붙였거나 브라우저의 네이티브 스크롤를 이용하거나 둘 중 하나였던 거 같은데 정확히는 기억나지 않는다.\u003c/p\u003e\n\u003ch2 id=\"카테고리-버튼과의-연동\"\u003e카테고리 버튼과의 연동\u003c/h2\u003e\n\u003cp\u003e카테고리 버튼도 좌우로 스크롤 가능하고, 이용자가 스크롤하는 만큼 컨텐츠도 좌우로 움직여졌으면 좋겠다는 요구사항이 있었다.\u003c/p\u003e\n\u003cp\u003e그러면 컨텐츠와 카테코리 버튼의 상태가 양방향으로 연결되야 한다. 카테고리 버튼이 좌우로 스크롤되면 컨텐츠도 좌우로 스크롤되고, 컨텐츠가 좌우로 스크롤되면 카테고리 버튼도 스크롤되야 한다.\u003c/p\u003e\n\u003cp\u003e근데 이렇게 하니 버그가 기가 막히더라. 그래서 그냥 컨텐츠가 좌우로 스크롤될 때만 카테고리 버튼이 같이 스크롤되도록 하고, 카테고리 버튼은 그냥 이용자가 직접 좌우 스크롤할 수 없도록 막았다. (위에 첨부한 사진을 자세히 보면 버튼을 스크롤하는 것이 아닌 \u0026quot;클릭\u0026quot;하고 있다는 걸 알 수 있다.)\u003c/p\u003e\n\u003ch1 id=\"결론\"\u003e결론\u003c/h1\u003e\n\u003cp\u003e이때를 기점으로 사파리 혐오가 생겼다. 버그 잡느라 되게 힘들었는데 그래도 돌이켜보면 재미있는 경험이었다.\u003c/p\u003e\n\u003cp\u003e잔버그 고치는 데 시간을 많이 썼다. 다만 커밋 로그 하나하나 보면서 블로그 글 쓰고 싶진 않아서 이 글에서는 생략했다.\u003c/p\u003e\n\u003cp\u003e웹에서 네이티브 어플리케이션 수준의 UX/UI를 구현하는 건 매우 힘들다는 걸 느끼게 됐다. 세상 일이 참 쉽지가 않다.\u003c/p\u003e\n\u003cp\u003e비록 퇴사했지만 언제나 번창했으면 좋겠다.\u003c/p\u003e\n"},"articleId":"reinventing_scroll","previousPost":{"name":"cups_monochrome_printing_bug","metadata":{"title":"리눅스에서 인쇄가 흑백으로만 되는 CUPS 버그","subtitle":"아니 왜 색이 안나와","author":"LiteHell","date":"2025-03-12T15:12:14.190Z","category":"Linux","tags":["CUPS"]},"rendered":"\u003ch1 id=\"개요\"\u003e개요\u003c/h1\u003e\n\u003cp\u003e당근마켓에서 복합기를 샀다.\u003c/p\u003e\n\u003cp\u003eCUPS 서버를 구축해 프린터를 공유하고 테스트 페이지를 인쇄했는데 인쇄가 모노크롬(회색조)으로만 인쇄됐다. 왜일까...\u003c/p\u003e\n\u003ch1 id=\"해결법\"\u003e해결법\u003c/h1\u003e\n\u003cp\u003e열심히 검색하면서 찾아본 결과 CUPS에서 프린터를 추가할 때 회색조 인쇄를 기본값으로 하는 버그가 있어서 그렇다.\u003c/p\u003e\n\u003cp\u003e아래 명령어에서 PRINTER 부분만 프린터 이름으로 바꿔서 실행하면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo lpadmin -p PRINTER -o print-color-mode-default=color\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e끝~\u003c/p\u003e\n\u003ch1 id=\"참고-문서\"\u003e참고 문서\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://askubuntu.com/a/1416784\"\u003eStackoverflow 답변\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"reinventing_scroll"},"buildId":"C4IygSzdus1WQT9k-jkf-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>