<!doctypehtml><link href=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 rel=icon><link href=https://blog.litehell.info/post/min_max_heap rel=canonical><link title="RSS 2.0 Feed for blog.litehell.info"href=https://blog.litehell.info/feed/rss rel=alternate type=application/rss+xml><link title="Atom 1.0 Feed for blog.litehell.info"type="	application/atom+xml"href=https://blog.litehell.info/feed/atom rel=alternate><link title="Json 1.0 Feed for blog.litehell.info"href=https://blog.litehell.info/feed/json rel=alternate type=application/feed+json><link href=https://esm.sh/@wooorm/starry-night@3/style/both.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap rel=stylesheet><meta content="최소-최대 힙(Min-max heap) 구현하기 (백준 7662번 이중 우선순위 큐 문제)"property=og:title><meta content="최소값과 최대값을 동시에 구할 수 있는 힙 자료구조"property=og:description><meta content=ko_KR property=og:locale><meta content=blog property=og:type><meta content="LiteHell의 블로그"property=og:site_name><meta content=https://blog.litehell.info/post/min_max_heap property=og:url><meta content=https://blog.litehell.info/example.svg property=og:image><meta content=width=device-width,initial-scale=1 name=viewport><style>html,body{margin:0;padding:0;font-family:Noto Sans KR,sans-serif}</style><title>LiteHell의 블로그 - 최소-최대 힙(Min-max heap) 구현하기 (백준 7662번 이중 우선순위 큐 문제)</title><body><link as=image href=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1 rel=preload><link as=image href=https://i.creativecommons.org/l/by-sa/4.0/88x31.png rel=preload><link as=image href=https://www.gnu.org/graphics/agplv3-with-text-100x42.png rel=preload><style data-emotion="css 1nfpw07">.css-1nfpw07{--top-padding:max(40px,3rem);--vertical-padding:max(20px,2em);padding:var(--top-padding)var(--vertical-padding)0em var(--vertical-padding);box-sizing:border-box;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;align-items:center;min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-1nfpw07>*{width:100%}@media (width>=1024px){.css-1nfpw07>*{max-width:960px}}.css-1nfpw07 main{-webkit-flex:1;-ms-flex:1;flex:1}.css-1nfpw07 footer{border-top:1px solid #727272;margin:2rem 0 0;padding:1.5rem 0}</style><div class=css-1nfpw07><style data-emotion="css 1fkv74n">.css-1fkv74n{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;align-items:center;gap:2rem;padding-bottom:1.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}@media (width<=25rem){.css-1fkv74n{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}}.css-1fkv74n .profileImg a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.css-1fkv74n .profileImg img{border-radius:4rem;width:8rem;height:8rem;box-shadow:0 3px 6px #00000029,0 3px 6px #0000003b}.css-1fkv74n .title h1{word-break:keep-all;margin:0 0 .5rem;padding:0;font-size:2rem;line-height:2.5rem}.css-1fkv74n .title h1 a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.css-1fkv74n .links{margin:0;padding:0;font-size:.9rem;line-height:1.2rem}@media (width<=1023px){.css-1fkv74n .title h1{font-size:1.5rem;line-height:2rem}.css-1fkv74n .rounded img{border-radius:3.5rem 3.4rem;width:7rem;height:7rem}}</style><header class=css-1fkv74n><div class=profileImg><a href=/><img alt="LiteHell의 Gravatar 아이콘"src=https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1></a></div><div class=title><h1><a href=/>LiteHell의 블로그</a></h1><p class=links>외부고리: <a href=https://github.com/litehell>GitHub</a>, <a href=https://yeonjin.name/portfolio>Portfolio</a><br>내부고리: <a href=/categories>카테고리</a>, <a href=/tags>태그</a></div></header><main><div><style data-emotion="css 1v4sk1e">.css-1v4sk1e{border-bottom:1px solid #999;margin-bottom:.8rem;padding:1.5rem 0 2rem}.css-1v4sk1e .title{margin-bottom:.25rem}.css-1v4sk1e .title *{margin:0;padding:0;display:inline}.css-1v4sk1e .title h2{font-size:2rem;line-height:2.1rem}.css-1v4sk1e .title h3{margin-left:1rem;font-size:1rem;font-weight:200;line-height:1rem}.css-1v4sk1e .datetime{color:#666;margin:0;padding:0}.css-1v4sk1e .links .description{color:#666}</style><div class=css-1v4sk1e><div class=title><h2>최소-최대 힙(Min-max heap) 구현하기 (백준 7662번 이중 우선순위 큐 문제)</h2><h3>최소값과 최대값을 동시에 구할 수 있는 힙 자료구조</h3></div><p class=datetime>2023. 5. 4. 오전 12:24:12에 LiteHell이(가) 편집함.<div class=links><div class=link><span class=description>카테고리: </span><a href="/category/Dev (PS)">Dev (PS)</a></div><div class=link><span class=description>테그: </span><a href=/tag/Heap>Heap</a></div></div></div><style data-emotion="css 1gzdrlg">.css-1gzdrlg{padding:10px;font-size:1rem;line-height:180%}.css-1gzdrlg pre{background:#f0f0f0;border-radius:6px;padding:.5em 1em;overflow-x:auto}.css-1gzdrlg code{font-family:monoscape}.css-1gzdrlg h1{margin:1.8rem 0;font-size:1.8rem}.css-1gzdrlg h1:before{content:"# ";color:#a19c91}.css-1gzdrlg h2{margin:1.6rem 0;font-size:1.6rem}.css-1gzdrlg h2:before{content:"## ";color:#a19c91}.css-1gzdrlg h3{margin:1.4rem 0;font-size:1.4rem}.css-1gzdrlg h3:before{content:"### ";color:#a19c91}.css-1gzdrlg h4{margin:1.2rem 0;font-size:1.2rem}.css-1gzdrlg h5{margin:1.15rem 0;font-size:1.15rem}.css-1gzdrlg h5:before{content:"> ";color:#a19c91}.css-1gzdrlg h6{margin:1.1rem 0;font-size:1.1rem}.css-1gzdrlg h6:before{content:">> ";color:#a19c91}.css-1gzdrlg img,.css-1gzdrlg iframe{max-width:80%;margin:0 auto;display:block}.css-1gzdrlg table{white-space:nowrap;border-collapse:collapse;display:block;overflow-x:auto}.css-1gzdrlg table td,.css-1gzdrlg table tr,.css-1gzdrlg table th{border:1px solid gray}.css-1gzdrlg table th{font-weight:700}.css-1gzdrlg table th,.css-1gzdrlg table td{padding:5px 10px}.css-1gzdrlg table thead{background:#d8d8d8}.css-1gzdrlg blockquote{background:#c2c2c2;border-left:5px solid #4e4e4e;margin:25px 10px 25px 30px;padding:10px 50px}.css-1gzdrlg ul li,.css-1gzdrlg ol li{margin:6px 0}</style><article class=css-1gzdrlg><h1>백준 7662번 이중 우선순위 큐 문제</h1><p><a href=https://www.acmicpc.net/problem/7662>백준 이중 우선순위 큐 문제</a>는 본 글에서 소개하는 최소-최대 힙(Min-max heap)을 구현하면 풀리는 문제이다.<p>필자는 최소-최대 힙을 시도하기에 앞서 다른 방법(최소 힙이랑 최대 힙 두개 만들기)을 시도했었으나 능력이 부족한 탓인지 실패했다. 따라서 이 방법의 정석적인 풀이방법인 최소-최대 힙을 <a href=https://en.wikipedia.org/wiki/Min-max_heap>영문 위키백과의 Min-max heap 문서</a>을 보면서 풀었다. 이 글에서는 최소-최대 힙에 대해 설명하고 C++ 구현 코드를 제시하고자 한다.<h2>Heap이란?</h2><p>Heap은 최소값이나 최대값 등을 빠르게 구하기 위해 만들어진 완전 이진 트리(Complete binary tree) 형태의 자료구조이다. 일반적으로 Heap이라고 말할 때는 보통 최대 힙(Max-heap)이나 최소 힙(Min-heap)을 의미한다. 이 중에서 최대 힙은 다음과 같이 구현된다.<ul><li>추가 <ol><li>추가하고자 하는 값을 힙 자료구조의 맨 뒤에 넣는다.<li>추가된 값을 부모 원소와 비교한다. <ul><li>만약 부모보다 작거나 같다면 멈춘다.<li>만약 부모보다 크다면 부모와 자리를 바꾼다.</ul><li>다시 2번으로 되돌아간다.</ol><li>최대값 삭제 <ol><li>최대 힙에서는 루트에 있는 값이 항상 최대값이다. 따라서 루트를 삭제하고 힙의 맨 뒤에 있는 값을 루트로 옮긴다. 이 루트로 옮겨진 원소를 A라 하자.<li>A를 가장 큰 값을 가진 자식과 비교한다. <ul><li>만약 자식이 더 크다면 자식과 자리를 바꾼다.<li>만약 자식이 더 작거나 같다면 멈춘다.</ul><li>다시 2번으로 되돌아간다.</ol></ul><p>최소 힙은 위에서 비교하는 방향만 돌려서 다음과 같이 구현하면 된다.<ul><li>추가 <ol><li>추가하고자 하는 값을 힙 자료구조의 맨 뒤에 넣는다.<li>추가된 값을 부모 원소와 비교한다. <ul><li>만약 부모보다 크거나 같다면 멈춘다.<li>만약 부모보다 작다면 부모와 자리를 바꾼다.</ul><li>다시 2번으로 되돌아간다.</ol><li>최소값 삭제 <ol><li>최대 힙에서는 루트에 있는 값이 항상 최소값이다. 따라서 루트를 삭제하고 힙의 맨 뒤에 있는 값을 루트로 옮긴다. 이 루트로 옮겨진 원소를 A라 하자.<li>A를 가장 작은 값을 가진 자식과 비교한다. <ul><li>만약 자식이 더 작다면 자식과 자리를 바꾼다.<li>만약 자식이 더 크거나 같다면 멈춘다.</ul><li>다시 2번으로 되돌아간다.</ol></ul><p>위와 같이 구현된 최대 힙에서는 항상 가장 큰 값을 가진 원소가 루트가 되며, 최소 힙에서는 가장 작은 값을 가진 원소가 항상 루트가 된다. 즉, 최대 힙을 이용하면 주어진 값들 중에서 최댓값을 빠르게 구할 수 있으며, 최소 힙을 이용하면 최소값을 빠르게 구할 수 있다.<p>그렇다면 여기서 궁금증이 하나 생긴다, 최댓값과 최소값을 둘 다 빠르게 구할 수 있는 힙 자료구조가 있을까? 이에 대한 정답은 본 글에서 소개하고자 하는 최소-최대 힙이다.<h2>최소-최대 힙</h2><p>Min-max heap(최소-최대 힙)은 홀수번째 레벨(이하 Min-level)의 원소는 그 밑에 있는 모든 원소들보다 작거나 같은 값을 가지며, 짝수번째 레벨(이하 Max-level)의 원소는 그 밑에 있는 모든 원소들보다 크거나 같은 값을 가진다. 루트가 있는 레벨은 Min-level이다.<p><img alt="예시 Min-max heap"src=./example.svg><p>위 예시를 보자. Min-level에 있는 원소는 그 하위에 있는 원소들보다 작은 값을 가지며, Max-level에 있는 원소는 그 밑에 있는 원소들보다 큰 값을 가진다.<p>따라서 우리는 최소-최대 힙에서 (루트는 Min-level이므로) 루트는 항상 힙의 최소값을 가지며, 2번째 레벨에 있는(루트 바로 밑 레벨에 있는) 두 원소 중 가장 큰 값이 힙의 최댓값을 나타냄을 알 수 있다.<h2>구현</h2><p>최소-최대 힙의 구현은 다음과 같이 이루어진다.<ul><li>추가 <ul><li>새로운 값을 추가할 때는 힙의 맨 뒤에 값을 추가한 뒤 그 값을 위로 올려가며(Push-up) 적절한 자리를 찾아 힙 자료구조를 완성한다.</ul><li>최소/최대값 확인 <ul><li>최소값을 읽을 때는 루트의 값을 읽는다.<li>최대값을 읽을 때는 루트의 직계자식들 중 가장 큰 값을 읽는다.</ul><li>삭제 <ul><li>최소값이나 최대값을 삭제한 뒤에는, 힙의 맨 뒤에 있는 값을 최소값이나 최대값이 있던 자리로 옮기고, 그 값을 아래로 내려가며(Push-down) 적절한 자리를 찾아 힙 자료구조를 완성한다.</ul></ul><p>위를 구현하기 위해서는 Push-up과 Push-down 알고리즘을 구현해야 한다.<h2>Push-Up의 구현</h2><p>예시를 들어 설명해보자. 다음 예시를 보라.<p><img alt="예시 Min-max heap"src=./pushup/step1.svg><p>위 그래프는 유효한 최소-최대힙이다. 위 그래프의 맨 끝에 3이라는 값을 추가했다고 가정해보자. 3을 추가할 시 아래와 같이 변한다.<p><img alt="예시 Min-max heap"src=./pushup/step2.svg><p>값을 추가하는 순간 유효한 최소-최대 힙이 아니게 된다. Min-level에 있는 6보다 더 작은 자식 3이 생기기 때문이다.<p>따라서 이 그래프를 다시 최소-최대 힙으로 만들기 위해서는 원소 3을 위로 올려가면서 적절한 위치를 찾아야 한다. 먼저, 추가한 값인 3이 Min-level에 있는 부모(6)보다 작다. 이는 최소-최대 힙의 조건과 모순되므로 부모와 추가된 값의 위치를 서로 바꿔준다.<p><img alt="에시 Min-max heap"src=./pushup/step3.svg><p>추가된 값이 부모와 바꿔지면서 Min-level로 옮겨졌음을 확인할 수 있다. 이제 3은 3을 루트로 하는 서브트리 내에서만큼은 무결하다. 왜나하면, 최소-최대 힙에서 루트에 있던 값은 그 밑의 모든 값들보다 작거나(혹은 루트의 레벨에 따라서, 크거나) 같아야 한다는 특징이 있는데, 이 값이 (6에서 3으로) 더 작아지는 것이 이 특징을 깨트리지 않음은 자명하기 때문이다.<p>그러나, 위 그래프는 아직도 최소-최대 힙의 특징을 만족하지 못한다. 5번째 레벨의 원소(값: 4)와 7번째 레벨의 원소(값: 5)를 보라. 5번째 레벨과 7번째 레벨은 홀수번째 레벨이므로 Min-level이다. 따라서 원소 4의 하위 원소들은 모두 값이 4보다 크거나 같아야 하고, 원소 5의 하위 원소들도 모두 값이 5보다 크거나 같아야 한다. 그러나 원소 3은 5나 4보다 크거나 같지 않다. 원소 5(혹은 4)의 하위 원소인 원소 3이 5(혹은 4)보다 작은 값을 가지므로 최소-최대 힙의 조건과 모순된다.<p>따라서 이 모순을 해결하기 위해, 원소 3을 상위의 Min-level에 있는 원소(위 사진에서 파란색으로 표시된 원소들)들과 비교하며 적절한 위치를 찾아야 한다. 원소 3을 파란색으로 표시된 원소들과 비교하여 위로 올려가며 적절한 위치를 찾은 결과는 다음과 같다.<p><img alt="에시 Min-max heap"src=./pushup/step4.svg><p>최소-최대 힙에 값 6이 성공적으로 추가됐음을 알 수 있다.<p>따라서 우리는 이 예시가 다음과 같은 알고리즘에 따라 이루어졌음을 알 수 있다.<ol><li>추가된 값(이하 원소 A)을 힙의 맨 뒤에 추가한다. A가 Max-level에 추가됐다고 가정하자.<li>A를 부모 원소와 비교한다. <ol><li>A가 부모 원소보다 작거나 같다면 A와 부모 원소를 서로 바꾼다.</ol><li>A를 A의 조부모 원소와 비교한다. <ul><li>만약 A가 Min-level이고 A가 조부모보다 더 작다면, A와 조부모의 위치를 서로 바꾼다.<li>만약 A가 Max-level이고 A가 조부모보다 더 크다면, A와 조부모의 위치를 서로 바꾼다.<li>서로 바꿀 필요가 없다면 멈춘다.</ul><li>3번으로 되돌아간다.</ol><p>위 알고리즘을 A가 처음에 Min-level에 추가된 경우로까지 확장하면 다음과 같다.<ol><li>추가된 값(이하 원소 A)을 힙의 맨 뒤에 추가한다.<li>A를 부모 원소와 비교한다. <ul><li>A가 Max-level에 있고, A가 부모 원소보다 작거나 같다면 A와 부모 원소를 서로 바꾼다.<li>A가 Min-level에 있고, A가 부모 원소보다 크거나 같다면 A와 부모 원소를 서로 바꾼다.</ul><li>A를 A의 조부모 원소와 비교한다. <ul><li>만약 A가 Min-level이고 A가 조부모보다 더 작다면, A와 조부모의 위치를 서로 바꾼다.<li>만약 A가 Max-level이고 A가 조부모보다 더 크다면, A와 조부모의 위치를 서로 바꾼다.<li>서로 바꿀 필요가 없다면 멈춘다.</ul><li>3번으로 되돌아간다.</ol><p>위 알고리즘이 최소-최대 힙의 Push-Up 알고리즘이다. 이 알고리즘을 이용하면 원소의 추가를 구현할 수 있다.<h2>Push-down의 구현</h2><p>Push-down은 다음과 같이 구현한다. 먼저, 아래와 같은 유효한 최소-최대 힙이이 있다고 가정하자.<p><img alt="Min-max heap"src=./pushdown/step1.svg><p>위 힙에서 최소값을 제거하고 최소값이 있던 자리(루트)에 8을 넣었다고 가정해보자. 그 결과는 다음과 같다.<p><img alt="Min-max heap"src=./pushdown/step2.svg><p>위 그래프는 유효한 최소-최대 힙이 아니다. 따라서 이 그래프를 최소-최대 힙으로 만들기 위해서는 원소들의 위치를 아래로 내려가며 조정해야 한다.<p>먼저, 위 그래프에서 원소 8은 Min-level에 있다. 따라서 원소 8의 자식(Child)과 손자(Grandchild)들중 가장 작은 값을 가진 원소를 확인한다. 이 원소는 2이다.<p>원소 2가 원소 8보다 더 작음은 Min-max heap의 조건에 모순된다. 따라서 원소 2와 원소 8의 위치를 서로 바꾼다.<p><img alt="Min-max heap"src=./pushdown/step3.svg><p>원소 2와 원소 8의 위치를 서로 바꾸었지만 Max-level에 있는 원소 7이 자식인 원소 8보다 더 작은 값을 가지고 있다. 이는 모순이다. 따라서 원소 7과 원소 8의 위치를 서로 바꾼다.<p><img alt="Min-max heap"src=./pushdown/step4.svg><p>이제 원소 2는 하위에 있는 모든 원소들보다 작은 값을 가지고, 원소 8은 하위에 있는 모든 원소들보다 큰 값을 가진다. 원소 7 위로는 Min-max heap의 조건과 모순되는 원소가 없다. 그러나 원소 7의 밑을 보라. 원소 7은 Min-level이므로 원소 7 하위의 모든 원소들보다 작거나 같은 값을 가져야 한다. 그러나 원소 6, 3, 5, 4로 인하여 이 조건이 만족되지 않는다.<p>이를 해결하기 위해 원소 7의 자식과 손자들 중 가장 작은 값을 가진 원소를 찾는다. 이러한 원소는 3이다. 원소 3으로 인하여 원소 7이 Min-level의 조건을 만족하지 않으니 원소 3과 원소 7의 위치를 서로 바꾼다.<p><img alt="Min-max heap"src=./pushdown/step5.svg><p>원소 7의 부모는 Max-level이므로 원소 7의 부모는 원소 7보다 더 크거나 같은 값을 가져야 한다. 그러나 부모 원소의 값은 6이므로 7보다 크거나 같은 값이 아니다. 따라서 원소 7과 6의 위치를 서로 바꾼다.<p><img alt="Min-max heap"src=./pushdown/step6.svg><p>이제 원소 6 위의 모든 원소들 (2, 8, 3, 7)들은 Min-level과 Max-level의 조건을 만족한다. 그러나 원소 6은 Min-level의 조건을 만족하지 못한다. 따라서 원소 6이 Min-level의 조건을 만족하도록 하기 위해 원소 6의 자식과 손자들 중 가장 작은 값을 가진 원소를 찾는다. 이 원소는 4이다. 원소 4는 Min-level인 원소 6의 손자임이도 불구하고 6보다 작은 값을 가지고 있다. 이는 모순이므로 원소 6과 4의 위치를 바꾼다.<p><img alt="Min-max heap"src=./pushdown/step7.svg><p>원소 6의 부모를 보자. 원소 6의 부모의 값은 5인데, 이 부모 원소는 Max-level에 있다. 이는 모순이다. 이 모순을 해결하기 위해 원소 6과 원소 5의 위치를 서로 바꾼다.<p><img alt="Min-max heap"src=./pushdown/step8.svg><p>이제 유효한 Min-max heap이 만들어졌음을 확인할 수 있다. 이 예시로부터 알고리즘을 도출하면 다음과 같다.<ul><li>주어진 원소 A에 대하여, 만약 A가 Min-level이라면 <ol><li>자식과 손자들 중 가장 작은 값을 가진 원소를 B라고 하고 B의 인덱스를 <code>i</code>라고 하자.<li>만약 B가 A보다 더 작은 값을 가지고 있고. <ul><li>B가 A의 손자라면 <ol><li>B와 A의 위치를 서로 바꾼다.<li>만약 A가 A의 부모보다 더 큰 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.<li><code>i</code>번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.</ol><li>B가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.</ul></ol></ul><p>위 알고리즘을 A가 Max-level인 경우로까지 확장하면 다음과 같다.<ul><li>주어진 원소 A에 대하여 <ul><li>만약 A가 Min-level이라면 <ol><li>자식과 손자들 중 가장 작은 값을 가진 원소를 B라고 하고 B의 인덱스를 <code>i</code>라고 하자.<li>만약 B가 A보다 더 작은 값을 가지고 있고. <ul><li>B가 A의 손자라면 <ol><li>B와 A의 위치를 서로 바꾼다.<li>만약 A가 A의 부모보다 더 큰 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.<li><code>i</code>번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.</ol><li>B가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.</ul></ol><li>만약 A가 Max-level이라면 <ol><li>자식과 손자들 중 가장 큰 값을 가진 원소를 B라고 하고 B의 인덱스를 <code>i</code>라고 하자.<li>만약 B가 A보다 더 큰 값을 가지고 있고. <ul><li>B가 A의 손자라면 <ol><li>B와 A의 위치를 서로 바꾼다.<li>만약 A가 A의 부모보다 더 작은 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.<li><code>i</code>번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.</ol><li>B가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.</ul></ol></ul></ul><h2>소스코드 (C++)</h2><p>이제 위에서 PushUp과 Pushdown의 구현 알고리즘을 살펴봤으므로 아래와 같이 C++로 구현할 수 있다.<pre><code class=language-cpp>#<span class=pl-k>include</span> <span class=pl-s><span class=pl-pds><</span>iostream<span class=pl-pds>></span></span>
#<span class=pl-k>include</span> <span class=pl-s><span class=pl-pds><</span>algorithm<span class=pl-pds>></span></span>
#<span class=pl-k>include</span> <span class=pl-s><span class=pl-pds><</span>cmath<span class=pl-pds>></span></span>
#<span class=pl-k>define</span> <span class=pl-en>INT_SWAP</span>(<span class=pl-v>a,b</span>) <span class=pl-k>int</span> tmp = a; a = b; b = tmp
#<span class=pl-k>define</span> <span class=pl-en>SWAP_HEAP</span>(<span class=pl-v>a,b</span>) INT_SWAP(heap[(a)], heap[(b)])
#<span class=pl-k>define</span> <span class=pl-en>IS_MIN_LEVEL</span>(<span class=pl-v>index</span>) ((<span class=pl-k>int</span>)(std::log2(index)) % <span class=pl-c1>2</span>) == <span class=pl-c1>0</span>

<span class=pl-k>int</span> heapCount = <span class=pl-c1>0</span>; <span class=pl-c>// How many elements in the heap?</span>
<span class=pl-k>int</span> heap[<span class=pl-c1>1000001</span>]; <span class=pl-c>// Heap, starting from index 1</span>

<span class=pl-k>void</span> <span class=pl-en>insertHeap</span>(<span class=pl-k>int</span> item); <span class=pl-c>// inserts an element</span>
<span class=pl-k>void</span> <span class=pl-en>popMin</span>(); <span class=pl-c>// removes minimum element</span>
<span class=pl-k>void</span> <span class=pl-en>popMax</span>(); <span class=pl-c>// removes maximum element</span>
<span class=pl-k>int</span> <span class=pl-en>seekMin</span>(); <span class=pl-c>// reads minimum element</span>
<span class=pl-k>int</span> <span class=pl-en>seekMax</span>(); <span class=pl-c>// reads maximum element</span>

<span class=pl-c>/**</span>
<span class=pl-c> * Implementation of min/max pop using push-down</span>
<span class=pl-c> */</span>

<span class=pl-c>// Picks index of largest(or smallest) child(or grandchild) of given element</span>
<span class=pl-k>int</span> <span class=pl-en>pickLargetOrSmallestDescendantIndex</span>(<span class=pl-k>int</span> index, <span class=pl-k>bool</span> largest) {
    <span class=pl-k>int</span> resultIndex = <span class=pl-c1>index</span> * <span class=pl-c1>2</span>, resultValue = heap[<span class=pl-c1>index</span> * <span class=pl-c1>2</span>];
    <span class=pl-k>int</span> candids[] = { <span class=pl-c>// Children and grandchildren</span>
        <span class=pl-c1>index</span> * <span class=pl-c1>2</span> + <span class=pl-c1>1</span>, <span class=pl-c>// Right child</span>
        <span class=pl-c1>index</span> * <span class=pl-c1>4</span>, <span class=pl-c>// 1st grandchild (Left child of left child)</span>
        <span class=pl-c1>index</span> * <span class=pl-c1>4</span> + <span class=pl-c1>1</span>, <span class=pl-c>// 2nd grandchild (Right child of left cihld)</span>
        <span class=pl-c1>index</span> * <span class=pl-c1>4</span> + <span class=pl-c1>2</span>, <span class=pl-c>// 3rd grandchild (Left child of right child)</span>
        <span class=pl-c1>index</span> * <span class=pl-c1>4</span> + <span class=pl-c1>3</span> <span class=pl-c>// 4th grandchild (Right child of right child)</span>
    };

    <span class=pl-k>for</span> (<span class=pl-k>auto</span> candidIndex: candids) {
        <span class=pl-k>if</span> (candidIndex > heapCount)
            <span class=pl-k>continue</span>; <span class=pl-c>// If it's invalid index, continue</span>

        <span class=pl-k>if</span> (largest && resultValue < heap[candidIndex]) {
            resultValue = heap[candidIndex];
            resultIndex = candidIndex;
        } <span class=pl-k>else</span> <span class=pl-k>if</span> (!largest && resultValue > heap[candidIndex]) {
            resultValue = heap[candidIndex];
            resultIndex = candidIndex;
        }
    }

    <span class=pl-k>return</span> resultIndex;
}

<span class=pl-k>void</span> <span class=pl-en>pushDownMin</span>(<span class=pl-k>int</span> index);
<span class=pl-k>void</span> <span class=pl-en>pushDownMax</span>(<span class=pl-k>int</span> index);

<span class=pl-k>void</span> <span class=pl-en>pushDown</span>(<span class=pl-k>int</span> index) {
    <span class=pl-k>if</span> (<span class=pl-c1>IS_MIN_LEVEL</span>(<span class=pl-c1>index</span>)) {
        <span class=pl-c1>pushDownMin</span>(<span class=pl-c1>index</span>);
    } <span class=pl-k>else</span> {
        <span class=pl-c1>pushDownMax</span>(<span class=pl-c1>index</span>);
    }
}

<span class=pl-k>void</span> <span class=pl-en>pushDownMin</span>(<span class=pl-k>int</span> index) {
    <span class=pl-k>if</span> (<span class=pl-c1>index</span> * <span class=pl-c1>2</span> <= heapCount) { <span class=pl-c>// if has children</span>
        <span class=pl-k>int</span> m = <span class=pl-c1>pickLargetOrSmallestDescendantIndex</span>(<span class=pl-c1>index</span>, <span class=pl-c1>false</span>);

        <span class=pl-k>if</span> (m >= <span class=pl-c1>index</span> * <span class=pl-c1>4</span>) { <span class=pl-c>// if m is a grandchild</span>
            <span class=pl-k>if</span> (heap[m] < heap[<span class=pl-c1>index</span>]) {
                <span class=pl-c1>SWAP_HEAP</span>(m, <span class=pl-c1>index</span>);
                <span class=pl-k>if</span> (heap[m] > heap[m / <span class=pl-c1>2</span>]) {
                    <span class=pl-c1>SWAP_HEAP</span>(m, m / <span class=pl-c1>2</span>);
                }
                <span class=pl-c1>pushDown</span>(m);
            }
        } <span class=pl-k>else</span> <span class=pl-k>if</span> (heap[m] < heap[<span class=pl-c1>index</span>]) {
            <span class=pl-c1>SWAP_HEAP</span>(m, <span class=pl-c1>index</span>); 
        }
    }
}

<span class=pl-k>void</span> <span class=pl-en>pushDownMax</span>(<span class=pl-k>int</span> index) {
    <span class=pl-k>if</span> (<span class=pl-c1>index</span> * <span class=pl-c1>2</span> <= heapCount) { <span class=pl-c>// if has children</span>
        <span class=pl-k>int</span> m = <span class=pl-c1>pickLargetOrSmallestDescendantIndex</span>(<span class=pl-c1>index</span>, <span class=pl-c1>true</span>);

        <span class=pl-k>if</span> (m >= <span class=pl-c1>index</span> * <span class=pl-c1>4</span>) { <span class=pl-c>// if m is a grandchild</span>
            <span class=pl-k>if</span> (heap[m] > heap[<span class=pl-c1>index</span>]) {
                <span class=pl-c1>SWAP_HEAP</span>(m, <span class=pl-c1>index</span>);
                <span class=pl-k>if</span> (heap[m] < heap[m / <span class=pl-c1>2</span>]) {
                    <span class=pl-c1>SWAP_HEAP</span>(m, m / <span class=pl-c1>2</span>);
                }
                <span class=pl-c1>pushDown</span>(m);
            }
        } <span class=pl-k>else</span> <span class=pl-k>if</span> (heap[m] > heap[<span class=pl-c1>index</span>]) {
            <span class=pl-c1>SWAP_HEAP</span>(m, <span class=pl-c1>index</span>); 
        }
    }
}

<span class=pl-k>void</span> <span class=pl-en>popMin</span>() {
    <span class=pl-k>if</span> (heapCount <= <span class=pl-c1>0</span>)
        <span class=pl-k>return</span>;
    <span class=pl-c>// Removes minimum element</span>
    heap[<span class=pl-c1>1</span>] = heap[heapCount--];
    <span class=pl-c>// Push down root element to make the heap valid min-max heap</span>
    <span class=pl-c1>pushDown</span>(<span class=pl-c1>1</span>);
}

<span class=pl-k>void</span> <span class=pl-en>popMax</span>() {
    <span class=pl-k>if</span> (heapCount <= <span class=pl-c1>0</span>)
        <span class=pl-k>return</span>;
    
    <span class=pl-k>int</span> <span class=pl-c1>index</span>;
    <span class=pl-k>if</span> (heapCount == <span class=pl-c1>1</span>)
        <span class=pl-c1>index</span> = <span class=pl-c1>1</span>;
    <span class=pl-k>else</span> <span class=pl-k>if</span> (heapCount == <span class=pl-c1>2</span>)
        <span class=pl-c1>index</span> = <span class=pl-c1>2</span>;
    <span class=pl-k>else</span>
        <span class=pl-c1>index</span> = heap[<span class=pl-c1>2</span>] > heap[<span class=pl-c1>3</span>] ? <span class=pl-c1>2</span> : <span class=pl-c1>3</span>;
    
    <span class=pl-c>// Removes maximum element</span>
    heap[<span class=pl-c1>index</span>] = heap[heapCount--];
    <span class=pl-c>// Push down to root element make the heap valid min-max heap</span>
    <span class=pl-c1>pushDown</span>(<span class=pl-c1>index</span>);
}

<span class=pl-c>/**</span>
<span class=pl-c> * Implementation of insertion using push-up</span>
<span class=pl-c> */</span>

<span class=pl-k>void</span> <span class=pl-en>pushUpMin</span>(<span class=pl-k>int</span> index) {
    <span class=pl-k>if</span> (<span class=pl-c1>index</span> >= <span class=pl-c1>4</span> && <span class=pl-c>// if index >= 4, it must have a grandparent.</span>
        heap[<span class=pl-c1>index</span>] < heap[<span class=pl-c1>index</span> / <span class=pl-c1>4</span>]) {
            <span class=pl-c1>SWAP_HEAP</span>(<span class=pl-c1>index</span>, <span class=pl-c1>index</span> / <span class=pl-c1>4</span>);
            <span class=pl-c1>pushUpMin</span>(<span class=pl-c1>index</span> / <span class=pl-c1>4</span>);
        }
}

<span class=pl-k>void</span> <span class=pl-en>pushUpMax</span>(<span class=pl-k>int</span> index) {
    <span class=pl-k>if</span> (<span class=pl-c1>index</span> >= <span class=pl-c1>4</span> && <span class=pl-c>// if index >= 4, it must have a grandparent.</span>
        heap[<span class=pl-c1>index</span>] > heap[<span class=pl-c1>index</span> / <span class=pl-c1>4</span>]) {
            <span class=pl-c1>SWAP_HEAP</span>(<span class=pl-c1>index</span>, <span class=pl-c1>index</span> / <span class=pl-c1>4</span>);
            <span class=pl-c1>pushUpMax</span>(<span class=pl-c1>index</span> / <span class=pl-c1>4</span>);
        }
}

<span class=pl-k>void</span> <span class=pl-en>pushUp</span>(<span class=pl-k>int</span> index) {
    <span class=pl-k>if</span> (<span class=pl-c1>index</span> != <span class=pl-c1>1</span>) {
        <span class=pl-k>if</span> (<span class=pl-c1>IS_MIN_LEVEL</span>(<span class=pl-c1>index</span>)) {
            <span class=pl-k>if</span> (heap[<span class=pl-c1>index</span>] > heap[<span class=pl-c1>index</span> / <span class=pl-c1>2</span>]) {
                <span class=pl-c1>SWAP_HEAP</span>(<span class=pl-c1>index</span>, <span class=pl-c1>index</span> / <span class=pl-c1>2</span>);
                <span class=pl-c1>pushUpMax</span>(<span class=pl-c1>index</span> / <span class=pl-c1>2</span>);
            } <span class=pl-k>else</span> {
                <span class=pl-c1>pushUpMin</span>(<span class=pl-c1>index</span>);
            }
        } <span class=pl-k>else</span> {
            <span class=pl-k>if</span> (heap[<span class=pl-c1>index</span>] < heap[<span class=pl-c1>index</span> / <span class=pl-c1>2</span>]) {
                <span class=pl-c1>SWAP_HEAP</span>(<span class=pl-c1>index</span>, <span class=pl-c1>index</span> / <span class=pl-c1>2</span>);
                <span class=pl-c1>pushUpMin</span>(<span class=pl-c1>index</span> / <span class=pl-c1>2</span>);
            } <span class=pl-k>else</span> {
                <span class=pl-c1>pushUpMax</span>(<span class=pl-c1>index</span>);
            }
        }
    }
}

<span class=pl-k>void</span> <span class=pl-en>insertHeap</span>(<span class=pl-k>int</span> item) {
    heap[++heapCount] = item;
    <span class=pl-c1>pushUp</span>(heapCount);
}


<span class=pl-k>int</span> <span class=pl-en>seekMin</span>() {
    <span class=pl-k>return</span> heap[<span class=pl-c1>1</span>];
}

<span class=pl-k>int</span> <span class=pl-en>seekMax</span>() {
    <span class=pl-k>if</span> (heapCount == <span class=pl-c1>1</span>) {
        <span class=pl-k>return</span> heap[<span class=pl-c1>1</span>];
    } <span class=pl-k>else</span> <span class=pl-k>if</span> (heapCount == <span class=pl-c1>2</span>) {
        <span class=pl-k>return</span> heap[<span class=pl-c1>2</span>];
    } <span class=pl-k>else</span> {
        <span class=pl-k>return</span> <span class=pl-c1>std::max</span>(heap[<span class=pl-c1>2</span>], heap[<span class=pl-c1>3</span>]);
    }

}

<span class=pl-k>int</span> <span class=pl-en>main</span>() {
    std::cin.<span class=pl-c1>tie</span>(<span class=pl-c1>NULL</span>);
    <span class=pl-c1>std::ios_base::sync_with_stdio</span>(<span class=pl-c1>false</span>);

    <span class=pl-c>// How many test cases?</span>
    <span class=pl-k>int</span> t;
    std::cin >> t;

    <span class=pl-k>for</span> (<span class=pl-k>int</span> i = <span class=pl-c1>0</span>; i < t; i++) {
        <span class=pl-c>// How many operations?</span>
        <span class=pl-k>int</span> q;
        std::cin >> q;
        
        <span class=pl-c>// Process operations</span>
        <span class=pl-k>for</span> (<span class=pl-k>int</span> j = <span class=pl-c1>0</span>; j < q; j++) {
            <span class=pl-k>char</span> c;
            <span class=pl-k>int</span> data;
            std::cin >> c >> data;
            
            <span class=pl-k>switch</span>(c) {
                <span class=pl-k>case</span> <span class=pl-s><span class=pl-pds>'</span>I<span class=pl-pds>'</span></span>:
                    <span class=pl-c1>insertHeap</span>(data);
                    <span class=pl-k>break</span>;
                <span class=pl-k>case</span> <span class=pl-s><span class=pl-pds>'</span>D<span class=pl-pds>'</span></span>:
                    <span class=pl-k>if</span> (data == -<span class=pl-c1>1</span>)
                        <span class=pl-c1>popMin</span>();
                    <span class=pl-k>else</span>
                        <span class=pl-c1>popMax</span>();
            }
        }

        <span class=pl-c>// Print result</span>
        <span class=pl-k>int</span> max = <span class=pl-c1>seekMax</span>(), min = <span class=pl-c1>seekMin</span>();

        <span class=pl-k>if</span> (heapCount == <span class=pl-c1>0</span>)
            std::cout << <span class=pl-s><span class=pl-pds>"</span>EMPTY<span class=pl-cce>\n</span><span class=pl-pds>"</span></span>;
        <span class=pl-k>else</span>
            std::cout << max << <span class=pl-s><span class=pl-pds>'</span> <span class=pl-pds>'</span></span> << min << <span class=pl-s><span class=pl-pds>'</span><span class=pl-cce>\n</span><span class=pl-pds>'</span></span>;
        heapCount = <span class=pl-c1>0</span>;
    }
}
</code></pre></article><style data-emotion="css ly0ba3">.css-ly0ba3 .utterances{max-width:100%!important}</style><div class=css-ly0ba3><script label="blog comment"async crossorigin issue-term=og:title repo=LiteHell/litehell-blog src=https://utteranc.es/client.js theme=github-light></script></div><style data-emotion="css eyxei3">.css-eyxei3{-webkit-box-flex-wrap:wrap;-webkit-flex-flow:wrap;-ms-flex-flow:wrap;flex-flow:wrap;justify-content:space-between;gap:1em .5em;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-eyxei3 a{-webkit-text-decoration:none;text-decoration:none}.css-eyxei3 .inner{vertical-align:top;display:inline-block}.css-eyxei3 .inner .title{font-size:1.3em;line-height:1.3rem}.css-eyxei3 .inner .subtitle{margin-top:.2rem;font-size:1rem;font-weight:200;line-height:1rem}.css-eyxei3 .inner .date{font-size:.8em;font-weight:200;line-height:.8rem}.css-eyxei3 .next,.css-eyxei3 .previous{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;gap:.5em;width:max-content;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-eyxei3 .next.next,.css-eyxei3 .previous.next{text-align:right;margin-left:auto}.css-eyxei3 .next.previous,.css-eyxei3 .previous.previous{text-align:left}.css-eyxei3 .next .inner,.css-eyxei3 .previous .inner{-webkit-flex:1;-ms-flex:1;flex:1}</style><nav class=css-eyxei3><a class=previous href=/post/creating_mastodon_instance><div class=arrow>❮</div><div class=inner><div class=title>Mastodon 서버 구축하기</div><div class=subtitle>6$짜리 VPS와 CloudFlare를 이용한 인스턴스 구축</div><div class=date>2023. 7. 23. 오전 12:55:38</div></div></a><a class=next href=/post/how_to_fix_no_sound_issue_in_samsung_laptop_ubuntu><div class=inner><div class=title>삼성 노트북(950XBE) 우분투에서 소리 안 들리는 버그 고치기</div><div class=subtitle>한 줄로 고치는 버그</div><div class=date>2023. 3. 18. 오후 7:21:27</div></div><div class=arrow>❯</div></a></nav></div></main><style data-emotion="css 19fp2wc">.css-19fp2wc{font-size:.75rem;line-height:.9rem}.css-19fp2wc p{margin:0 0 1em;padding:0}.css-19fp2wc .badges{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;gap:1em;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.css-19fp2wc .badges img{border-width:0;width:auto;height:3em}</style><footer class=css-19fp2wc><p>Copyright (C) 2020 ~ 2025 Yeonjin Shin (a.k.a. LiteHell), All rights reserved.<br><a href=/license>This blog is free software; For source code and more informations on license and copyrights, Click here.</a><p>Feeds: <a href=/feed/rss>RSS 2.0</a>, <a href=/feed/atom>Atom</a>, <a href=/feed/json>JSON</a><div class=badges><a href=http://creativecommons.org/licenses/by-sa/4.0/ rel=license><img alt="Creative Commons License"src=https://i.creativecommons.org/l/by-sa/4.0/88x31.png><a href=https://www.gnu.org/licenses/agpl-3.0.en.html><img alt="GNU Affero General License Version 3"src=https://www.gnu.org/graphics/agplv3-with-text-100x42.png></a></a></div></footer></div>