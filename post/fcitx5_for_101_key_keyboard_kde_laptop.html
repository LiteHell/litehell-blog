<!DOCTYPE html><html lang="ko-KR"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="https://gravatar.com/avatar/837266b567b50fd59e72428220bf69b1"/><link rel="canonical" href="https://blog.litehell.info/post/fcitx5_for_101_key_keyboard_kde_laptop"/><link rel="alternate" type="application/rss+xml" title="RSS 2.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/rss"/><link rel="alternate" type=" application/atom+xml" title="Atom 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/atom"/><link rel="alternate" type="application/feed+json" title="Json 1.0 Feed for blog.litehell.info" href="https://blog.litehell.info/feed/json"/><meta property="og:title" content="한글 입력을 위한 fcitx5 설치"/><meta property="og:description" content="KDE 노트북에서의 버그없는 한글 입력을 위한 삽질기"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="article"/><meta property="og:site_name" content="LiteHell의 블로그"/><meta property="og:url" content="https://blog.litehell.info/post/fcitx5_for_101_key_keyboard_kde_laptop"/><meta property="og:image" content="https://blog.litehell.info/img/kde_keyboard_settings.png"/><title>LiteHell의 블로그 - <!-- -->한글 입력을 위한 fcitx5 설치</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/vs2015.min.css"/><meta name="next-head-count" content="16"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CZL0E8YDPW"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-CZL0E8YDPW', { page_path: window.location.pathname });
            </script><link rel="preload" href="/_next/static/css/27d177a30947857b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27d177a30947857b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/088d29430e0ecbdb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/088d29430e0ecbdb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-ad45764ecfcae9e5.js" defer=""></script><script src="/_next/static/chunks/main-ee0cf4b7f81d7c24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a96cacb95f41a3ef.js" defer=""></script><script src="/_next/static/chunks/996-c5e5aa4c30f33066.js" defer=""></script><script src="/_next/static/chunks/503-25bfb158f613fce4.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bid%5D-b722ca2857677f7b.js" defer=""></script><script src="/_next/static/-Jnmemo0XHj-EY0Cns6cx/_buildManifest.js" defer=""></script><script src="/_next/static/-Jnmemo0XHj-EY0Cns6cx/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_body__O2_kC"><header class="Layout_header__M_IZ8"><div class="Layout_container__z4qWC"><h1><a href="/">LiteHell의 블로그</a></h1><div class="Layout_outLinks__XBNs_">외부고리 : <a href="https://litehell.info">Homepage</a><a href="https://github.com/LiteHell">GitHub</a><a href="https://linkedin.com/in/LiteHell">LinkedIn</a><a href="https://keybase.io/LiteHell">Keybase</a><a href="mailto:litehell@litehell.info">Email</a></div><div class="Layout_inLinks__f7gmD">내부고리 : <a href="/category">카테고리</a><a href="/tag">태그</a></div></div></header><main class="Layout_mainContainer__5WZfx"><div class="Layout_container__z4qWC"><div class="Blog_header__r4wcZ"><div class="Blog_title___OFu6"><h1>한글 입력을 위한 fcitx5 설치</h1><h2>KDE 노트북에서의 버그없는 한글 입력을 위한 삽질기</h2></div><p>10/17/2023, 12:34:16 PM<!-- -->에 <!-- -->LiteHell<!-- -->이(가) 작성<!-- -->하고 10/17/2023, 2:32:47 PM에 수정함<br/><span>카테고리 : <a href="/category/Linux">Linux</a><br/></span><span>태그 : <span class="Blog_tag__RW5VK"><a href="/tag/Linux">Linux</a></span><span class="Blog_tag__RW5VK"><a href="/tag/Korean">Korean</a></span><span class="Blog_tag__RW5VK"><a href="/tag/Hangul">Hangul</a></span><span class="Blog_tag__RW5VK"><a href="/tag/IM">IM</a></span><span class="Blog_tag__RW5VK"><a href="/tag/KDE">KDE</a></span><br/></span></p></div><section class="Blog_article__WZp3G"><h1 id="서론">서론</h1>
<p>필자는 초창기에 <a href="https://github.com/ibus/ibus">ibus</a>를 썼었다. ibus는 웬만한 프로그램에서 아무 버그없이 잘 작동한다. 딱 한가지, 리브레오피스에서 공백 입력이 안 된다는 치명적인 버그만 빼면 말이다.</p>
<p>그래서 ibus 다음으로 <a href="https://github.com/hamonikr/nimf">하모니카에서 유지보수하는 nimf</a>를 썼었다. nimf는 리브레오피스에서의 치명적인 버그는 없었지만, 엔터키를 누르면 텍스트가 사라지는 버그가 있었다. 근데 이 버그, 처음에만 짜증나지 좀 지나면 적응된다. 그래서 적응해서 쓰다가 생각해보니 &#39;이건 좀 아닌 것 같다&#39;싶어서 다른 입력기를 설치했다.</p>
<p>본 블로그 글은 <a href="https://archlinux.org/">Arch Linux</a>를 기준으로 설명한다.</p>
<h2 id="kde에서의-키보드-레이아웃">KDE에서의 키보드 레이아웃</h2>
<p>입력기를 바꾸기 위해 삽질하는 과정에서 한글키가 오른쪽 Alt키로 인식되는 현상을 확인했다. 분명히 아치 리눅스 설치 초기에 매핑을 했었는데, 시스템 업데이트를 하는 과정에서 원상복구가 된 것 같다. 그래서 이번에는 KDE 설정 프로그램을 이용해 한글키와 한자키를 매핑했다.</p>
<p><img src="/img/kde_keyboard_settings.png" alt="KDE 키보드 설정 프로그램"></p>
<p>위와 같이 시스템 설정 프로그램의 <strong>입력 장치 🠞 키보드</strong> 화면에서 <strong>오른쪽 Alt 키를 한/영 키로 만들기</strong>, <strong>오른쪽 Ctrl 키를 한자 키로 만들기</strong> 항목을 체크하면 된다. (키보드 레이아웃에 따라 약간 다를 수 있다.) 노트북 등의 101/104키 호환 레이아웃이라면 위 과정을 반드시 거쳐야 한다.</p>
<h3 id="한영-한자키-인식여부-확인방법">한/영, 한자키 인식여부 확인방법</h3>
<p>본인 키보드가 101/104키인지 106키인지 헷갈린다면 <del>키보드 키 갯수 세지말고</del> 먼저 <code>xev</code> 프로그램을 설치한다.</p>
<pre><code class="hljs language-bash">sudo pacman -S xorg-xev</code></pre>
<p>그리고 콘솔 창에서 xev 프로그램을 실행한다.</p>
<pre><code class="hljs language-bash">xev</code></pre>
<p>xev 프로그램 창을 활성화하고 한글키랑 한자키를 눌러본다. 다음과 같이 콘솔 창에 <em>Hangul</em>이나 <em>Hangul_Hanja</em>키가 인식된 메세지가 출력되면 한/영 키, 한자 키가 정상적으로 인식되는 것이다.</p>
<pre><code>KeyRelease event, serial 39, synthetic NO, window 0x9000001,
    root 0x79b, subw 0x0, time 1234567, (-10, 10), root:(10, 10),
    state 0x0, keycode 108 (keysym 0xff31, Hangul), same_screen YES,</code></pre>
<pre><code>KeyPress event, serial 39, synthetic NO, window 0x9000001,
    root 0x79b, subw 0x0, time 1234567, (10, 10), root:(10, 10),
    state 0x0, keycode 105 (keysym 0xff34, Hangul_Hanja), same_screen YES,</code></pre>
<p>만약 위와 같은 메세지가 안 뜨고 Alt_R이나 Control_R이 인식된다면 <a href="#kde에서의-키보드-레이아웃">위에 써진 내용</a>에 따라 매핑하면 된다.</p>
<h2 id="fcitx5-설치-방법">fcitx5 설치 방법</h2>
<p>먼저, 다음 명령어를 실행해 fcitx5를 설치한다.</p>
<pre><code class="hljs language-bash">sudo pacman -S fcitx5-im fcitx-hangul</code></pre>
<p><code>/etc/environment</code> 파일에 다음 내용을 추가한다. 입력기로 fcitx를 쓰도록 지정하는 작업이다.</p>
<!-- ini파일이 아니지만 syntax highlighting을 위해 형식을 ini으로 지정함 --->
<pre><code class="hljs language-ini"><span class="hljs-attr">GTK_IM_MODULE</span>=fcitx
<span class="hljs-attr">QT_IM_MODULE</span>=fcitx
<span class="hljs-attr">QT4_IM_MODULE</span>=fcitx
<span class="hljs-attr">QT5_IM_MODULE</span>=fcitx
<span class="hljs-attr">XMODIFIERS</span>=@im=fcitx</code></pre>
<p>그 다음에 <code>~/.xprofile</code> 파일에 다음 내용을 추가한다. 부팅시에 fcitx5가 실행되도록 한다.</p>
<pre><code class="hljs language-bash">fcitx5 -d</code></pre>
<p>재부팅하고 <code>env | grep fcitx</code> 명령어를 실행해 환경변수가 제대로 변경됐는지 확인해보자. 제대로 변경됐다면 다음과 같이 뜰 것이다.</p>
<pre><code class="hljs language-bash">GTK_IM_MODULE=fcitx
QT4_IM_MODULE=fcitx
XMODIFIERS=@im=fcitx
QT5_IM_MODULE=fcitx
QT_IM_MODULE=fcitx</code></pre>
<p>만약 환경변수가 제대로 변경되지 않았다면 <code>~/.xprofile</code> 파일에서 <code>fcitx5 -d</code> 위에 다음 내용을 추가하고 재부팅한다. 그러면 환경변수가 정상적으로 변경될 것이다.</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">export</span> $(/usr/lib/systemd/user-environment-generators/30-systemd-environment-d-generator)</code></pre>
<h2 id="fcitx5-설정">fcitx5 설정</h2>
<p><code>fcitx5-configtool</code> 명령어를 실행하면 다음 창이 뜬다.
<img src="/img/fcitx5_settings_first_screen.png" alt="fcitx5 KDE 설정 창"></p>
<p>위 화면에서 한국어가 안 보이면 <strong>입력기 추가</strong>버튼을 눌러서 추가한다. (입력기 추가 화면에서 한국어가 안 보이면 <strong>현재 언어만 표시</strong> 옵션을 해제하면 된다.)</p>
<p>밑에서 <strong>전역 옵션 구성하기...</strong> 버튼을 누르면 다음 화면이 뜬다.</p>
<p><img src="/img/fcitx5_global_settings.png" alt="fcitx5 KDE 설정 창"></p>
<p><strong>Trigger Input Method</strong>가 한/영을 전환하는 단축키 설정이다. 오른쪽의 <strong>+</strong> 버튼을 눌러 한글 키를 추가하면 된다.</p>
<p>fcitx5는 기본적으로 한/영을 전환할때 작은 툴팁을 표시한다. 거슬리면 위 화면에서 <strong>Show Input Method Information when switch input method</strong>를 체크 해제하면 된다.</p>
<p>이제 한글 입력을 버그없이 잘 할 수 있게 됐다. 끝!</p>
</section><div class="Comments_blogComments__GRWmY"></div><nav class="Blog_postNav__ivy8_ Blog_hasBoth__3MRPr"><div class="Blog_leftAnchor__HhzIP"><a href="/post/webpack_and_react_ssg_3"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">Webpack과 React를 이용한 정적 웹사이트 만들기 (3)</div><div class="Blog_subtitle__RRFh7">... + MiniCssExtractPlugin = TA-DA!</div></div></a></div><div class="Blog_rightAnchor__B9n7B"><a href="/post/docker_for_testing"><div class="Blog_postDescription__eV92_"><div class="Blog_title___OFu6">Docker로 테스트하기</div><div class="Blog_subtitle__RRFh7">Docker로 빌드만 하지 말고 테스트도 하자</div></div></a></div></nav></div></main><footer class="Layout_footer__bKkxe"><div class="Layout_container__z4qWC"><a href="https://www.gnu.org/licenses/agpl-3.0.en.html"><img alt="GNU Affero General License Version 3" src="https://www.gnu.org/graphics/agplv3-with-text-100x42.png" style="height:31px"/></a> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a><br/>Copyrights (C) 2020 LiteHell, All rights reserved.<br/><div class="Layout_visibleOnPrintOnly__UK6Yl">LiteHell&#x27;s Blog - <a href="https://blog.litehell.info">https://blog.litehell.info</a><br/>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.<br/><br/>Url of this article: <a href="https://blog.litehell.info/post/fcitx5_for_101_key_keyboard_kde_laptop">https://blog.litehell.info/post/fcitx5_for_101_key_keyboard_kde_laptop</a><br/></div><div class="Layout_invisibleOnPrint__rdrDv">Fox Image : Copyrights (C) 2004 Shiretoko-Shari Torurist Association<br/><a href="/license">This blog is free software; For source code and more informations on license and copyrights, Click here.</a><br/><br/>Feeds : <a href="/feed/rss">RSS 2.0</a>,<!-- --> <a href="/feed/atom">Atom 1.0</a>, <a href="/feed/json">Json 1.0</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"metadata":{"title":"한글 입력을 위한 fcitx5 설치","subtitle":"KDE 노트북에서의 버그없는 한글 입력을 위한 삽질기","author":"LiteHell","date":"2023-10-17T12:34:16.790Z","category":"Linux","tags":["Linux","Korean","Hangul","IM","KDE"],"last_modified_at":"2023-10-17T14:32:47.687Z"},"rendered":"\u003ch1 id=\"서론\"\u003e서론\u003c/h1\u003e\n\u003cp\u003e필자는 초창기에 \u003ca href=\"https://github.com/ibus/ibus\"\u003eibus\u003c/a\u003e를 썼었다. ibus는 웬만한 프로그램에서 아무 버그없이 잘 작동한다. 딱 한가지, 리브레오피스에서 공백 입력이 안 된다는 치명적인 버그만 빼면 말이다.\u003c/p\u003e\n\u003cp\u003e그래서 ibus 다음으로 \u003ca href=\"https://github.com/hamonikr/nimf\"\u003e하모니카에서 유지보수하는 nimf\u003c/a\u003e를 썼었다. nimf는 리브레오피스에서의 치명적인 버그는 없었지만, 엔터키를 누르면 텍스트가 사라지는 버그가 있었다. 근데 이 버그, 처음에만 짜증나지 좀 지나면 적응된다. 그래서 적응해서 쓰다가 생각해보니 \u0026#39;이건 좀 아닌 것 같다\u0026#39;싶어서 다른 입력기를 설치했다.\u003c/p\u003e\n\u003cp\u003e본 블로그 글은 \u003ca href=\"https://archlinux.org/\"\u003eArch Linux\u003c/a\u003e를 기준으로 설명한다.\u003c/p\u003e\n\u003ch2 id=\"kde에서의-키보드-레이아웃\"\u003eKDE에서의 키보드 레이아웃\u003c/h2\u003e\n\u003cp\u003e입력기를 바꾸기 위해 삽질하는 과정에서 한글키가 오른쪽 Alt키로 인식되는 현상을 확인했다. 분명히 아치 리눅스 설치 초기에 매핑을 했었는데, 시스템 업데이트를 하는 과정에서 원상복구가 된 것 같다. 그래서 이번에는 KDE 설정 프로그램을 이용해 한글키와 한자키를 매핑했다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/kde_keyboard_settings.png\" alt=\"KDE 키보드 설정 프로그램\"\u003e\u003c/p\u003e\n\u003cp\u003e위와 같이 시스템 설정 프로그램의 \u003cstrong\u003e입력 장치 🠞 키보드\u003c/strong\u003e 화면에서 \u003cstrong\u003e오른쪽 Alt 키를 한/영 키로 만들기\u003c/strong\u003e, \u003cstrong\u003e오른쪽 Ctrl 키를 한자 키로 만들기\u003c/strong\u003e 항목을 체크하면 된다. (키보드 레이아웃에 따라 약간 다를 수 있다.) 노트북 등의 101/104키 호환 레이아웃이라면 위 과정을 반드시 거쳐야 한다.\u003c/p\u003e\n\u003ch3 id=\"한영-한자키-인식여부-확인방법\"\u003e한/영, 한자키 인식여부 확인방법\u003c/h3\u003e\n\u003cp\u003e본인 키보드가 101/104키인지 106키인지 헷갈린다면 \u003cdel\u003e키보드 키 갯수 세지말고\u003c/del\u003e 먼저 \u003ccode\u003exev\u003c/code\u003e 프로그램을 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo pacman -S xorg-xev\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 콘솔 창에서 xev 프로그램을 실행한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003exev\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003exev 프로그램 창을 활성화하고 한글키랑 한자키를 눌러본다. 다음과 같이 콘솔 창에 \u003cem\u003eHangul\u003c/em\u003e이나 \u003cem\u003eHangul_Hanja\u003c/em\u003e키가 인식된 메세지가 출력되면 한/영 키, 한자 키가 정상적으로 인식되는 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eKeyRelease event, serial 39, synthetic NO, window 0x9000001,\n    root 0x79b, subw 0x0, time 1234567, (-10, 10), root:(10, 10),\n    state 0x0, keycode 108 (keysym 0xff31, Hangul), same_screen YES,\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eKeyPress event, serial 39, synthetic NO, window 0x9000001,\n    root 0x79b, subw 0x0, time 1234567, (10, 10), root:(10, 10),\n    state 0x0, keycode 105 (keysym 0xff34, Hangul_Hanja), same_screen YES,\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 위와 같은 메세지가 안 뜨고 Alt_R이나 Control_R이 인식된다면 \u003ca href=\"#kde에서의-키보드-레이아웃\"\u003e위에 써진 내용\u003c/a\u003e에 따라 매핑하면 된다.\u003c/p\u003e\n\u003ch2 id=\"fcitx5-설치-방법\"\u003efcitx5 설치 방법\u003c/h2\u003e\n\u003cp\u003e먼저, 다음 명령어를 실행해 fcitx5를 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo pacman -S fcitx5-im fcitx-hangul\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e/etc/environment\u003c/code\u003e 파일에 다음 내용을 추가한다. 입력기로 fcitx를 쓰도록 지정하는 작업이다.\u003c/p\u003e\n\u003c!-- ini파일이 아니지만 syntax highlighting을 위해 형식을 ini으로 지정함 ---\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ini\"\u003e\u003cspan class=\"hljs-attr\"\u003eGTK_IM_MODULE\u003c/span\u003e=fcitx\n\u003cspan class=\"hljs-attr\"\u003eQT_IM_MODULE\u003c/span\u003e=fcitx\n\u003cspan class=\"hljs-attr\"\u003eQT4_IM_MODULE\u003c/span\u003e=fcitx\n\u003cspan class=\"hljs-attr\"\u003eQT5_IM_MODULE\u003c/span\u003e=fcitx\n\u003cspan class=\"hljs-attr\"\u003eXMODIFIERS\u003c/span\u003e=@im=fcitx\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 다음에 \u003ccode\u003e~/.xprofile\u003c/code\u003e 파일에 다음 내용을 추가한다. 부팅시에 fcitx5가 실행되도록 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003efcitx5 -d\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e재부팅하고 \u003ccode\u003eenv | grep fcitx\u003c/code\u003e 명령어를 실행해 환경변수가 제대로 변경됐는지 확인해보자. 제대로 변경됐다면 다음과 같이 뜰 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eGTK_IM_MODULE=fcitx\nQT4_IM_MODULE=fcitx\nXMODIFIERS=@im=fcitx\nQT5_IM_MODULE=fcitx\nQT_IM_MODULE=fcitx\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 환경변수가 제대로 변경되지 않았다면 \u003ccode\u003e~/.xprofile\u003c/code\u003e 파일에서 \u003ccode\u003efcitx5 -d\u003c/code\u003e 위에 다음 내용을 추가하고 재부팅한다. 그러면 환경변수가 정상적으로 변경될 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e $(/usr/lib/systemd/user-environment-generators/30-systemd-environment-d-generator)\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"fcitx5-설정\"\u003efcitx5 설정\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efcitx5-configtool\u003c/code\u003e 명령어를 실행하면 다음 창이 뜬다.\n\u003cimg src=\"/img/fcitx5_settings_first_screen.png\" alt=\"fcitx5 KDE 설정 창\"\u003e\u003c/p\u003e\n\u003cp\u003e위 화면에서 한국어가 안 보이면 \u003cstrong\u003e입력기 추가\u003c/strong\u003e버튼을 눌러서 추가한다. (입력기 추가 화면에서 한국어가 안 보이면 \u003cstrong\u003e현재 언어만 표시\u003c/strong\u003e 옵션을 해제하면 된다.)\u003c/p\u003e\n\u003cp\u003e밑에서 \u003cstrong\u003e전역 옵션 구성하기...\u003c/strong\u003e 버튼을 누르면 다음 화면이 뜬다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/fcitx5_global_settings.png\" alt=\"fcitx5 KDE 설정 창\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTrigger Input Method\u003c/strong\u003e가 한/영을 전환하는 단축키 설정이다. 오른쪽의 \u003cstrong\u003e+\u003c/strong\u003e 버튼을 눌러 한글 키를 추가하면 된다.\u003c/p\u003e\n\u003cp\u003efcitx5는 기본적으로 한/영을 전환할때 작은 툴팁을 표시한다. 거슬리면 위 화면에서 \u003cstrong\u003eShow Input Method Information when switch input method\u003c/strong\u003e를 체크 해제하면 된다.\u003c/p\u003e\n\u003cp\u003e이제 한글 입력을 버그없이 잘 할 수 있게 됐다. 끝!\u003c/p\u003e\n"},"articleId":"fcitx5_for_101_key_keyboard_kde_laptop","previousPost":{"name":"webpack_and_react_ssg_3","metadata":{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (3)","subtitle":"... + MiniCssExtractPlugin = TA-DA!","author":"LiteHell","date":"2023-07-23T17:25:47.907Z","series":"webpack_and_react_ssg","seriesName":"Webpack과 React를 이용한 정적 웹사이트 만들기","category":"Dev","tags":["React"]},"rendered":"\u003cp\u003e전 글까지 \u003ca href=\"https://webpack.js.org/loaders/style-loader/\"\u003estyle-loader\u003c/a\u003e를 썼다. style-loader는 style 태그를 동적으로 생성하여 CSS를 DOM 안에 주입하는 로더이다. 즉, style-loader를 쓰면 js 스크립트가 실행되면서 style 태그가 동적으로 생성되고, 그 태그 내에 css가 동적으로 삽입되면서 스타일이 적용된다.\u003c/p\u003e\n\u003cp\u003e하지만 정적 페이지로 빌드후 속도가 느린 서버로 게시하거나 스크립트 용량이 비대하면, 스크립트가 완전히 다 실행되기 전까지의 찰나동안 스타일이 적용되지 않은 깨진 페이지가 나타난다. 이런 버그를 막기 위해서는 \u003ca href=\"https://webpack.js.org/plugins/mini-css-extract-plugin/\"\u003eMiniCssExtractPlugin\u003c/a\u003e을 이용하면 된다.\u003c/p\u003e\n\u003cp\u003eMiniCssExtractPlugin은 CSS를 스크립트를 통해 DOM에 주입하지 않고 별도의 CSS 파일에 저장한 뒤, 빌드시에 해당 CSS 파일을 삽입하는 link 태그를 HTML에 삽입한다. 즉 동적으로 CSS를 주입하지 않는다. 따라서 이를 이용하면 스크립트가 완전히 다 실행되기 전까지 페이지 스타일이 적용되지 않는 현상을 해결할 수 있다.\u003c/p\u003e\n\u003cp\u003eMiniCssExtractPlugin을 이용하기 위해서는 먼저 해당 패키지를 설치해야 한다. 다음 명령어로 해당 패키지를 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eyarn add --dev mini-css-extract-plugin\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 다음 \u003ccode\u003ewebpack.config.js\u003c/code\u003e 파일에서 다음 부분을 다음과 같이 수정한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 수정 전\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: {\n        ...commons.module,\n        \u003cspan class=\"hljs-attr\"\u003erules\u003c/span\u003e: [\n            ...commons.module.rules,\n            \u003cspan class=\"hljs-comment\"\u003e// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 \u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// src/index.tsx Webpack 설정에만 추가한다.\u003c/span\u003e\n            {\n                \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/\\.css$/\u003c/span\u003e,\n                use: [\u003cspan class=\"hljs-string\"\u003e\u0026#x27;style-loader\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;css-loader\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;postcss-loader\u0026#x27;\u003c/span\u003e]\n            },\n        ]\n    },\n    \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n        ...commons.plugins,\n        \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e HtmlWebpackPlugin({\n        \u003cspan class=\"hljs-attr\"\u003efilename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;index.html\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-comment\"\u003e// template 속성을 추가한다.\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/index.html\u0026#x27;\u003c/span\u003e\n    })],\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 수정 후\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: {\n        ...commons.module,\n        \u003cspan class=\"hljs-attr\"\u003erules\u003c/span\u003e: [\n            ...commons.module.rules,\n            \u003cspan class=\"hljs-comment\"\u003e// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 \u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// src/index.tsx Webpack 설정에만 추가한다.\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 그리고 프로덕션 빌드시에는 MiniCssExtractPlugin을 이용하여 js가 다 로드되기 전에는\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 스타일이 적용되지 않는 버그를 해결한다.\u003c/span\u003e\n            {\n                \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/\\.css$/\u003c/span\u003e,\n                use: [dev ? \u003cspan class=\"hljs-string\"\u003e\u0026#x27;style-loader\u0026#x27;\u003c/span\u003e : MiniCssExtractPlugin.loader, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;css-loader\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;postcss-loader\u0026#x27;\u003c/span\u003e]\n            },\n        ]\n    },\n    \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n        ...commons.plugins,\n        \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MiniCssExtractPlugin(),\n        \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e HtmlWebpackPlugin({\n        \u003cspan class=\"hljs-attr\"\u003efilename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;index.html\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-comment\"\u003e// template 속성을 추가한다.\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/index.html\u0026#x27;\u003c/span\u003e\n    })],\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같이 수정한 후 정적 웹페이지를 빌드하면 이제 스크립트가 불러와지는동안 스타일이 적용되지 않는 문제가 해결된다.\u003c/p\u003e\n"},"nextPost":{"name":"docker_for_testing","metadata":{"title":"Docker로 테스트하기","subtitle":"Docker로 빌드만 하지 말고 테스트도 하자","author":"LiteHell","date":"2023-10-25T14:49:49.041Z","category":"Dev","tags":["Docker"]},"rendered":"\u003ch1 id=\"들어가는-글\"\u003e들어가는 글\u003c/h1\u003e\n\u003cp\u003e필자는 중앙대학교 공지사항을 \u003ca href=\"https://rss.puang.network\"\u003eRSS\u003c/a\u003e로 만들어서 구독한다. RSS로 만든 후 메신지 봇을 붙이면 알아서 알려주니 편하다.\u003c/p\u003e\n\u003cp\u003e그러나 최근 해당 RSS 프로그램의 테스트가 실패하는 현상이 발견됐다. 확인한 결과, \u003ca href=\"https://swedu.cau.ac.kr\"\u003e중앙대학교 SW교육원\u003c/a\u003e 홈페이지의 TLS 인증서 이슈였던 것으로 확인됐다. 따라서 이를 해결하기 위해 일단 실행되고 있는 Docker 컨테이너에 직접 접근해서 해당 사이트의 CA 인증서를 설치했다.\u003c/p\u003e\n\u003ch1 id=\"기존-테스트-방법의-한계점\"\u003e기존 테스트 방법의 한계점\u003c/h1\u003e\n\u003cp\u003e버그는 일단 임시방편으로 수정한 것이니 레포에는 반영되지 않았다. 따라서 테스트 실패 메일이 매일매일 내 메일함으로 전송됐다.\u003c/p\u003e\n\u003cp\u003e어떻게 하면 이 버그를 수정하고 잘 테스트할 수 있을까? 먼저 이 버그를 수정하려면 Dockerfile을 수정해야 한다. Dockerfile에 다음 내용을 추가하여 Docker 이미지 빌드시 CA 인증서를 복사하도록 했다. \u003ca href=\"https://github.com/LiteHell/cau-rss/commit/d765d53d61e9370f5a284068ed273570d21013a3\"\u003eLiteHell/cau-rss 레포의 커밋 21013a3\u003c/a\u003e에서 확인할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Dockerfile\"\u003e\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e swedu-cert.pem /usr/\u003cspan class=\"hljs-built_in\"\u003elocal\u003c/span\u003e/share/ca-certificates/swedu-cert.crt\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e cat /usr/\u003cspan class=\"hljs-built_in\"\u003elocal\u003c/span\u003e/share/ca-certificates/swedu-cert.crt \u0026gt;\u0026gt; /etc/ssl/certs/ca-certificates.crt\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 위 버그 수정도 같이 테스트해야 한다. 아래에 있는 기존의 GitHub Action으로는 이 버그 수정을 테스트할 수 없다. \u003ccode\u003ego test -v ./...\u003c/code\u003e 명령어가 빌드된 Docker 이미지 내에서 실행되는 것이 아니기 때문이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuild\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ego\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ebuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-v\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e./...\u003c/span\u003e\n\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eTest\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ego\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etest\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-v\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e./...\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e어떻게 하면 테스트할 수 있을까? 답은 간단하다. Docker로 테스트도 하면 된다.\u003c/p\u003e\n\u003ch1 id=\"docker를-이용한-테스트\"\u003eDocker를 이용한 테스트\u003c/h1\u003e\n\u003ch2 id=\"multi-stage-빌드\"\u003eMulti-stage 빌드\u003c/h2\u003e\n\u003cp\u003eDocker는 빌드를 여러 단계로 나누어 진행할 수 있다. 아래 예시 Dockerfile을 보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Dockerfile\"\u003e\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e node AS base\n\u003cspan class=\"hljs-keyword\"\u003eWORKDIR\u003c/span\u003e\u003cspan class=\"bash\"\u003e /app\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eADD\u003c/span\u003e\u003cspan class=\"bash\"\u003e src package.json package-lock.json tsconfig.json .\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e npm i\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e npm bulid\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;yarn\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;start\u0026quot;\u003c/span\u003e]\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTypescript 프로젝트를 위한 간단한 Dockerfile이다. 이를 다음과 같이 여러개의 단계(stage)로 쪼갤 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Dockerfile\"\u003e\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e node AS base\n\u003cspan class=\"hljs-keyword\"\u003eWORKDIR\u003c/span\u003e\u003cspan class=\"bash\"\u003e /app\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eADD\u003c/span\u003e\u003cspan class=\"bash\"\u003e src package.json package-lock.json tsconfig.json .\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e base AS deps\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e npm i\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e deps AS build\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e npm bulid\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e build As deployment\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;yarn\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;start\u0026quot;\u003c/span\u003e]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같은 Dockerfile을 이용하면 Docker 빌드시 특정 스테이지까지만 빌드할 수 있다. 예를 들어 아래 명령어는 deps 스테이지까지만 빌드한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003edocker build --target deps\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e스테이지가 직선적이여야 할 필요는 없다. 다음과 같이 스테이지가 중간에 분기하도록 작성할 수도 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Dockerfile\"\u003e\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e node AS base\n\u003cspan class=\"hljs-keyword\"\u003eWORKDIR\u003c/span\u003e\u003cspan class=\"bash\"\u003e /app\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eADD\u003c/span\u003e\u003cspan class=\"bash\"\u003e src package.json package-lock.json tsconfig.json .\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e base AS deps\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e npm i\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e deps AS build\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e npm bulid\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e build As english\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e english .\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e english As deployment-international\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;yarn\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;start\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;--lang=english\u0026quot;\u003c/span\u003e]\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e build As korean\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e korean .\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e korean AS deployment-domestic\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;yarn\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;start\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;--lang=korean\u0026quot;\u003c/span\u003e]\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 Dockerfile의 경우 build 스테이지에서 english 스테이지와 korean 스테이지로 분기한다.\u003c/p\u003e\n\u003ch3 id=\"buildkit\"\u003eBuildKit\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Dockerfile\"\u003e\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e node AS base\n\u003cspan class=\"hljs-keyword\"\u003eWORKDIR\u003c/span\u003e\u003cspan class=\"bash\"\u003e /app\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eADD\u003c/span\u003e\u003cspan class=\"bash\"\u003e src package.json package-lock.json tsconfig.json .\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e base AS deps\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e npm i\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e deps AS build\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e npm bulid\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e build As english\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e english .\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e english As deployment-international\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;yarn\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;start\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;--lang=english\u0026quot;\u003c/span\u003e]\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e build As korean\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e korean .\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e korean AS deployment-domestic\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;yarn\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;start\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;--lang=korean\u0026quot;\u003c/span\u003e]\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 Dockerfile을 가지고 아래 명령어를 실행한다고 가정해보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003edocker build --target deployment-domestic\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 경우 빌드에 필요한 스테이지는 \u003ccode\u003ebase\u003c/code\u003e, \u003ccode\u003edeps\u003c/code\u003e, \u003ccode\u003ebuild\u003c/code\u003e, \u003ccode\u003ekorean\u003c/code\u003e, \u003ccode\u003edeployment-domestic\u003c/code\u003e이다. 그러나 실제로 위 명령어를 실행해보면 불필요한 \u003ccode\u003eenglish\u003c/code\u003e, \u003ccode\u003edeployment-international\u003c/code\u003e 스테이지도 빌드하는 것을 확인할 수 있다.\u003c/p\u003e\n\u003cp\u003e이는 도커 레거시 빌더를 이용하기 때문에 생기는 문제이다. \u003ca href=\"https://docs.docker.com/build/buildkit/\"\u003eDocker BuildKit\u003c/a\u003e은 사용되지 않는 스테이지를 자동으로 파악하여 불필요한 스테이지는 빌드를 생략한다. 따라서 Docker BuildKit을 설치한 후 다음 명령어로 빌드하면 필요한 스테이지만 빌드할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eDOCKER_BUILDKIT=1 docker build --target deployment-domestic\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"multi-stage-빌드를-이용한-테스트\"\u003eMulti-stage 빌드를 이용한 테스트\u003c/h2\u003e\n\u003cp\u003e이제 Docker를 이용해 테스트를 하는 방법에 대해 알아보자. 다음은 \u003ca href=\"https://github.com/LiteHell/cau-rss\"\u003ecau-rss 레포\u003c/a\u003e의 Dockerfile 내용을 약간 수정한 예시이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Dockerfile\"\u003e\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e golang:alpine as base\n\u003cspan class=\"hljs-keyword\"\u003eWORKDIR\u003c/span\u003e\u003cspan class=\"bash\"\u003e /app\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e go.mod go.sum ./\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e go mod download \u0026amp;\u0026amp; go mod verify\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e cau_parser ./cau_parser\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e server ./server\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# To avoid tls error from swedu.cau.ac.kr\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e swedu-cert.pem /usr/\u003cspan class=\"hljs-built_in\"\u003elocal\u003c/span\u003e/share/ca-certificates/swedu-cert.crt\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e cat /usr/\u003cspan class=\"hljs-built_in\"\u003elocal\u003c/span\u003e/share/ca-certificates/swedu-cert.crt \u0026gt;\u0026gt; /etc/ssl/certs/ca-certificates.crt\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e static ./static\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e html ./html\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"bash\"\u003e *.go ./\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e base as build\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e go build -v -o ./app ./\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;/app/app\u0026quot;\u003c/span\u003e]\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e base as test\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;go\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;test\u0026quot;\u003c/span\u003e ,\u003cspan class=\"hljs-string\"\u003e\u0026quot;-v\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;./...\u0026quot;\u003c/span\u003e]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebase\u003c/code\u003e 스테이지에서 의존성을 설치한 뒤 각종 필요한 파일들을 복사하고 TLS 인증서 오류 해결을 위한 CA 인증서를 복사한다. \u003ccode\u003etest\u003c/code\u003e 스테이지는 \u003ccode\u003ebase\u003c/code\u003e 스테이지에서 테스트 명령어를 실행하는 스테이지이며, \u003ccode\u003ebuild\u003c/code\u003e 스테이지는 \u003ccode\u003ebase\u003c/code\u003e 스테이지를 바탕으로 도커 이미지를 빌드하는 스테이지이다.\u003c/p\u003e\n\u003cp\u003e따라서 위 Dockerfile을 이용해 \u003ccode\u003ebuild\u003c/code\u003e 스테이지까지 빌드하면 도커 이미지를 만드는 것이며, \u003ccode\u003etest\u003c/code\u003e 스테이지까지 빌드하면 테스트를 실행하게 되는 것이다. 이를 명령어로 나타내면 다음과 같으며, 캐시로 인해 테스트가 진행되지 않는 것을 방지하기 위해 \u003ccode\u003e--no-cache\u003c/code\u003e 매개변수를 추가했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-comment\"\u003e# Test\u003c/span\u003e\nDOCKER_BUILDKIT=1 docker build --no-cache --target \u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e .\n\n\u003cspan class=\"hljs-comment\"\u003e# Build\u003c/span\u003e\nDOCKER_BUILDKIT=1 docker build --target build\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e테스트 실패시 Docker 빌드 오류가 발생한다. 이를 응용하면 다음과 같이 테스트 성공시 빌드를 진행하고, 실패시 오류 메세지를 출력하는 bash 스크립트를 작성할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e DOCKER_BUILDKIT=1\n\ndocker build --no-cache --target \u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e .\ntest_status=$?\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e [ \u003cspan class=\"hljs-variable\"\u003e$test_status\u003c/span\u003e -eq 0 ]; \u003cspan class=\"hljs-keyword\"\u003ethen\u003c/span\u003e\n  docker build --taget build . --tag example-application\n\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;ERROR while testing!\u0026quot;\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efi\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"github-action을-이용한-활용\"\u003eGithub Action을 이용한 활용\u003c/h2\u003e\n\u003cp\u003eGitHub Action을 이용하면 다음과 같이 push시 테스트가 이루어지도록 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eTest\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eon:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epush\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003ejobs:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etest:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eruns-on:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu-latest\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003esteps:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eactions/checkout@v3\u003c/span\u003e\n\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eSet\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eup\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eDocker\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuildx\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edocker/setup-buildx-action@v3\u003c/span\u003e\n\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eTest\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edocker\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ebuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--no-cache\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--target\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etest\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e.\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eenv:\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eDOCKER_BUILDKIT:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e빌드도 잘 되는지 확인하고 싶다면 빌드하는 job을 하나 더 추가하면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eand\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etest\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eon:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epush\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003ejobs:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ebuild:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eruns-on:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu-latest\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003esteps:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eactions/checkout@v3\u003c/span\u003e\n\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eSet\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eup\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eDocker\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuildx\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edocker/setup-buildx-action@v3\u003c/span\u003e\n\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuild\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edocker\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ebuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--target\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ebuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e.\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eenv:\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eDOCKER_BUILDKIT:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\n  \u003cspan class=\"hljs-attr\"\u003etest:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eruns-on:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu-latest\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003esteps:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eactions/checkout@v3\u003c/span\u003e\n\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eSet\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eup\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eDocker\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eBuildx\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edocker/setup-buildx-action@v3\u003c/span\u003e\n\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eTest\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edocker\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ebuild\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--no-cache\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--target\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etest\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e.\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eenv:\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eDOCKER_BUILDKIT:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"결론\"\u003e결론\u003c/h1\u003e\n\u003cp\u003eDocker 이미지로 배포를 진행하는 경우, Docker로 테스트도 같이 진행하면 실제 배포 환경과 유사한 환경에서 테스트를 진행할 수 있다는 큰 장점이 있다. 따라서 복잡한 어플리케이션이라면 이 글을 참고해 Docker로 테스트도 같이 하는 것이 좋은 선택이 될 수 있다.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[id]","query":{"id":"fcitx5_for_101_key_keyboard_kde_laptop"},"buildId":"-Jnmemo0XHj-EY0Cns6cx","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>