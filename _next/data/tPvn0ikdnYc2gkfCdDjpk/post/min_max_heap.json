{"pageProps":{"article":{"metadata":{"title":"최소-최대 힙(Min-max heap) 구현하기 (백준 7662번 이중 우선순위 큐 문제)","subtitle":"최소값과 최대값을 동시에 구할 수 있는 힙 자료구조","author":"LiteHell","date":"2023-05-03T15:24:12.104Z","category":"Dev (PS)","tags":["Heap"]},"rendered":"<h1 id=\"백준-7662번-이중-우선순위-큐-문제\">백준 7662번 이중 우선순위 큐 문제</h1>\n<p><a href=\"https://www.acmicpc.net/problem/7662\">백준 이중 우선순위 큐 문제</a>는 본 글에서 소개하는 최소-최대 힙(Min-max heap)을 구현하면 풀리는 문제이다.</p>\n<p>필자는 최소-최대 힙을 시도하기에 앞서 다른 방법(최소 힙이랑 최대 힙 두개 만들기)을 시도했었으나 능력이 부족한 탓인지 실패했다. 따라서 이 방법의 정석적인 풀이방법인 최소-최대 힙을 <a href=\"https://en.wikipedia.org/wiki/Min-max_heap\">영문 위키백과의 Min-max heap 문서</a>을 보면서 풀었다. 이 글에서는 최소-최대 힙에 대해 설명하고 C++ 구현 코드를 제시하고자 한다.</p>\n<h2 id=\"heap이란\">Heap이란?</h2>\n<p>Heap은 최소값이나 최대값 등을 빠르게 구하기 위해 만들어진 완전 이진 트리(Complete binary tree) 형태의 자료구조이다. 일반적으로 Heap이라고 말할 때는 보통 최대 힙(Max-heap)이나 최소 힙(Min-heap)을 의미한다. 이 중에서 최대 힙은 다음과 같이 구현된다.</p>\n<ul>\n<li>추가<ol>\n<li>추가하고자 하는 값을 힙 자료구조의 맨 뒤에 넣는다.</li>\n<li>추가된 값을 부모 원소와 비교한다.<ul>\n<li>만약 부모보다 작거나 같다면 멈춘다.</li>\n<li>만약 부모보다 크다면 부모와 자리를 바꾼다.</li>\n</ul>\n</li>\n<li>다시 2번으로 되돌아간다.</li>\n</ol>\n</li>\n<li>최대값 삭제<ol>\n<li>최대 힙에서는 루트에 있는 값이 항상 최대값이다. 따라서 루트를 삭제하고 힙의 맨 뒤에 있는 값을 루트로 옮긴다. 이 루트로 옮겨진 원소를 A라 하자.</li>\n<li>A를 가장 큰 값을 가진 자식과 비교한다.<ul>\n<li>만약 자식이 더 크다면 자식과 자리를 바꾼다.</li>\n<li>만약 자식이 더 작거나 같다면 멈춘다.</li>\n</ul>\n</li>\n<li>다시 2번으로 되돌아간다.</li>\n</ol>\n</li>\n</ul>\n<p>최소 힙은 위에서 비교하는 방향만 돌려서 다음과 같이 구현하면 된다.</p>\n<ul>\n<li>추가<ol>\n<li>추가하고자 하는 값을 힙 자료구조의 맨 뒤에 넣는다.</li>\n<li>추가된 값을 부모 원소와 비교한다.<ul>\n<li>만약 부모보다 크거나 같다면 멈춘다.</li>\n<li>만약 부모보다 작다면 부모와 자리를 바꾼다.</li>\n</ul>\n</li>\n<li>다시 2번으로 되돌아간다.</li>\n</ol>\n</li>\n<li>최소값 삭제<ol>\n<li>최대 힙에서는 루트에 있는 값이 항상 최소값이다. 따라서 루트를 삭제하고 힙의 맨 뒤에 있는 값을 루트로 옮긴다. 이 루트로 옮겨진 원소를 A라 하자.</li>\n<li>A를 가장 작은 값을 가진 자식과 비교한다.<ul>\n<li>만약 자식이 더 작다면 자식과 자리를 바꾼다.</li>\n<li>만약 자식이 더 크거나 같다면 멈춘다.</li>\n</ul>\n</li>\n<li>다시 2번으로 되돌아간다.</li>\n</ol>\n</li>\n</ul>\n<p>위와 같이 구현된 최대 힙에서는 항상 가장 큰 값을 가진 원소가 루트가 되며, 최소 힙에서는 가장 작은 값을 가진 원소가 항상 루트가 된다. 즉, 최대 힙을 이용하면 주어진 값들 중에서 최댓값을 빠르게 구할 수 있으며, 최소 힙을 이용하면 최소값을 빠르게 구할 수 있다.</p>\n<p>그렇다면 여기서 궁금증이 하나 생긴다, 최댓값과 최소값을 둘 다 빠르게 구할 수 있는 힙 자료구조가 있을까? 이에 대한 정답은 본 글에서 소개하고자 하는 최소-최대 힙이다.</p>\n<h2 id=\"최소-최대-힙\">최소-최대 힙</h2>\n<p>Min-max heap(최소-최대 힙)은 홀수번째 레벨(이하 Min-level)의 원소는 그 밑에 있는 모든 원소들보다 작거나 같은 값을 가지며, 짝수번째 레벨(이하 Max-level)의 원소는 그 밑에 있는 모든 원소들보다 크거나 같은 값을 가진다. 루트가 있는 레벨은 Min-level이다.</p>\n<p><img src=\"/img/min_max_heap/example.svg\" alt=\"예시 Min-max heap\"></p>\n<p>위 예시를 보자. Min-level에 있는 원소는 그 하위에 있는 원소들보다 작은 값을 가지며, Max-level에 있는 원소는 그 밑에 있는 원소들보다 큰 값을 가진다.</p>\n<p>따라서 우리는 최소-최대 힙에서 (루트는 Min-level이므로) 루트는 항상 힙의 최소값을 가지며, 2번째 레벨에 있는(루트 바로 밑 레벨에 있는) 두 원소 중 가장 큰 값이 힙의 최댓값을 나타냄을 알 수 있다.</p>\n<h2 id=\"구현\">구현</h2>\n<p>최소-최대 힙의 구현은 다음과 같이 이루어진다.</p>\n<ul>\n<li>추가<ul>\n<li>새로운 값을 추가할 때는 힙의 맨 뒤에 값을 추가한 뒤 그 값을 위로 올려가며(Push-up) 적절한 자리를 찾아 힙 자료구조를 완성한다.</li>\n</ul>\n</li>\n<li>최소/최대값 확인<ul>\n<li>최소값을 읽을 때는 루트의 값을 읽는다.</li>\n<li>최대값을 읽을 때는 루트의 직계자식들 중 가장 큰 값을 읽는다.</li>\n</ul>\n</li>\n<li>삭제<ul>\n<li>최소값이나 최대값을 삭제한 뒤에는, 힙의 맨 뒤에 있는 값을 최소값이나 최대값이 있던 자리로 옮기고, 그 값을 아래로 내려가며(Push-down) 적절한 자리를 찾아 힙 자료구조를 완성한다.</li>\n</ul>\n</li>\n</ul>\n<p>위를 구현하기 위해서는 Push-up과 Push-down 알고리즘을 구현해야 한다.</p>\n<h2 id=\"push-up의-구현\">Push-Up의 구현</h2>\n<p>예시를 들어 설명해보자. 다음 예시를 보라.</p>\n<p><img src=\"/img/min_max_heap/pushup/step1.svg\" alt=\"예시 Min-max heap\"></p>\n<p>위 그래프는 유효한 최소-최대힙이다. 위 그래프의 맨 끝에 3이라는 값을 추가했다고 가정해보자. 3을 추가할 시 아래와 같이 변한다.</p>\n<p><img src=\"/img/min_max_heap/pushup/step2.svg\" alt=\"예시 Min-max heap\"></p>\n<p>값을 추가하는 순간 유효한 최소-최대 힙이 아니게 된다. Min-level에 있는 6보다 더 작은 자식 3이 생기기 때문이다.</p>\n<p>따라서 이 그래프를 다시 최소-최대 힙으로 만들기 위해서는 원소 3을 위로 올려가면서 적절한 위치를 찾아야 한다.\n먼저, 추가한 값인 3이 Min-level에 있는 부모(6)보다 작다. 이는 최소-최대 힙의 조건과 모순되므로 부모와 추가된 값의 위치를 서로 바꿔준다.</p>\n<p><img src=\"/img/min_max_heap/pushup/step3.svg\" alt=\"에시 Min-max heap\"></p>\n<p>추가된 값이 부모와 바꿔지면서 Min-level로 옮겨졌음을 확인할 수 있다. 이제 3은 3을 루트로 하는 서브트리 내에서만큼은 무결하다. 왜나하면, 최소-최대 힙에서 루트에 있던 값은 그 밑의 모든 값들보다 작거나(혹은 루트의 레벨에 따라서, 크거나) 같아야 한다는 특징이 있는데, 이 값이 (6에서 3으로) 더 작아지는 것이 이 특징을 깨트리지 않음은 자명하기 때문이다.</p>\n<p>그러나, 위 그래프는 아직도 최소-최대 힙의 특징을 만족하지 못한다. 5번째 레벨의 원소(값: 4)와 7번째 레벨의 원소(값: 5)를 보라. 5번째 레벨과 7번째 레벨은 홀수번째 레벨이므로 Min-level이다. 따라서 원소 4의 하위 원소들은 모두 값이 4보다 크거나 같아야 하고, 원소 5의 하위 원소들도 모두 값이 5보다 크거나 같아야 한다. 그러나 원소 3은 5나 4보다 크거나 같지 않다. 원소 5(혹은 4)의 하위 원소인 원소 3이 5(혹은 4)보다 작은 값을 가지므로 최소-최대 힙의 조건과 모순된다.</p>\n<p>따라서 이 모순을 해결하기 위해, 원소 3을 상위의 Min-level에 있는 원소(위 사진에서 파란색으로 표시된 원소들)들과 비교하며 적절한 위치를 찾아야 한다. 원소 3을 파란색으로 표시된 원소들과 비교하여 위로 올려가며 적절한 위치를 찾은 결과는 다음과 같다.</p>\n<p><img src=\"/img/min_max_heap/pushup/step4.svg\" alt=\"에시 Min-max heap\"></p>\n<p>최소-최대 힙에 값 6이 성공적으로 추가됐음을 알 수 있다.</p>\n<p>따라서 우리는 이 예시가 다음과 같은 알고리즘에 따라 이루어졌음을 알 수 있다.</p>\n<ol>\n<li>추가된 값(이하 원소 A)을 힙의 맨 뒤에 추가한다. A가 Max-level에 추가됐다고 가정하자.</li>\n<li>A를 부모 원소와 비교한다.<ol>\n<li>A가 부모 원소보다 작거나 같다면 A와 부모 원소를 서로 바꾼다.</li>\n</ol>\n</li>\n<li>A를 A의 조부모 원소와 비교한다.<ul>\n<li>만약 A가 Min-level이고 A가 조부모보다 더 작다면, A와 조부모의 위치를 서로 바꾼다.</li>\n<li>만약 A가 Max-level이고 A가 조부모보다 더 크다면, A와 조부모의 위치를 서로 바꾼다.</li>\n<li>서로 바꿀 필요가 없다면 멈춘다.</li>\n</ul>\n</li>\n<li>3번으로 되돌아간다.</li>\n</ol>\n<p>위 알고리즘을 A가 처음에 Min-level에 추가된 경우로까지 확장하면 다음과 같다.</p>\n<ol>\n<li>추가된 값(이하 원소 A)을 힙의 맨 뒤에 추가한다.</li>\n<li>A를 부모 원소와 비교한다.<ul>\n<li>A가 Max-level에 있고, A가 부모 원소보다 작거나 같다면 A와 부모 원소를 서로 바꾼다.</li>\n<li>A가 Min-level에 있고, A가 부모 원소보다 크거나 같다면 A와 부모 원소를 서로 바꾼다.</li>\n</ul>\n</li>\n<li>A를 A의 조부모 원소와 비교한다.<ul>\n<li>만약 A가 Min-level이고 A가 조부모보다 더 작다면, A와 조부모의 위치를 서로 바꾼다.</li>\n<li>만약 A가 Max-level이고 A가 조부모보다 더 크다면, A와 조부모의 위치를 서로 바꾼다.</li>\n<li>서로 바꿀 필요가 없다면 멈춘다.</li>\n</ul>\n</li>\n<li>3번으로 되돌아간다.</li>\n</ol>\n<p>위 알고리즘이 최소-최대 힙의 Push-Up 알고리즘이다. 이 알고리즘을 이용하면 원소의 추가를 구현할 수 있다.</p>\n<h2 id=\"push-down의-구현\">Push-down의 구현</h2>\n<p>Push-down은 다음과 같이 구현한다. 먼저, 아래와 같은 유효한 최소-최대 힙이이 있다고 가정하자.</p>\n<p><img src=\"/img/min_max_heap/pushdown/step1.svg\" alt=\"Min-max heap\"></p>\n<p>위 힙에서 최소값을 제거하고 최소값이 있던 자리(루트)에 8을 넣었다고 가정해보자. 그 결과는 다음과 같다.</p>\n<p><img src=\"/img/min_max_heap/pushdown/step2.svg\" alt=\"Min-max heap\"></p>\n<p>위 그래프는 유효한 최소-최대 힙이 아니다. 따라서 이 그래프를 최소-최대 힙으로 만들기 위해서는 원소들의 위치를 아래로 내려가며 조정해야 한다.</p>\n<p>먼저, 위 그래프에서 원소 8은 Min-level에 있다. 따라서 원소 8의 자식(Child)과 손자(Grandchild)들중 가장 작은 값을 가진 원소를 확인한다. 이 원소는 2이다.</p>\n<p>원소 2가 원소 8보다 더 작음은 Min-max heap의 조건에 모순된다. 따라서 원소 2와 원소 8의 위치를 서로 바꾼다.</p>\n<p><img src=\"/img/min_max_heap/pushdown/step3.svg\" alt=\"Min-max heap\"></p>\n<p>원소 2와 원소 8의 위치를 서로 바꾸었지만 Max-level에 있는 원소 7이 자식인 원소 8보다 더 작은 값을 가지고 있다. 이는 모순이다. 따라서 원소 7과 원소 8의 위치를 서로 바꾼다.</p>\n<p><img src=\"/img/min_max_heap/pushdown/step4.svg\" alt=\"Min-max heap\"></p>\n<p>이제 원소 2는 하위에 있는 모든 원소들보다 작은 값을 가지고, 원소 8은 하위에 있는 모든 원소들보다 큰 값을 가진다. 원소 7 위로는 Min-max heap의 조건과 모순되는 원소가 없다. 그러나 원소 7의 밑을 보라. 원소 7은 Min-level이므로 원소 7 하위의 모든 원소들보다 작거나 같은 값을 가져야 한다. 그러나 원소 6, 3, 5, 4로 인하여 이 조건이 만족되지 않는다.</p>\n<p>이를 해결하기 위해 원소 7의 자식과 손자들 중 가장 작은 값을 가진 원소를 찾는다. 이러한 원소는 3이다. 원소 3으로 인하여 원소 7이 Min-level의 조건을 만족하지 않으니 원소 3과 원소 7의 위치를 서로 바꾼다.</p>\n<p><img src=\"/img/min_max_heap/pushdown/step5.svg\" alt=\"Min-max heap\"></p>\n<p>원소 7의 부모는 Max-level이므로 원소 7의 부모는 원소 7보다 더 크거나 같은 값을 가져야 한다. 그러나 부모 원소의 값은 6이므로 7보다 크거나 같은 값이 아니다. 따라서 원소 7과 6의 위치를 서로 바꾼다.</p>\n<p><img src=\"/img/min_max_heap/pushdown/step6.svg\" alt=\"Min-max heap\"></p>\n<p>이제 원소 6 위의 모든 원소들 (2, 8, 3, 7)들은 Min-level과 Max-level의 조건을 만족한다. 그러나 원소 6은 Min-level의 조건을 만족하지 못한다. 따라서 원소 6이 Min-level의 조건을 만족하도록 하기 위해 원소 6의 자식과 손자들 중 가장 작은 값을 가진 원소를 찾는다. 이 원소는 4이다. 원소 4는 Min-level인 원소 6의 손자임이도 불구하고 6보다 작은 값을 가지고 있다. 이는 모순이므로 원소 6과 4의 위치를 바꾼다.</p>\n<p><img src=\"/img/min_max_heap/pushdown/step7.svg\" alt=\"Min-max heap\"></p>\n<p>원소 6의 부모를 보자. 원소 6의 부모의 값은 5인데, 이 부모 원소는 Max-level에 있다. 이는 모순이다. 이 모순을 해결하기 위해 원소 6과 원소 5의 위치를 서로 바꾼다.</p>\n<p><img src=\"/img/min_max_heap/pushdown/step8.svg\" alt=\"Min-max heap\"></p>\n<p>이제 유효한 Min-max heap이 만들어졌음을 확인할 수 있다. 이 예시로부터 알고리즘을 도출하면 다음과 같다.</p>\n<ul>\n<li>주어진 원소 A에 대하여, 만약 A가 Min-level이라면<ol>\n<li>자식과 손자들 중 가장 작은 값을 가진 원소를 B라고 하고 B의 인덱스를 <code>i</code>라고 하자.</li>\n<li>만약 B가 A보다 더 작은 값을 가지고 있고.<ul>\n<li>B가 A의 손자라면<ol>\n<li>B와 A의 위치를 서로 바꾼다.</li>\n<li>만약 A가 A의 부모보다 더 큰 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.</li>\n<li><code>i</code>번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.</li>\n</ol>\n</li>\n<li>B가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>위 알고리즘을 A가 Max-level인 경우로까지 확장하면 다음과 같다.</p>\n<ul>\n<li>주어진 원소 A에 대하여<ul>\n<li>만약 A가 Min-level이라면<ol>\n<li>자식과 손자들 중 가장 작은 값을 가진 원소를 B라고 하고 B의 인덱스를 <code>i</code>라고 하자.</li>\n<li>만약 B가 A보다 더 작은 값을 가지고 있고.<ul>\n<li>B가 A의 손자라면<ol>\n<li>B와 A의 위치를 서로 바꾼다.</li>\n<li>만약 A가 A의 부모보다 더 큰 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.</li>\n<li><code>i</code>번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.</li>\n</ol>\n</li>\n<li>B가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>만약 A가 Max-level이라면<ol>\n<li>자식과 손자들 중 가장 큰 값을 가진 원소를 B라고 하고 B의 인덱스를 <code>i</code>라고 하자.</li>\n<li>만약 B가 A보다 더 큰 값을 가지고 있고.<ul>\n<li>B가 A의 손자라면<ol>\n<li>B와 A의 위치를 서로 바꾼다.</li>\n<li>만약 A가 A의 부모보다 더 작은 값을 가지고 있다면, A와 A의 부모의 위치를 서로 바꾼다.</li>\n<li><code>i</code>번째 위치에 있는 원소에 대하여 이 알고리즘을 다시 실행한다.</li>\n</ol>\n</li>\n<li>B가 A의 손자가 아니라면 B와 A의 위치를 바꾸고 끝낸다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"소스코드-c\">소스코드 (C++)</h2>\n<p>이제 위에서 PushUp과 Pushdown의 구현 알고리즘을 살펴봤으므로 아래와 같이 C++로 구현할 수 있다.</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> INT_SWAP(a,b) int tmp = a; a = b; b = tmp</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> SWAP_HEAP(a,b) INT_SWAP(heap[(a)], heap[(b)])</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> IS_MIN_LEVEL(index) ((int)(std::log2(index)) % 2) == 0</span>\n\n<span class=\"hljs-keyword\">int</span> heapCount = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// How many elements in the heap?</span>\n<span class=\"hljs-keyword\">int</span> heap[<span class=\"hljs-number\">1000001</span>]; <span class=\"hljs-comment\">// Heap, starting from index 1</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insertHeap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> item)</span></span>; <span class=\"hljs-comment\">// inserts an element</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">popMin</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// removes minimum element</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">popMax</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// removes maximum element</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">seekMin</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// reads minimum element</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">seekMax</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// reads maximum element</span>\n\n<span class=\"hljs-comment\">/**\n * Implementation of min/max pop using push-down\n */</span>\n\n<span class=\"hljs-comment\">// Picks index of largest(or smallest) child(or grandchild) of given element</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">pickLargetOrSmallestDescendantIndex</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index, <span class=\"hljs-keyword\">bool</span> largest)</span> </span>{\n    <span class=\"hljs-keyword\">int</span> resultIndex = index * <span class=\"hljs-number\">2</span>, resultValue = heap[index * <span class=\"hljs-number\">2</span>];\n    <span class=\"hljs-keyword\">int</span> candids[] = { <span class=\"hljs-comment\">// Children and grandchildren</span>\n        index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// Right child</span>\n        index * <span class=\"hljs-number\">4</span>, <span class=\"hljs-comment\">// 1st grandchild (Left child of left child)</span>\n        index * <span class=\"hljs-number\">4</span> + <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// 2nd grandchild (Right child of left cihld)</span>\n        index * <span class=\"hljs-number\">4</span> + <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// 3rd grandchild (Left child of right child)</span>\n        index * <span class=\"hljs-number\">4</span> + <span class=\"hljs-number\">3</span> <span class=\"hljs-comment\">// 4th grandchild (Right child of right child)</span>\n    };\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> candidIndex: candids) {\n        <span class=\"hljs-keyword\">if</span> (candidIndex &gt; heapCount)\n            <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">// If it&#x27;s invalid index, continue</span>\n\n        <span class=\"hljs-keyword\">if</span> (largest &amp;&amp; resultValue &lt; heap[candidIndex]) {\n            resultValue = heap[candidIndex];\n            resultIndex = candidIndex;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!largest &amp;&amp; resultValue &gt; heap[candidIndex]) {\n            resultValue = heap[candidIndex];\n            resultIndex = candidIndex;\n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> resultIndex;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pushDownMin</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index)</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pushDownMax</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index)</span></span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pushDown</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (IS_MIN_LEVEL(index)) {\n        pushDownMin(index);\n    } <span class=\"hljs-keyword\">else</span> {\n        pushDownMax(index);\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pushDownMin</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (index * <span class=\"hljs-number\">2</span> &lt;= heapCount) { <span class=\"hljs-comment\">// if has children</span>\n        <span class=\"hljs-keyword\">int</span> m = pickLargetOrSmallestDescendantIndex(index, <span class=\"hljs-literal\">false</span>);\n\n        <span class=\"hljs-keyword\">if</span> (m &gt;= index * <span class=\"hljs-number\">4</span>) { <span class=\"hljs-comment\">// if m is a grandchild</span>\n            <span class=\"hljs-keyword\">if</span> (heap[m] &lt; heap[index]) {\n                SWAP_HEAP(m, index);\n                <span class=\"hljs-keyword\">if</span> (heap[m] &gt; heap[m / <span class=\"hljs-number\">2</span>]) {\n                    SWAP_HEAP(m, m / <span class=\"hljs-number\">2</span>);\n                }\n                pushDown(m);\n            }\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (heap[m] &lt; heap[index]) {\n            SWAP_HEAP(m, index); \n        }\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pushDownMax</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (index * <span class=\"hljs-number\">2</span> &lt;= heapCount) { <span class=\"hljs-comment\">// if has children</span>\n        <span class=\"hljs-keyword\">int</span> m = pickLargetOrSmallestDescendantIndex(index, <span class=\"hljs-literal\">true</span>);\n\n        <span class=\"hljs-keyword\">if</span> (m &gt;= index * <span class=\"hljs-number\">4</span>) { <span class=\"hljs-comment\">// if m is a grandchild</span>\n            <span class=\"hljs-keyword\">if</span> (heap[m] &gt; heap[index]) {\n                SWAP_HEAP(m, index);\n                <span class=\"hljs-keyword\">if</span> (heap[m] &lt; heap[m / <span class=\"hljs-number\">2</span>]) {\n                    SWAP_HEAP(m, m / <span class=\"hljs-number\">2</span>);\n                }\n                pushDown(m);\n            }\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (heap[m] &gt; heap[index]) {\n            SWAP_HEAP(m, index); \n        }\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">popMin</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (heapCount &lt;= <span class=\"hljs-number\">0</span>)\n        <span class=\"hljs-keyword\">return</span>;\n    <span class=\"hljs-comment\">// Removes minimum element</span>\n    heap[<span class=\"hljs-number\">1</span>] = heap[heapCount--];\n    <span class=\"hljs-comment\">// Push down root element to make the heap valid min-max heap</span>\n    pushDown(<span class=\"hljs-number\">1</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">popMax</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (heapCount &lt;= <span class=\"hljs-number\">0</span>)\n        <span class=\"hljs-keyword\">return</span>;\n\n    <span class=\"hljs-keyword\">int</span> index;\n    <span class=\"hljs-keyword\">if</span> (heapCount == <span class=\"hljs-number\">1</span>)\n        index = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (heapCount == <span class=\"hljs-number\">2</span>)\n        index = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-keyword\">else</span>\n        index = heap[<span class=\"hljs-number\">2</span>] &gt; heap[<span class=\"hljs-number\">3</span>] ? <span class=\"hljs-number\">2</span> : <span class=\"hljs-number\">3</span>;\n\n    <span class=\"hljs-comment\">// Removes maximum element</span>\n    heap[index] = heap[heapCount--];\n    <span class=\"hljs-comment\">// Push down to root element make the heap valid min-max heap</span>\n    pushDown(index);\n}\n\n<span class=\"hljs-comment\">/**\n * Implementation of insertion using push-up\n */</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pushUpMin</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (index &gt;= <span class=\"hljs-number\">4</span> &amp;&amp; <span class=\"hljs-comment\">// if index &gt;= 4, it must have a grandparent.</span>\n        heap[index] &lt; heap[index / <span class=\"hljs-number\">4</span>]) {\n            SWAP_HEAP(index, index / <span class=\"hljs-number\">4</span>);\n            pushUpMin(index / <span class=\"hljs-number\">4</span>);\n        }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pushUpMax</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (index &gt;= <span class=\"hljs-number\">4</span> &amp;&amp; <span class=\"hljs-comment\">// if index &gt;= 4, it must have a grandparent.</span>\n        heap[index] &gt; heap[index / <span class=\"hljs-number\">4</span>]) {\n            SWAP_HEAP(index, index / <span class=\"hljs-number\">4</span>);\n            pushUpMax(index / <span class=\"hljs-number\">4</span>);\n        }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pushUp</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (index != <span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-keyword\">if</span> (IS_MIN_LEVEL(index)) {\n            <span class=\"hljs-keyword\">if</span> (heap[index] &gt; heap[index / <span class=\"hljs-number\">2</span>]) {\n                SWAP_HEAP(index, index / <span class=\"hljs-number\">2</span>);\n                pushUpMax(index / <span class=\"hljs-number\">2</span>);\n            } <span class=\"hljs-keyword\">else</span> {\n                pushUpMin(index);\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (heap[index] &lt; heap[index / <span class=\"hljs-number\">2</span>]) {\n                SWAP_HEAP(index, index / <span class=\"hljs-number\">2</span>);\n                pushUpMin(index / <span class=\"hljs-number\">2</span>);\n            } <span class=\"hljs-keyword\">else</span> {\n                pushUpMax(index);\n            }\n        }\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insertHeap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> item)</span> </span>{\n    heap[++heapCount] = item;\n    pushUp(heapCount);\n}\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">seekMin</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> heap[<span class=\"hljs-number\">1</span>];\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">seekMax</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (heapCount == <span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-keyword\">return</span> heap[<span class=\"hljs-number\">1</span>];\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (heapCount == <span class=\"hljs-number\">2</span>) {\n        <span class=\"hljs-keyword\">return</span> heap[<span class=\"hljs-number\">2</span>];\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">std</span>::max(heap[<span class=\"hljs-number\">2</span>], heap[<span class=\"hljs-number\">3</span>]);\n    }\n\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cin</span>.tie(<span class=\"hljs-literal\">NULL</span>);\n    <span class=\"hljs-built_in\">std</span>::ios_base::sync_with_stdio(<span class=\"hljs-literal\">false</span>);\n\n    <span class=\"hljs-comment\">// How many test cases?</span>\n    <span class=\"hljs-keyword\">int</span> t;\n    <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cin</span> &gt;&gt; t;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; t; i++) {\n        <span class=\"hljs-comment\">// How many operations?</span>\n        <span class=\"hljs-keyword\">int</span> q;\n        <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cin</span> &gt;&gt; q;\n\n        <span class=\"hljs-comment\">// Process operations</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; q; j++) {\n            <span class=\"hljs-keyword\">char</span> c;\n            <span class=\"hljs-keyword\">int</span> data;\n            <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cin</span> &gt;&gt; c &gt;&gt; data;\n\n            <span class=\"hljs-keyword\">switch</span>(c) {\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;I&#x27;</span>:\n                    insertHeap(data);\n                    <span class=\"hljs-keyword\">break</span>;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;D&#x27;</span>:\n                    <span class=\"hljs-keyword\">if</span> (data == <span class=\"hljs-number\">-1</span>)\n                        popMin();\n                    <span class=\"hljs-keyword\">else</span>\n                        popMax();\n            }\n        }\n\n        <span class=\"hljs-comment\">// Print result</span>\n        <span class=\"hljs-keyword\">int</span> max = seekMax(), min = seekMin();\n\n        <span class=\"hljs-keyword\">if</span> (heapCount == <span class=\"hljs-number\">0</span>)\n            <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;EMPTY\\n&quot;</span>;\n        <span class=\"hljs-keyword\">else</span>\n            <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; max &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span> &lt;&lt; min &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\n        heapCount = <span class=\"hljs-number\">0</span>;\n    }\n}</code></pre>\n"},"articleId":"min_max_heap","previousPost":{"name":"how_to_fix_no_sound_issue_in_samsung_laptop_ubuntu","metadata":{"title":"삼성 노트북(950XBE) 우분투에서 소리 안 들리는 버그 고치기","subtitle":"한 줄로 고치는 버그","author":"LiteHell","date":"2023-03-18T10:21:27.090Z","category":"Linux","tags":["Linux","Ubuntu"]},"rendered":"<p>나는 삼성 노트북 9 Always(모델명: NT950XBE)를 이용한다. 꽤 괜찮은 노트북인데, 대학에서 운영체제 수업을 듣다보니 우분투를 깔 필요를 느껴서 듀얼부팅으로 설치했다.</p>\n<p>우분투를 설치하고 이용하는 데엔 큰 문제가 없었다, Wine으로 설치한 카카오톡도 잘 작동했다. 그러나 문제는 다른 데 있었다, 소리가 안 들렸다.</p>\n<h1 id=\"어떻게-안-들리나요\">어떻게 안 들리나요?</h1>\n<p>이 소리가 안 들리는 증상을 자세히 서술하면 다음과 같았다.</p>\n<ul>\n<li>노트북 내부 스피커: 아예 작동하지 않음.</li>\n<li>노트북 이어폰 잭: pauvcontrol로 볼륨을 150%까지 올리면 들리긴 하는데 소리가 지지직거린다. 150%까지 안 올리면 들리지도 않는다.</li>\n</ul>\n<p>이어폰 잭은 그래도 <code>sudo hda-verb /dev/snd/hwC0D0 0x1a SET_PIN_WIDGET_CONTROL 0x5</code>명령어를 실행하면 정상적으로 작동은 하는 데 이조차도 영구적인 해결책이 아니었고, 잠시 소리가 idle이 되면 바로 원상복구된다는 한계가 있었다. 영구적으로 해결할 수 있는 방법이 없을까?</p>\n<h2 id=\"생각보다-간단했던-해결방법\">생각보다 간단했던 해결방법</h2>\n<p><a href=\"https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1851518?comments=all\">찾아보니 이미 커널 버그로 보고된 문제였다.</a> 이 버그 보고를 읽다가 문득 &#39;<code>/etc/modprobe.d/alsa-base.conf</code> 파일 맨 밑에 다음 줄을 추가하면 되지 않을까?&#39;라는 생각이 들었다. 그래서 추가했고, 재부팅했다.</p>\n<pre><code># audio fix\noptions snd-hda-intel model=alc298-samsung-amp</code></pre>\n<p>결과는? 해결됐다. 이어폰도 스피커도 매우 잘 작동한다. 커널 버그라서 복잡하게 해결할 줄 알았는데 문제가 손쉽게 해결되서 다행이었다, 메데타시 메데타시.</p>\n"},"nextPost":{"name":"creating_mastodon_instance","metadata":{"title":"Mastodon 서버 구축하기","subtitle":"6$짜리 VPS와 CloudFlare를 이용한 인스턴스 구축","author":"LiteHell","date":"2023-07-22T15:55:38.110Z","category":"Dev","tags":["Mastodon","ActivityPub"]},"rendered":"<h1 id=\"트위터와-페디버스\">트위터와 페디버스</h1>\n<p>확실히 요즘 트위터는 달라졌다. 일론 머스크가 인수한 이후의 트위터는 확실히 뭔가 달라졌다. 뭔가 보여주겠다는 의지의 표출인가?</p>\n<p>이런 새로워진 트위터에 적응하지 못한 사람들은 <a href=\"https://joinmastodon.org\">마스토돈</a>이나 <a href=\"https://misskey-hub.net/\">미스키</a> 등의 <a href=\"https://www.w3.org/TR/activitypub/\">ActivityPub</a>를 구현한 분산형 SNS 인스턴스로 이주하고 있다. 국내의 이런 분산형 SNS는 대표적으로 다음과 같다.</p>\n<ul>\n<li><a href=\"https://twingyeo.kr/\">트잉여</a></li>\n<li><a href=\"https://planet.moe/\">플래닛</a></li>\n<li><a href=\"https://qdon.space/\">큐돈</a></li>\n<li><a href=\"https://ani.work/\">애니워크</a></li>\n<li><a href=\"https://social.silicon.moe\">SifNet Mastodon</a></li>\n<li><a href=\"https://hoto.moe\">hotomoe</a></li>\n</ul>\n<p>위와 같이 서로 AcitivtyPub 등의 프로토콜을 이용해 통신하는 SNS 서비스들의 집합을 <strong>Fediverse</strong>(페디버스)라 일컬는다. 페디버스는 서버간에 서로 통신할 수 있기 때문에 다른 서버에 있는 사용자와도 소통할 수 있다. 즉, 서버 A에서 서버 B에 있는 사람을 팔로우할 수도 있다.</p>\n<h1 id=\"mastodon-설치\">Mastodon 설치</h1>\n<p>분산형 SNS이니 당연히 본인이 직접 서버를 구축하는 것도 가능하다. 따라서 직접 VPS에 마스토돈을 설치했다. VPS 운영체제로는 데비안을 택했고, 사양은 Vultr $6 VPS로 했다.</p>\n<p>설치 자체는 <a href=\"https://docs.joinmastodon.org/admin/install/\">공식 홈페이지의 문서</a>를 따르는 식으로 진행했으나 중간중간 삽질을 약간 했다.</p>\n<h2 id=\"root-계정-전환\">root 계정 전환</h2>\n<p>마스토돈을 설치하기 위해서는 먼저 root 계정으로 전환한다. <code>su</code> 명령어를 이용하면 된다.</p>\n<h2 id=\"의존성-설치\">의존성 설치</h2>\n<p>그 다음, 의존성을 설치해야 한다. 의존성 설치 자체는 공식 홈페이지에 있는 명령어를 복사-붙여넣기하면 끝난다.</p>\n<p>첫번째로 다음 명령어를 실행해 node.js v16을 설치한다.</p>\n<pre><code class=\"hljs language-bash\">curl -sL https://deb.nodesource.com/setup_16.x | bash -</code></pre>\n<p>그리고 다음 명령어를 실행해 PostgreSQL와 기타 다른 의존성들을 설치한다.</p>\n<pre><code class=\"hljs language-bash\">apt install -y curl wget gnupg apt-transport-https lsb-release ca-certificates\nwget -O /usr/share/keyrings/postgresql.asc https://www.postgresql.org/media/keys/ACCC4CF8.asc\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;deb [signed-by=/usr/share/keyrings/postgresql.asc] http://apt.postgresql.org/pub/repos/apt <span class=\"hljs-subst\">$(lsb_release -cs)</span>-pgdg main&quot;</span> &gt; /etc/apt/sources.list.d/postgresql.list\napt update\napt install -y \\\n  imagemagick ffmpeg libpq-dev libxml2-dev libxslt1-dev file git-core \\\n  g++ libprotobuf-dev protobuf-compiler pkg-config nodejs gcc autoconf \\\n  bison build-essential libssl-dev libyaml-dev libreadline6-dev \\\n  zlib1g-dev libncurses5-dev libffi-dev libgdbm-dev \\\n  nginx redis-server redis-tools postgresql postgresql-contrib \\\n  certbot python3-certbot-nginx libidn11-dev libicu-dev libjemalloc-dev</code></pre>\n<h3 id=\"nodejs-버전-확인\">nodejs 버전 확인</h3>\n<p>다만 여기서 주의해야 하는 것이 있다. 시스템에 따라서 nodejs 16버전이 아닌 그보다 더 최신 버전이 설치됐었을 수도 있다.\n상관없지 않냐고? 상관있다, nodejs v16 버전이 아니면 나중에 webpack precompile 과정에서 오류가 난다.</p>\n<p>설치된 nodejs의 버전은 <code>node --version</code> 명령어로 확인할 수 있다.</p>\n<pre><code class=\"hljs language-bash\">$ node --version\nv18.13.0</code></pre>\n<p>이는 데비안 apt 레포지토리에 있는 <code>nodejs</code> 패키지 버전이 16보다 더 최신이기 때문에 발생한 문제이다. 이를 해결하기 위해서는 먼저 <code>sudo apt-cache policy nodejs</code>를 실행해 어떤 버전이 설치 가능한지 확인해야 한다.</p>\n<pre><code class=\"hljs language-bash\">$ sudo apt-cache policy nodejs\nnodejs:\n  Installed: 18.13.0+dfsg1-1\n  Candidate: 18.13.0+dfsg1-1\n  Version table:\n *** 18.13.0+dfsg1-1 500\n        500 https://deb.debian.org/debian bookworm/main amd64 Packages\n        500 https://debian.mirror.constant.com bookworm/main amd64 Packages\n     16.20.1-deb-1nodesource1 500\n        500 https://deb.nodesource.com/node_16.x bookworm/main amd64 Packages\n        100 /var/lib/dpkg/status</code></pre>\n<p>위 예시에서는 <code>18.13.0+dfsg1-1</code>과 <code>16.20.1-deb-1nodesource1</code> 버전이 설치 가능하다. 우리가 필요한 것은 nodejs v16대 버전이니 <code>16.20.1-deb-1nodesource1</code>을 설치할 것이다.</p>\n<p>apt에서 특정한 버전을 지정해 설치하기 위해서는 다음과 같이 명령어를 실행하면 된다.</p>\n<pre><code class=\"hljs language-bash\">$ sudo apt install nodejs=16.20.1-deb-1nodesource1</code></pre>\n<p>그러면 nodejs v16이 정상적으로 설치된 것을 확인할 수 있다.</p>\n<h3 id=\"yarn-설치\">Yarn 설치</h3>\n<p>위에서 nodejs, PostregreSQL 등의 의존성을 다 설치했으면 <a href=\"https://yarnpkg.com\">Yarn</a>을 설치해야 한다. Yarn은 다음 명령어로 설치한다.</p>\n<pre><code class=\"hljs language-bash\">corepack <span class=\"hljs-built_in\">enable</span>\nyarn <span class=\"hljs-built_in\">set</span> version classic</code></pre>\n<p>혹시 위 명령어가 작동하지 않는다면 다음과 같이 npm을 이용해 설치할 수도 있다.</p>\n<pre><code class=\"hljs language-bash\">sudo npm i -g yarn</code></pre>\n<p>만약 위 npm을 이용한 명령어가 npm이 설치되어 있지 않아 실행되지 않는다면 아래 명령어로 npm을 실치할 수 있다.</p>\n<pre><code class=\"hljs language-bash\">curl -qL https://www.npmjs.com/install.sh | sh</code></pre>\n<h2 id=\"ruby-설치\">Ruby 설치</h2>\n<p>이제 Ruby를 설치해야 한다. 먼저 <code>mastodon</code>이라는 이름의 리눅스 계정을 생성한다.</p>\n<pre><code class=\"hljs language-bash\">adduser --disabled-login mastodon</code></pre>\n<p>그리고 쉘을 지정한다. (안 하면 <code>sudo su - mastodon</code> 명령어가 오류날 수 있다.) 아래 명령어에서는 쉘을 bash로 지정했는데, 쉘이 무조건 bash여야 할 필요는 없다. 선호하는 쉘이 있다면 그 쉘로 지정해도 된다.</p>\n<pre><code class=\"hljs language-bash\">chsh -s /bin/bash mastodon</code></pre>\n<p>이제 mastodon으로 계정을 전환하자.</p>\n<pre><code class=\"hljs language-bash\">sudo su - mastodon</code></pre>\n<p>다음 명령어를 모두 실행해 Ruby를 설치한다.</p>\n<pre><code class=\"hljs language-bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/rbenv/rbenv.git ~/.rbenv\n<span class=\"hljs-built_in\">cd</span> ~/.rbenv &amp;&amp; src/configure &amp;&amp; make -C src\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;eval &quot;$(rbenv init -)&quot;&#x27;</span> &gt;&gt; ~/.bashrc\n<span class=\"hljs-built_in\">exec</span> bash\ngit <span class=\"hljs-built_in\">clone</span> https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build\nRUBY_CONFIGURE_OPTS=--with-jemalloc rbenv install 3.0.6\nrbenv global 3.0.6</code></pre>\n<p>Ruby 설치가 완료됐다면 bundler도 설치한다.</p>\n<pre><code class=\"hljs language-bash\">gem install bundler --no-document</code></pre>\n<p>Ruby와 bundler 설치를 마쳤다면 root 유저로 되돌아간다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">exit</span></code></pre>\n<h2 id=\"postgresql-설정\">PostgreSQL 설정</h2>\n<p>공식 문서에서 pgTune을 쓰고 싶으면 쓰라고 나와있는데 필자는 귀찮아서 건너뛰었다.</p>\n<p>PostgreSQL 설정을 위해 다음 명령어로 PostgreSQL 쉘을 띄운다.</p>\n<pre><code class=\"hljs language-bash\">sudo -u postgres psql</code></pre>\n<p>PostgreSQL 쉘이 띄워졌으면 다음 쿼리를 실행해서 SQL 계정을 생성한다.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span> mastodon CREATEDB;</code></pre>\n<p>계정이 생성됐으면 다음 명령을 쳐서 쉘을 빠져나온다.</p>\n<pre><code class=\"hljs language-sql\">\\q</code></pre>\n<h2 id=\"마스토돈-다운로드\">마스토돈 다운로드</h2>\n<p>이제 마스토돈을 다운로드하고 설정할 때가 왔다. 먼저 mastodon 계정으로 전환한다.</p>\n<pre><code class=\"hljs language-bash\">sudo su - mastodon</code></pre>\n<p>다음 명령어를 실행해 최신 stable 버전의 mastodon을 다운로드한다.</p>\n<pre><code class=\"hljs language-bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/mastodon/mastodon.git live &amp;&amp; <span class=\"hljs-built_in\">cd</span> live\ngit checkout $(git tag -l | grep -v <span class=\"hljs-string\">&#x27;rc[0-9]*$&#x27;</span> | sort -V | tail -n 1)</code></pre>\n<p>이제 Ruby 의존성과 JavaScript 의존성을 설치한다.</p>\n<pre><code class=\"hljs language-bash\">bundle config deployment <span class=\"hljs-string\">&#x27;true&#x27;</span>\nbundle config without <span class=\"hljs-string\">&#x27;development test&#x27;</span>\nbundle install -j$(getconf _NPROCESSORS_ONLN)\nyarn install --pure-lockfile</code></pre>\n<h2 id=\"서버-swap-설정-및-nodejs-heap-용량-설정\">서버 swap 설정 및 nodejs heap 용량 설정</h2>\n<p>마스토돈 설정(바로 다음 문단)을 하는 과정에서 Javascript heap out of memory 오류가 발생할 수 있다. 이는 서버에 RAM이 부족하기 때문이다. 이를 해결하기 위해서는 RAM을 더 꽂거나 swap 파일을 형성하고, 그 다음 node 설정을 수정해야 한다.</p>\n<p>먼저 swap파일을 생성하는 방법은 다음과 같다. 용량은 적절하게 바꾸면 된다.</p>\n<pre><code class=\"hljs language-bash\">sudo fallocate -l 2G /tmp-swapfile\nsudo chmod 600 /tmp-swapfile\nsudo mkswap /tmp-swapfile</code></pre>\n<p>생성된 swap파일은 다음과 같이 적용할 수 있다.</p>\n<pre><code class=\"hljs language-bash\">sudo swapon /tmp-swapfile</code></pre>\n<p>위 명령어로 적용된 swap파일은 재부팅이 될 시 다시 적용되지 않으므로 재부팅을 하면 위 명령어를 다시 쳐줘야 한다. 따라서 swap 파일을 영구적으로 적용하기 위해서는 <code>/etc/fstab</code> 파일을 수정해야 하나, 본 글에서는 마스토돈을 설정하는 동안에만 임시적으로 이용할 swap 파일을 생성하는 것이므로 이 파일을 수정하는 방법에 대해서 언급하지 않는다.</p>\n<p>이제 node 설정을 바꾸어야 한다. 먼저 현재 할당한 힙 용량을 다음 명령어로 확인한다.</p>\n<pre><code class=\"hljs language-bash\">node -e <span class=\"hljs-string\">&#x27;console.log(v8.getHeapStatistics().heap_size_limit/(1024*1024))&#x27;</span></code></pre>\n<p>실행하면 다음과 같이 뜰 것이다.</p>\n<pre><code class=\"hljs language-bash\">$ node -e <span class=\"hljs-string\">&#x27;console.log(v8.getHeapStatistics().heap_size_limit/(1024*1024))&#x27;</span>\n495.75</code></pre>\n<p>위 용량을 참고해서 위 용량보다 적당히 더 큰 용량으로 힙 용량을 설정하면 된다. 힙 용량의 설정은 다음 명령어를 마스토돈 설정 명령어 실행 직전에 실행함으로써 할 수 있다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">export</span> NODE_OPTIONS=--max_old_space_size=800</code></pre>\n<h2 id=\"마스토돈-설정\">마스토돈 설정</h2>\n<p>다음 명령어를 실행해 마스토돈 서버를 설정한다.</p>\n<pre><code class=\"hljs language-bash\">RAILS_ENV=production bundle <span class=\"hljs-built_in\">exec</span> rake mastodon:setup</code></pre>\n<p>만약 Javascript heap out of memory 오류가 떴다면 바로 윗 문단에 따라 힙 용량 및 swap 설정을 하고 다음 명령어를 실행하면 된다.</p>\n<pre><code class=\"hljs language-bash\">RAILS_ENV=production bundle <span class=\"hljs-built_in\">exec</span> rails assets:precompile</code></pre>\n<p>성공적으로 실행됐을 시 마스토돈 관리자 비밀번호가 표시될 것이다. 잊지 말고 메모하도록 하자.</p>\n<h2 id=\"nginx-설정\">nginx 설정</h2>\n<p>다음 명령어를 실행한다.</p>\n<pre><code class=\"hljs language-bash\">cp /home/mastodon/live/dist/nginx.conf /etc/nginx/sites-available/mastodon\nln -s /etc/nginx/sites-available/mastodon /etc/nginx/sites-enabled/mastodon</code></pre>\n<p><code>/etc/nginx/sites-available/mastodon</code> 파일에서 <code>example.com</code>을 모두 자신의 마스토돈 도메인(내 경우에는 <code>social.litehell.info</code>)로 바꾼다. 그리고 다음 명령어를 실행한다.</p>\n<pre><code class=\"hljs language-bash\">systemctl reload nginx</code></pre>\n<h2 id=\"cloudflare-origin-certificate-설정\">CloudFlare Origin Certificate 설정</h2>\n<p>필자는 CloudFlare Origin Certificate를 쓴다. CloudFlare에서 Origin Certificate를 생성한 뒤 서버에 저장하고, <code>/etc/nginx/sites-available/mastodon</code> 파일에서 <code>ssl_certificate</code> 속성과 <code>ssl_certificate_key</code>를 다운받은 서버/서버 개인키 경로로 수정하면 된다.</p>\n<h2 id=\"systemd-설정\">systemd 설정</h2>\n<p>아래 명령어를 실행한다.</p>\n<pre><code class=\"hljs language-bash\">cp /home/mastodon/live/dist/mastodon-*.service /etc/systemd/system/\nsystemctl daemon-reload\nsystemctl <span class=\"hljs-built_in\">enable</span> --now mastodon-web mastodon-sidekiq mastodon-streaming\n</code></pre>\n<p>그러면 마스토돈이 실행될 것이다. 이제 즐기면 된다.</p>\n<h2 id=\"cloudflare-최적화로-인한-사이트-깨짐-문제-해결\">CloudFlare 최적화로 인한 사이트 깨짐 문제 해결</h2>\n<p><img src=\"/img/broken_css_mastodon.png\" alt=\"CSS가 정상적으로 불러와지지 않은 마스토돈 인스턴스의 스크린샷\"></p>\n<p>CloudFlare를 쓰면 위와 같이 마스토돈이 깨지는 문제를 겪을 수 있다.\n이는, 무결성을 위해 HTML 내에 CSS 파일의 해시가 포함되어있는데, CloudFlare가 CSS를 자동 최적화하면서 CSS 파일이 변경되고, 이로 인해 해시가 불일치됨에 따라 웹브라우저가 CSS를 불러오지 않음으로써 발생하는 문제이다.</p>\n<p>이 문제는 CloudFlare에서 Auto Minify를 비활성화하고 모든 캐시를 삭제하여 해결할 수 있다.</p>\n<h2 id=\"릴레이-연결\">릴레이 연결</h2>\n<p>마스토돈에 혼자 있으면 외롭다. 이를 극복하기 위해서는 릴레이를 연결해야 한다. 페디버스 내에서 인스턴스는 기본적으로 게시물을 팔로워가 있는 서버에만 전송한다. 따라서 타 서버의 팔로워가 없는 인스턴스는 외로울 수 밖에 없다. 이를 극복하기 위해 릴레이가 있다.</p>\n<p>릴레이는 구독하는 서버들간에 게시물을 나눈다. 릴레이에 구독된 인스턴스가 게시물을 릴레이로 보내면, 릴레이가 구독된 모든 서버들에게 게시물을 전송하는 방식이다. 따라서 릴레이내에 있는 서버간에는 팔로워가 있는지의 여부와 상관없이 게시물이 서로 공유된다.</p>\n<p>한국어권 릴레이는 다음 세가지 릴레이가 있다. 이 릴레이는 모두 화이트리스트이다.</p>\n<ul>\n<li><a href=\"https://relay.mastodon.kr\">한국 Mastodon 인스턴스 연합(가칭) 릴레이</a></li>\n<li><a href=\"https://interstellar.flights\">인터스텔라 릴레이 커뮤니티</a></li>\n<li><a href=\"https://relay.musubi.moe\">musubi.moe</a></li>\n</ul>\n<p>위 릴레이에 가입하기 위해서는 각 릴레이에서 요구하는 조건을 모두 만족시킨 뒤 릴레이측에 가입 신청을 하면 된다. 가입 신청 방법 및 조건은 릴레이마다 다르다. 가입 신청이 받아들여지면 릴레이 관리 페이지(<code>/admin/relays</code>)에서 해당 릴레이에서 안내하는 주소를 추가하면 된다. 참고로 내 경험상 개인 인스턴스라고 딱히 안 받아주진 않았다. 조건만 맞으면 받아주는 것 같으니 조건이 맞는다면 부담없이 신청해보자.</p>\n<p>모든 릴레이가 화이트리스트인 것은 아니다. <a href=\"https://relaylist.com\">RelayList</a>에서 Registeration이 open으로 되어있는 릴레이는 가입신청을 하지 않아도 되는 릴레이들이다. 다만 대규모 릴레이는 구독이 처리되는 데 시간이 좀 오래 걸릴 수 있다.</p>\n<p><a href=\"https://relay.fedi.buzz/\">#FediBuzz Relay</a> 서비스를 이용하면 특정 마스토돈 인스턴스의 타임라인을 릴레이를 통해 구독할 수도 있다. 해당 사이트의 안내를 따르면 특정 인스턴스의 타임라인을 구독할 수 있다.</p>\n<h2 id=\"publicsystem-용량-문제\">public/system 용량 문제</h2>\n<p><code>public/system</code> 디렉토리는 용량을 많이 잡아먹는다. 다음 두 가지 방법 중 하나를 택하여 해결하면 된다.</p>\n<ul>\n<li>S3-Compatible Object Storage 쓰기</li>\n<li><a href=\"https://docs.joinmastodon.org/admin/setup/#cleanup\">마스토돈 공식 홈페이지의 Running periodic cleanup tasks 문단</a>에 따라 crontab을 생성하고 마스토돈이 설치된 디렉토리에서 다음 명령어 모두 실행하기<pre><code class=\"hljs language-bash\">RAILS_ENV=production ./bin/tootctl accounts prune\nRAILS_ENV=production ./bin/tootctl cache clear\nRAILS_ENV=production ./bin/tootctl media remove --days=0\nRAILS_ENV=production ./bin/tootctl media remove --prune-profiles --days=0\nRAILS_ENV=production ./bin/tootctl preview_cards remove --days=0</code></pre>\n<ul>\n<li>crontab과 위 명령어만으로 부족하면 그냥 대용량 하드디스크 하나 꽂고 <code>/etc/fstab</code> 파일 수정해서 <code>public/system</code> 디렉토리에 영구 마운트해버리기 (좀 무식하게 보일 수도 있지만 간단하고 직빵이다)</li>\n</ul>\n</li>\n</ul>\n<p>마음에 드는 방법을 택하도록 하자.</p>\n"}},"__N_SSG":true}