{"pageProps":{"article":{"metadata":{"title":"2022년의 회고","subtitle":"군대와 전역","author":"LiteHell","date":"2023-01-08T15:01:25.655Z","category":"Life","tags":["Retrospective"]},"rendered":"<h1 id=\"들어가는-말\">들어가는 말</h1>\n<p>대단한 성취를 이루지도 못했는데 벌써 2022년이 다 지나갔다. 올해는 다르리라 다짐하는 의미에서 2022년에 무엇을 했는지 되짚어보고자 한다.</p>\n<h1 id=\"부대안에서\">부대안에서</h1>\n<p>군대에서만큼은 잠시 코딩을 쉬고 싶었다. 그래서 부대에서 코딩을 열심히 하진 않았는데, 그럼에도 불구하고 휴식을 제대로 취하진 못했다. 아무래도 밖에 자유롭게 못 나가는 것에, 군대 특유의 통제도 있었고, 또 교대근무를 하다보니 몸이 피로했다. 육체적으로 힘든 일을 하진 않았지만, 모든 사람에게 군대가 그렇듯 다시 하고 싶은 경험은 아니었다. 그래서 그런지 쉬어가는 텀이 되진 못했다.</p>\n<p>내가 부대에서 목표로 한 것은 딱 3가지였다: 자격증, 그림, 운동. 운동은 게을려서 하지 못했지만 나머지 2개는 이뤘다. 그림 연습을 거의 매일 하는데 성공했고, 자격증도 취득했다.</p>\n<h2 id=\"정보처리산업기사-취득2021\">정보처리산업기사 취득(2021)</h2>\n<p>2021년 12월 31일에 정보처리산업기사를 취득했다. </p>\n<p>군내시험이라 필기를 CBT가 아닌 OMR 마킹형식으로 했다. (실기는 사회와 똑같이 필답형이다.) 개정된 산업기사 시험이었는데, 난이도는 그리 어렵진 않았다. 알고리즘 문제가 순서도 그림이 아닌 코드 형태로 나와서 오히려 편했다.</p>\n<p>공군은 산업기사를 취득하면 휴가 1일(정확히는 휴가 하루치의 병영생활 가점)을 준다. 덕분에 휴가 하루 받아서 잘 다녀왔다.</p>\n<p>원래 2021년 회고에 들어갈 내용이지만, 어떤 이유에선지 까먹고 안 썼길래 이번 회고에 썼다.</p>\n<h2 id=\"상공회의소-한자-3급-취득\">상공회의소 한자 3급 취득</h2>\n<p>2022년 3월에 상공회의소 한자 3급을 취득했다. <a href=\"https://www.cau.ac.kr/cms/FR_CON/index.do?MENU_ID=130&amp;P_TAB_NO=7&amp;TAB_NO=3\">중앙대학교는 졸업필수요건으로 모든 재학생에게 한자급수 3급 이상(예체능은 4급 이상)을 취득한 것을 요구한다.</a> 졸업을 하려면 좋든 싫든 한자 자격증을 따거나 한자 관련 교양 수업 2개이상을 들어야 한다.</p>\n<p>내 주변 사람들 중에서는 <a href=\"https://www.cau.ac.kr/cms/FR_CON/BoardView.do?MENU_ID=100&amp;CONTENTS_NO=2&amp;SITE_NO=2&amp;BOARD_SEQ=4&amp;BOARD_CATEGORY_NO=26&amp;BBS_SEQ=23797&amp;P_TAB_NO=2\">군 e-러닝</a>으로 한자 교양을 듣는 사람이 꽤 있었다. 졸업요건도 채우고 성적 잘 받으면 휴가도 받으니 1석2조다. 그러나 난 그러진 않았다. 첫번째 이유로는 학점을 이미 많이 들었고 두번째 이유로는 최대한 빠르게 끝내고 싶었다.</p>\n<p>그래서 <a href=\"https://book.eduwill.net/goods/select.action?goodsId=0100003113\">에듀윌 상공회의소 한자 3급 2주끝장</a>을 사서 일단 4급 한자 900자만 공부했다. (3급 900자는 몰라도 합격하는 데 지장없다.) 근데 완벽하게 외우지 않고 대충 외우고 갔더니 떨어졌다.</p>\n<p>비록 <a href=\"https://www.mnd.go.kr/user/boardList.action?boardId=I_4492133&amp;siteId=mnd&amp;cboardType=02&amp;boardSeq=I_8637767&amp;command=albumView&amp;warningYn=N&amp;id=mnd_020701000000\">장병 자기개발비 지원사업</a>으로 시험비용을 일부 환급받긴 했지만 돈이 아까웠다. 그래서 이번에는 <a href=\"https://quizlet.com/\">Quizlet</a> 앱과 책을 같이 병행하여 확실하게 공부했다.</p>\n<p>앱을 이용하니 확실히 외우는 데 큰 도움이 됐다. 퀴즐렛에 카드를 좌우로 넘기면서 학습하는 기능이 있는데, 이 기능은 가물가물하던 한자를 다시 외우는 데 탁월한 효과가 있다.</p>\n<p>위와 같이 한자를 반복적으로 외우고 인터넷에 올라온 기출문제들을 다 받아서 풀며 열심히 준비했다. 그렇게 열심히 공부하여 2022년 3월 17일날 시험을 봤고, 그 결과 당당하게 합격했다.</p>\n<h2 id=\"개발\">개발</h2>\n<p>위에서 코딩 안했다고 했는데, 아예 안하진 않았다. 부대사 사이버지식정보방에서 <a href=\"https://github.com/features/codespaces\">GitHub Codespaces</a>를 이용해 어느정도 개발을 했다.</p>\n<p>군 복무중일때는 주로 <a href=\"https://github.com/ManhwaDure\">만화동아리</a> 사이트들의 버그를 고치는 데 주력했다. 그 외에도 나는 개인적으로 싼 서버를 개인서버로 쓰는데 Docker가 쓰는 용량을 줄이기 위해 3월에 Docker 이미지들을 전부 다 alpine 기반으로 바꾸기도 했다. 이 블로그의 RSS/Atom/Json 피드와 <a href=\"https://ogp.me/\">OpenGraph</a> 코드도 3월에 추가된 것이다.</p>\n<h3 id=\"fullcards\">fullcards</h3>\n<p><a href=\"https://github.com/ManhwaDure/fullcards\">fullcards</a>는 <a href=\"https://caumd.club\">만화동아리 홈페이지</a>를 만드는 데 이용되는 웹 어플리케이션이다.</p>\n<p>4월에 해당 프로젝트를 정적 파일을 생성하는 형태로 바꾸려고 시도했다가 Nextjs 프레임워크 위에서 하려니 자꾸 꼬여서 포기하기도 했다. 이 건은 지금 다시 재시도하고 있다.</p>\n<p>5월에는 <a href=\"https://firebase.google.com\">Firebase</a>를 제거하고 <a href=\"https://typeorm.io\">TypeORM 라이브러리</a>를 이용해 <a href=\"https://mariadb.org/\">MariaDB</a> 기반으로 전환했다. 기존에 Firebase를 쓸 때는 홈페이지 초반에 로딩이 잠깐 걸렸는 데 그걸 없애고 싶었다.</p>\n<p>Firebase에서 다른 데이터베이스로 마이그레이션하기는 귀찮았다. 그래서 처음에 서버사이드에서 Firebase 데이터를 받아서 주는 방식을 시도해봤는데, 끔찍하게 느렸다. 따라서 그냥 Firebase를 제거하고 서버에서 홈페이지를 렌더링할때 사이트 데이터를 함께 주는 방식으로 진행했다.</p>\n<p>지금은 로딩이 반짝 뜨긴 하지만, 전에 비하면 확실히 개선됐다. 이 반짝 뜨는 현상도 추후 수정 예정이다.</p>\n<h1 id=\"말년휴가\">말년휴가</h1>\n<p>9월 말에 말년휴가를 나왔다. 확실히 좋았다. 중간에 부대 잠깐 찍고 다시 휴가나오기만 몇 번하면 되니, 사실상 민간인이었다.</p>\n<p>이때부터 연말까지 코딩을 꽤 많이 했다. fullcards의 에디터도 <a href=\"https://github.com/zenoamaro/react-quill\">react-quill</a>에서 <a href=\"https://ui.toast.com/tui-editor\">TOAST UI Editor</a>로 바꾸었고, 특히 <a href=\"https://github.com/LiteHell/theseed-skin-buma\">theseed-skin-buma</a>의 개발을 집중적으로 했다. 기존에 존재하던 버그들을 거의 다 수정하고, 이 과정에서 <a href=\"https://github.com/Tenpower\">Tenpower</a>님의 큰 도움을 받았다.</p>\n<p>11월에 <a href=\"https://flutter.dev/\">Flutter</a>에 관심이 생겨서 공부를 시작했다. React와 Vue를 둘 다 해본 사람이라 그런지 입문하고 이해하는 데 큰 어려움은 겪지 못했다. <a href=\"https://blog.litehell.info/post/review_of_gdg_songdo_devfest_songdo_2022\">GDG Songdo Devfest도 이때 다녀왔다.</a></p>\n<h1 id=\"전역\">전역</h1>\n<p>12월 중에 전역했다. 말년휴가를 나가있던 사람이라 그런지 막 대단한 감흥을 느끼진 못했다.</p>\n<p>12월(정확히는 11월 30일)에는 <a href=\"https://flutter.dev\">Flutter</a> 공부도 할 겸 <a href=\"http://reference.sketchdaily.net/\">SketchDaily reference</a> 모바일 앱의 개발을 시작했다. 사이트 주인분께 허락도 받았고 아는 분께 앱 디자인도 부탁드렸다. 플레이스토어에 직접 배포해본 적이 없었는데, 이번 개발을 통해 한 번 해보고 싶다.</p>\n<h1 id=\"다짐\">다짐</h1>\n<p>올해는 열심히 살 것이다. 코딩테스트를 준비하고, 전공공부에 집중할 것이다. 그리하여 마지막에 노력과 행운을 합쳐 좋은 기업에 취업하고 싶다.</p>\n"},"articleId":"retrospective_of_2022","previousPost":{"name":"memory_of_namufix","metadata":{"title":"NamuFix의 추억","subtitle":"내 첫 유저스크립트","author":"LiteHell","date":"2023-01-04T08:32:17.948Z","category":"Dev","tags":["JavaScript"]},"rendered":"<h1 id=\"들어가며\">들어가며</h1>\n<p>추억여행을 위해 2015년으로 올라가보자. 2015년에 <a href=\"https://namu.wiki\">나무위키</a>가 생겼다. 나무위키는 <a href=\"https://www.rigvedawiki.net/\">리그베다위키</a>와 <a href=\"web.archive.org/web/20150607151726/https://mirror.enha.kr/wiki/FrontPage\">엔하위키 미러</a>를 무너트리고 급격히 부상했다. 토론과 편집에 있어 전에 비해 크게 향상된 편의성(접근성), 그리고 SEO가 큰 원인이였다.</p>\n<p>그때의 나무위키는 지금과 많이 달랐다. UI도 달랐고, 이미지 업로드 기능과 에디터도 없었다. 그래서 그때는 이미지를 올릴려면 <a href=\"https://imgur.com\">imgur</a>에 업로드한 뒤 그 주소를 직접 복사해야 했다. 그래서 &#39;이걸 간단하게 할 수 있지 않을까?&#39;라는 생각이 들었고, 바로 간단한 에디터와 imgur 이미지 업로드 기능을 추가하는 유저스크립트를 배포했다. 그게 바로 <a href=\"https://github.com/litehell/namufix\">NamuFix</a>의 시작이었다.</p>\n<p><img src=\"/img/namufix_first_version.png\" alt=\"NamuFix의 첫버전\"></p>\n<div style=\"text-align: center; color: gray;\">(초창기 나무위키에 NamuFix 초기버전을 적용시킨 모습)</div>\n\n<p>이 글에서는 <a href=\"https://github.com/LiteHell/NamuFix/releases\">NamuFix 릴리즈 목록</a>을 시간대별로 보면서 추억을 회상할 것이다. 글 쓰는데 익숙하지 않아 두서없을 수 있지만, 넓은 아량으로 읽어주기를 바란다.</p>\n<h2 id=\"업데이트들\">업데이트들</h2>\n<p>2015년 초부터 2020년 초까지 총 5년동안 유지보수했다. 그래서 이 유저스크립트에는 추억이 참 깊다.</p>\n<h3 id=\"첫-버전\">첫 버전</h3>\n<p>초반에 잠깐 <a href=\"https://gist.github.com\">GitHub Gist</a>를 써서 배포하다가 그냥 <a href=\"https://github.com\">GitHub</a>에 <a href=\"https://github.com/LiteHell/NamuFix\">레포</a>를 하나 파서 배포했다. 처음에는 버전을 그냥 평범하게 3.14의 형식으로 매기다가 &#39;15년 8월부터 YYMMDD.N(N은 해당 날짜의 몇 번째 업데이트인지를 나타내는 숫자)의 형식을 채택했다. 어렸을 때에는 버전을 자동으로 매기는 방법을 몰랐고, 버전을 직접 매길 때는 이 방법이 편했다.</p>\n<p>이렇게 YYMMDD.N 형태의 버전으로 배포한 첫 버전은 imgur 업로드 기능 외에도 몇가지 기능이 더 있었다. 임시저장 기능과 지도/TV팟/유튜브 삽입기능, 템플릿 불러오기 기능(귀찮게 복붙하지 말고 바로 불러올 수 있게 하는 기능)이다. 그때는 <a href=\"https://gall.dcinside.com/dcwiki\">위키 갤러리</a>가 엄청 활성화됐을 때라서, 그 곳에서 기능 건의를 받곤 했었다. GitHub 이슈 트래커는 비개발자들에게 접근성이 낮았기에 이렇게 직접 발품을 파는 방식이 더 좋았다.</p>\n<p>그 다음에 추가된 기능들은 문서 주시 기능과 리다이렉트를 간단하게 생성하는 기능들이였다. 문서 주시 기능은 문서에 변경 사항이 있으면 알림을 띄워주는 기능이고, 리다이렉트 생성 기능은 그냥 리다이렉트의 도착지 문서에서 클릭 한 번만으로 편하게 만들 수 있게 하는 기능이다. 문서 주시 기능은 초반에 딜레이를 낮게 했더니 서버측에서 차단하는 버그가 있었다. 그래서 급하게 강제로 비활성화해서 배포하고, 해당 버그를 고치고 다시 활성화했다가, 결국에 그냥 삭제해버렸다. 그 밖에도 토론에 아이덴티콘 추가하는 기능이랑, 사용자 기여/토론 통계 기능도 넣었다. 이 모든 것들이 8월까지의 일이었다.</p>\n<h3 id=\"여시-워마드\">여시-워마드</h3>\n<p>그러다가 8~9월쯤에 페미니즘 관련 사태가 터졌다. (시기가 정확하진 않다. 필자는 기억력이 매우 나쁘다.) 그때 나무위키에서는 <a href=\"https://archive.is\">archive.is</a>로 아카이브를 떠서 넣는 유행이 있었는데, 기여해본 사람은 알겠지만 이게 약간 귀찮다. 주소를 일일이 복사-붙여넣기하기 위해 마우스를 움직이는 것도 귀찮은 것이 사람 마음 아니겠는가. 그래서 9월에 편집기에 아카이브 메뉴를 추가했다. 나무위키내 편집기에서 바로 아카이브를 만들어 링크를 첨부할 수 있는 기능이었다. 그때의 열렬한 반페미니즘 기여자들에게는 정말로 편리했을 것이다.</p>\n<p>그 밖에도 나무위키 이슈 트래커에 접속할 시(그때는 있었다. issue.namu.wiki라고...) https로 자동 전환해주는 기능이랑, 리버전 비교를 더 편하게 하는 기능, 편집 불가능한 문서에서 소스코드를 보여주는 기능도 추가했다. 그때는 편집 불가능한 문서에서 편집을 시도하면 소스코드를 보여주지 않고 그냥 오류 메세지만 표시했다. 이 기능이 &#39;15년 9월 10일에 추가된 기능이었는데, 나중에 나무위키측에서도 편집 불가능 문서의 편집을 시도할 시 소스코드를 보여주도록 변경했다. 그래서 &#39;15년 9월 17일에 해당 기능을 제거했다.</p>\n<h3 id=\"비트코인-받아요\">비트코인 받아요</h3>\n<p>9월 19일에는 나무위키 기부 버튼을 추가하도록 업데이트했다. 지금은 나무위키가 <a href=\"https://umanle.net/\">umanle s.r.l</a>의 소유지만, 그때는 <a href=\"https://namu.wiki/w/%EC%82%AC%EC%9A%A9%EC%9E%90:namu\">개발자 namu</a>의 소유였다. 그때 namu가 돈 좀 기부해달라면서 비트코인 주소를 공개한 적이 있었다. 그 주소를 NamuFix를 통해 상단바 메뉴 형식으로 추가한 것이다, 누르면 비트코인 주소가 뜨도록. 이 기능은 추후 9월 28일에 하단 기부 문구형식으로 뜨도록 수정했고, 그 다음 날에 QR코드 이미지를 추가했다. 이 기능은 나중에 나무위키가 umanle s.r.l에서 인수되면서 &#39;16년 9월 11일에 제거했다.</p>\n<p>자기 기여 보는 메뉴 추가하는 기능(이하 &quot;내 기여 메뉴 추가 기능&quot;)도 &#39;15년 9월에 추가했다. 지금은 편해졌지만, 그때는 자기 기여 보기가 좀 불편했다, 주소에서 IP/아이디 부분을 직접 바꿔서 쳐야했다...</p>\n<p>언제인진 기억안나지만 앵커 미리보기 기능도 추가했다. 나무위키 토론에서 토론 스레드 번호(예시: <code>#3</code>)를 누르면 해당 스레드로 가는 기능이 있는데, 이게 왔다갔다 하다보면 은근히 헷갈린다. 그래서 그냥 토론 스레드 번호위에 마우스만 올리면 해당 스레드 내용을 띄워주는 기능을 추가했다. 내가 매우 편하게 썼으니, 다른 사람들도 편하게 썼을 것이다.</p>\n<h3 id=\"vpngate\">VPNGate</h3>\n<p>그 당시 나무위키에는 VPNGate를 이용한 반달이 성행했다. 그래서 VPNGate IP인 게 확인되면 일단 차단하곤 했는데, 그거 편하게 하라는 의미에서 10월 4일에 토론시 VPNGate VPN 여부 확인 기능을 추가했다. 토론할때 어떤 IP이용자가 VPNGate IP면 옆에 뜨는 기능이다. 이 밖에도 편집화면에서 미리보기/비교를 바로 할 수 있도록 편집기를 위키백과와 비슷하게 탭방식으로 수정했고, 코드 강조 기능도 추가했다. 그때는 나무위키에 코드 구문 강조 문법이 없었는데, 나중에 나무위키측에서 자체적으로 지원을 시작했기에 해당 기능은 &#39;16년 9월에 제거됐다.</p>\n<h3 id=\"레이아웃-변경\">레이아웃 변경</h3>\n<p>&#39;15년 10월에 나무위키에서 프론트엔드를 변경했다. 초창기에는 <a href=\"https://github.com/daumcorp/Dough\">Daum Dough</a>를 이용한 검은색 프론트엔드를 썼었는데, 이를 완전히 버리고 <a href=\"https://getbootstrap.com\">Bootstrap</a>에 기반한 프론트엔드로 완전히 탈바꿈한 것이다. 그래서 10월 10일과 11일에 이에 대응하는 대규모 업데이트를 실시했다. 이때 앞서 말한 내 기여 메뉴 추가 기능도 같이 삭제됐다, 프론트엔드가 바뀌면서 추가됐기 때문이다.</p>\n<p>10월 17일에는 imgur에서 나무위키를 차단함에 따라 imgur 업로더 기능을 삭제했다. 나무위키측에서는 급하게 캐시서버를 만들어 대응했다가 추후 자체적으로 이미지 업로드를 지원하는 방식으로 완전히 해결했다.</p>\n<p>이 자체 이미지 업로더를 쓰려면 <a href=\"https://namu.wiki/Upload\">파일 올리기</a> 페이지를 들어가야 한다. 어? 따로 다른 페이지에 들어갈 필요없이 편집페이지에서 바로 이미지를 올릴 수 있으면 더 편하지 않을까? 그래서 NamuFix에서 &#39;16년 3월 19일에 이걸 추가했다. 그리고 토론에서 IP주소 옆에 상세정보 조회 버튼도 만들었다.</p>\n<h4 id=\"토론-주소의-변경\">토론 주소의 변경</h4>\n<p>&#39;17년 7월에는 나무위키 토론 주소가 <code>https://namu.wiki/topic/번호</code>에서 <code>https://namu.wiki/thread/번호</code> 형식으로 변경됐었다. 그래서 이에 대응하는 긴급 업데이트를 진행했다. 그 다음날에는 IP주소 관련 기능의 속도도 개선했다.\n이 토론 주소 변경 이후로 많은 토론들이 접근불가가 됐다, 주소 형식의 변경으로 인해 단절됐기 때문이다.</p>\n<p>&#39;17년 8월에는 나무위키에서 서버 부하를 줄인다는 이유로 토론에서 보이는 쓰레드만 불러들이도록 업데이트했다. 그래서 가만히 생각해보니 이거 무시하고 한 번에 불러들이는 기능을 추가하면 사람들이 좋아할 것 같았다. 그래서 Namufix에 보여지지 않는 쓰레드도 불러오는 기능을 추가했다.</p>\n<h3 id=\"이미지-업로더\">이미지 업로더</h3>\n<p>10월에는 KISA WHOIS 조회 기능을 추가하고, <a href=\"https://awiki.theseed.io\">A위키</a>(지금은 알파위키지만 그때는 이름이 없었다.)를 지원하기 시작했으며, 드래그드롭 업로드 기능과 편집기 내 복사-붙여놓기를 통한 이미지 업로드 기능을 추가했다. 드래그드롭 업로드 기능이 확실히 반응이 좋았던 것으로 기억한다. 다른 사람이 NamuFix 이미지 업로드 기능으로 사진을 막 업로드하며 웹툰 문서를 만들다가 차단당하는 사례도 있었다.</p>\n<p>그리고 이미지 업로드시 확장자 jpeg이면 jpg로 변경하라고 경고 띄우는 기능도 추가했다. 지금은 고쳐졌을지 모르겠는데, 그때는 나무위키측에 확장자가 jpeg이면 이미지 업로드시 오류가 나는 버그가 있었다. 이유는 오직 namu만이 안다.</p>\n<h3 id=\"차단기간-초단위-입력-기능\">차단기간 초단위 입력 기능</h3>\n<p>10월에 차단기간을 초 단위로 입력하는 기능을 추가했다. 그때 나무위키의 차단 UI는 3일, 5일, 1주, 2주 이런 식으로만 선택할 수 있었다. (그래서 나무위키 규정을 보면 1개월을 4주로 계산한다.) 근데 UI가 그런거지 내부적으로는 초 단위까지 지정할 수 있었다. 그래서 이를 이용해 초 단위로 차단 기간을 설정할 수 있게 하는 기능을 추가했다. 처음에는 초 단위의 시간을 입력하게 했는데, 생각해보니 이건 아닌 거 같아서 다음날에 연/월/일/시/분/초를 입력하면 자동으로 초 단위의 시간이 입력되도록 개선했다.</p>\n<h3 id=\"기록의-가독성-향상\">기록의 가독성 향상</h3>\n<p>그때의 나무위키는 <a href=\"https://namu.wiki/BlockHistory\">차단기록</a>에서 차단 시간을 초 단위로만 표시했다. 초 단위의 시간만 보면 며칠인지 바로 감이 오지 않는다. 그래서 이 초 단위의 시간을 &quot;몇일 몇시간&quot; 이런식으로 좀 보기 편하게 바꾸는 기능을 10월에 추가했다.</p>\n<p>문서 역사에서 ACL 변경 기록도 (참고 : 그때의 ACL 시스템이랑 지금의 ACL 시스템은 다르다. 지금은 규칙기반의 ACL 시스템이지만, 그때는 열람/수정/삭제/토론/이동 권한을 <code>member</code>, <code>admin</code>, <code>everyone</code> 셋 중 하나로 설정하고, 추가적으로 국내 열람 가능 여부를 설정하는 방식이였다.) 보기 쉽게 바꾸는 기능도 추가했다. 문서 역사에서 ACL 변경 기록이 <code>(everyone, everyone, member, everyone, everyone)</code> 이런식으로 뜨니 뭐가 뭔지 한 번에 알아보기 어려웠다. 그래서 <code>everyone</code>은 <code>모두</code> 이런식으로 바꾸고 그 옆에 알맞은 아이콘을 추가하는 기능을 구현해 배포했다. 이렇게 하니 내가 보기 좀 편해서 좋았다.</p>\n<h3 id=\"liberty-스킨\">liberty 스킨</h3>\n<p>&#39;17년 11월에 나무위키에 <a href=\"https://github.com/namu-theseed/theseed-skin-liberty\">liberty 스킨</a>이 추가됐다. 그래서 이 스킨을 지원하도록 NamuFix를 수정했다. 그리고 이때쯔음 A위키가 알파위키로 바뀌며 주소도 <code>https://awiki.theseed.io</code>에서 <code>https://www.alphawiki.org</code>로 바뀌었다. 그래서 알파위키에서도 스크립트가 불려와지도록 업데이트했다.</p>\n<h3 id=\"greasmonkey-4-kst\">Greasmonkey 4, KST</h3>\n<p>&#39;17년에 <a href=\"https://www.greasespot.net/2017/09/greasemonkey-4-for-script-authors.html\">Greasemonekey 4가 나오면서 API가 변경되었다.</a> 따라서 이를 지원하기 위해 &#39;17년 12월 초에 GM4를 지원하도록 스크립트를 수정했다. 또한 나무위키 게시판에서 시간대를 KST로 표시하는 기능을 추가했다. 그때 당시 나무위키 게시판은 시간대를 KST가 아닌 UTC로 표시했다. 그래서 시간을 보면 머릿속으로 9시간을 더하는 암산을 해야했는데... 귀찮지 않은가? 그래서 그냥 댓글/게시글 작성일의 시간대를 자동변환하는 기능을 추가했다.</p>\n<p>또한 &#39;17 12월에 여러개의 계정이나 IP를 한 번에 차단하는 일괄 차단 기능을 추가했다. 내 기억상으로 나무위키/알파위키 관리자들이 이 기능을 매우 잘 썼던 것으로 기억한다.</p>\n<p>여기서 더 나아가, <a href=\"https://github.com/LiteHell/NamuFix/issues/64\">토론에서의 긴급차단 기능을 문서 역사로 확대하고,</a> <a href=\"https://github.com/LiteHell/NamuFix/releases/tag/171224.0\">최근 변경 페이지</a>와 <a href=\"https://github.com/LiteHell/NamuFix/issues/86\">사용자 기여내역</a>, <a href=\"https://github.com/LiteHell/NamuFix/issues/106\">나무위키 게시판</a>에서도 긴급차단을 할 수 있도록 개선했다. 이 긴급차단 기능도 일괄차단 기능과 함께 관리자들이 애용했던 것으로 기억한다.</p>\n<h3 id=\"infra-customer-차단사유-상용구\">INFRA, CUSTOMER, 차단사유, 상용구</h3>\n<p>KISA WHOIS 조회시 네트워크 구분이 INFRA로 뜨면 공용 IP고 CUSTOMER로 뜨면 공용 IP가 아니라는 것을 아는가? 이는 위키 관리자에게 중요한 상식이다.</p>\n<p>근데 이걸 매번 KISA WHOIS 조회페이지에 입력해가면서 확인하면 귀찮다. 그래서 &#39;18년 1월 초에 토론페이지에서 IP 옆에 해당 네트워크 구분을 표시하는 기능을 추가했다. 이때 서버에 요청을 너무 많이하면 안 되니까, 내부적으로 캐시를 만들어 중복되는 요청은 하지 않도록 했다.</p>\n<p>나무위키는 차단사유에 링크를 넣으면 사용자문서에서 그냥 텍스트로만 넣어준다. 즉, 눌러도 링크 안 열린다. 이건 지금도 그런데, 크리티컬하진 않지만 소소하게 번거롭다. 그래서 차단사유에 웹페이지 주소가 있으면 해당 주소로 가는 링크를 생성하는 기능을 1월 말에 추가했다. 몇몇 사람들에겐 약간 유용했을 것이다.</p>\n<p>&#39;18년 2월에는 <a href=\"https://github.com/LiteHell/NamuFix/issues/75\">ID 기여자의 기여목록에서 차단내역을 조회하는 기능을 추가했다.</a> 하긴, 직접 ID 복사해서 차단내역 검색하는 건 은근히 귀찮다. 나무위키 게시판을 자세히 보면 관리자들이 똑같은 댓글을 자주 다는 것(예시: &quot;기각합니다&quot;)을 볼 수 있는데 이를 캐치하여 <a href=\"https://github.com/LiteHell/NamuFix/commit/e8cc6bea9d514f3e96a33e7dc204e45e162cf604\">나무위키 게시판 댓글 사용구 기능도 추가했다.</a></p>\n<h3 id=\"ssl은-이제-상식이죠\">SSL은 이제 상식이죠</h3>\n<p>나무위키는 초창기부터 <code>no-ssl.namu.wiki</code>로 SSL없이 접속할 수 있었다. 이 기능이 어느순간 삭제돼서 &#39;18년 5월에 해당 주소에서의 NamuFix 지원을 삭제했다.</p>\n<p>&#39;18년 10월에 알파위키가 잠시 폐쇄됐었다. 그래서 &#39;18년 10월 말에 알파위키 지원을 삭제했다. 그리고 &#39;19년 1월 초에 클릭 한 번으로 바로 되돌릴 수 있는 빠른 되돌리기 기능을 추가했다.</p>\n<p>&#39;19년 1월 20일에는 IP Quality Score를 추가해달라는 요청도 있어서 KISA WHOIS 조회기능 사용시 IP Quality Score도 같이 표시되도록 개선했다. 근데 이게 그렇게 도움이 될 지는 잘 모르겠다.</p>\n<p>&#39;19년 6월 말에는 일괄 블라인드 기능을 추가했고, 그리고 이것저것 자잘한 것들을 추가했다.</p>\n<h2 id=\"지원중단\">지원중단</h2>\n<p>2019년 9월쯤에 나무위키가 기존의 <a href=\"https://github.com/paularmstrong/swig\">Swig</a> 라이브러리를 던지고 Vue를 쓰기 시작했다. 이때를 기점으로 NamuFix에 매우 많은 버그가 생기기 시작했고, 버그를 고치기 어려워서 이때를 기점으로 지원을 중단했다. 그러나 지원을 중단했음에도 불구하고 <a href=\"https://github.com/gdl-blue/classic-theseed\">Vue 업데이트를 일정 부분 되돌리는 유저스크립트</a>를 만들어서 어떻게든 NamuFix를 쓰는 사용자분들이 있었다. 이걸 보면서 감회가 꽤 새로웠다.</p>\n<h2 id=\"얼마나-썼을까\">얼마나 썼을까?</h2>\n<p>유저스크립트에 애널리틱스같은 걸 넣지 않아서, 얼마나 많은 사람들이 썼는지는 정확히 가늠할 수 없다. 하지만 적지 않은 사람들이 이 스크립트를 써주고 이슈와 PR을 올려줬다는 점 만큼은 기억하고 있다. 특히 관리자들이 이 스크립트를 써줬다는 것이 인상적이었다. <a href=\"https://board.namu.wiki/b/report/773522\">특히 일반 관리자가 아닌 사측 관리자도 쓰는 점은 더 놀라웠다.</a></p>\n<h2 id=\"디테일의-ux-그리고-추억\">디테일의 UX, 그리고 추억</h2>\n<p>이 유저스크립트는 &quot;디테일의 불편함&quot;을 개선하고 수정하는 데 중점을 뒀다. 사람들은 사소한 부분에서도 불편함을 느끼고, 사소한 부분에서도 편리함을 느낀다. 이 유저스크립트를 만들면서 한가지 교훈을 얻었다: UX는 디테일부터 시작한다는 것이다.</p>\n<p>이 스크립트는 곧 내 추억이다. 내가 만든 프로그램들 중 많은 사람들이 써준 첫 프로그램이었다. 이 스크립트를 만들면서 리그베다위키가 망하는 것을 보았고, 나무위키가 생기는 것을 보았고, 나무위키 관리자들이 선거로 뽑히는 것을 보았고, 나무위키에서 기존 리그베다식 표현이 삭제되는 것을 보았고, 나무위키가 umanle s.r.l로 인수되는 것을 보았다. 그러한 역사를 NamuFix를 유지보수하며 묵묵히 지켜봤다. 시험공부를 하다가도 NamuFix 개발이 너무 재밌어서 바로 버그를 수정하던 그 시절이 그립다.</p>\n<p>UX는 디테일에서부터 시작한다. 관찰과 소통으로 디테일의 불편함을 찾아내고 개선할 수 있었다.</p>\n"},"nextPost":{"name":"webpack_and_react_ssg_1","metadata":{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (1)","subtitle":"Webpack + TypeScript + React + TailwindCSS = TA-DA!","author":"LiteHell","date":"2023-01-10T05:00:48.244Z","series":"webpack_and_react_ssg","seriesName":"Webpack과 React를 이용한 정적 웹사이트 만들기","category":"Dev","tags":["React"]},"rendered":"<h1 id=\"들어가는-글\">들어가는 글</h1>\n<p>본래 <a href=\"https://litehell.info\">내 개인 웹사이트</a>는 <a href=\"https://nextjs.org/docs/advanced-features/static-html-export\">Next.js의 Static HTML Export 기능</a>과 <a href=\"https://pages.github.com/\">GitHub Pages</a>를 이용해 배포됐다. 디자인에는 <a href=\"https://bulma.io\">bulma CSS 프레임워크</a>를 이용했다.</p>\n<p><img src=\"/img/homepage_before_redesign_2022.png\" alt=\"홈페이지 재디자인 전의 이미지\"></p>\n<p>위와 같이 bulma에서 제공하는 component들을 이용해 간단하게 디자인했다.</p>\n<p>그러나 내 웹사이트를 몇 번 보다보니 디자인을 좀 설렁설렁하게 한 느낌이 들었다. 그래서 디자인을 한 번 바꿔보고 싶었고, 이번 기회에 Next.js를 쓰지 않고 직접 정적 파일로 배포하는 경험도 해보고 싶었다.</p>\n<p>이 글은 개인 홈페이지를 재작성한 경험에 기반하여 쓰는 글이지만, 독자들이 따라하며 참고할 수 있도록 일부 변형하여 작성했다. 설명을 최대한 자세하게 하려 노력했지만, 글 쓰는 실력이 좋은 편이 아니라 읽기 불편할 수 있으니 양해해주셨으면 좋겠다.</p>\n<h1 id=\"webpack과-babel-그리고-typescript\">Webpack과 Babel, 그리고 Typescript</h1>\n<p>Next.js는 쓰지 않았다. 간단한 한 페이지 정적 페이지 만드는 데에는 Webpack이면 충분하다.</p>\n<p>이제 어떤 기술스택을 쓸 지 정했다, 이제 필요한 의존성을 먼저 설치하면 된다. 의존성을 한 번 설치해보자.</p>\n<h2 id=\"의존성-설치하기\">의존성 설치하기</h2>\n<p>먼저 React와 Typescript를 설치한다. 재디자인 전에 했듯이 이번에도 React로 개발할 것이다.</p>\n<pre><code class=\"hljs language-bash\">yarn add react-dom react\nyarn add --dev typescript react @types/react @types/react-dom</code></pre>\n<p>그 다음, 다음 명령어로 tsconfig.json을 생성한다.</p>\n<pre><code class=\"hljs language-bash\">npx tsc --init</code></pre>\n<p>생성된 tsconfig.json에서 <code>jsx</code> 속성을 <code>react</code>로(다르게 해도 되긴 한데 나는 이렇게 했다), 그리고 <code>moduleResolution</code> 속성은 <code>node</code>로 바꾸어야 한다. 이 외에 나머지 속성들은 개인 취향대로 하면 된다. 일단 개인 취향대로 하고 나중에 코딩하다 <code>tsconfig.json</code>때문에 오류나면 그때 수정하면 된다.</p>\n<p>참고로 내 <code>tsconfig.json</code>는 다음과 같다.</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">&quot;compilerOptions&quot;</span>: {\n    <span class=\"hljs-attr\">&quot;target&quot;</span>: <span class=\"hljs-string\">&quot;es2016&quot;</span>,\n    <span class=\"hljs-attr\">&quot;lib&quot;</span>: [<span class=\"hljs-string\">&quot;DOM&quot;</span>],\n    <span class=\"hljs-attr\">&quot;jsx&quot;</span>: <span class=\"hljs-string\">&quot;react&quot;</span>,\n    <span class=\"hljs-attr\">&quot;module&quot;</span>: <span class=\"hljs-string\">&quot;ESNext&quot;</span>,\n    <span class=\"hljs-attr\">&quot;moduleResolution&quot;</span>: <span class=\"hljs-string\">&quot;node&quot;</span>,\n    <span class=\"hljs-attr\">&quot;typeRoots&quot;</span>: [<span class=\"hljs-string\">&quot;node_modules/@types&quot;</span>, <span class=\"hljs-string\">&quot;src/types&quot;</span>],\n    <span class=\"hljs-attr\">&quot;allowJs&quot;</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">&quot;checkJs&quot;</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">&quot;allowSyntheticDefaultImports&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;strict&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;noImplicitAny&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;strictNullChecks&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;strictFunctionTypes&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;alwaysStrict&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;noUnusedLocals&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;noUnusedParameters&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;skipLibCheck&quot;</span>: <span class=\"hljs-literal\">true</span>\n  },\n  <span class=\"hljs-attr\">&quot;include&quot;</span>: [<span class=\"hljs-string\">&quot;src/**/*.tsx&quot;</span>, <span class=\"hljs-string\">&quot;src/**/*.ts&quot;</span>],\n  <span class=\"hljs-attr\">&quot;exclude&quot;</span>: [<span class=\"hljs-string\">&quot;node_modules&quot;</span>]\n}\n</code></pre>\n<p>그 다음으로는 Webpack이 필요하다. 다음 명령어로 Webpack을 추가하자.</p>\n<pre><code class=\"hljs language-bash\">yarn add webpack webpack-cli\nyarn add --dev webpack-dev-server ts-loader style-loader clean-webpack-plugin css-loader html-webpack-plugin</code></pre>\n<p>각 패키지들의 설명은 다음과 같다.</p>\n<ul>\n<li><code>webpack</code>, <code>webpack-cli</code> : Webpack이다. 설명이 필요없다.</li>\n<li><code>webpack-dev-server</code> : 수정이 되면 자동으로 webpack 재빌드해서 새로고침되는 웹 서버를 열기 위해 이용한다. 디버깅이 편해진다.</li>\n<li>webpack loader: Webpack에서 특정 유형의 파일을 불러오거나 변형한다.<ul>\n<li><code>ts-loader</code>: <code>.ts</code>나 <code>.tsx</code>파일을 Webpack에서 읽을 때 쓴다.</li>\n<li><code>css-loader</code>: css 파일에서 <code>@import</code>나 <code>url()</code> 구절들을 <code>import/require()</code>와 같은 식으로 해석하는 loader다.</li>\n<li><code>style-loader</code>: css를 웹페이지에 추가하는 loader다</li>\n</ul>\n</li>\n<li>webpack plugin<ul>\n<li><code>clean-webpack-plugin</code>: 출력 디렉토리내 파일들을 삭제하는 플러그인이다.</li>\n<li><code>html-webpack-plugin</code>: 생성된 js 파일의 스크립트 태그들이 추가된 html파일을 자동으로 생성한다</li>\n</ul>\n</li>\n</ul>\n<p>나는 이번에 babel을 쓸 것이다. babel은 최신 버전의 자바스크립트 기능을 브라우저 지원에 신경쓰지 않고 쓸 수 있게 해준다. 아래 명령어로 babel도 설치하자.</p>\n<pre><code class=\"hljs language-bash\">yarn add --dev @babel/core @babel/preset-env @babel/preset-react babel-loader</code></pre>\n<p><a href=\"https://tailwindcss.com/\">TailwindCSS</a>가 웹사이트 빠르게 만드는 데 좋다갈래 반신반의하는 느낌으로 한 번 써보려 한다. TailwindCSS를 쓰려면 다음 패키지들을 설치해야 한다.</p>\n<pre><code class=\"hljs language-bash\">yarn add --dev autoprefixer postcss postcss-loader tailwindcss</code></pre>\n<h2 id=\"webpack-설정하기\">Webpack 설정하기</h2>\n<p>이제 Webpack을 설정해야 한다. 루트 디렉토리에 <code>webpack.config.js</code>를 생성하고 내용을 다음과 같이 한다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack.config.js</span>\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> HtmlWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;html-webpack-plugin&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> { CleanWebpackPlugin } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;clean-webpack-plugin&#x27;</span>);\n\n<span class=\"hljs-keyword\">const</span> dev = process.env.NODE_ENV === <span class=\"hljs-string\">&#x27;development&#x27;</span>;\n<span class=\"hljs-built_in\">module</span>.exports = {\n    <span class=\"hljs-comment\">// 개발시라면 개발 모드로 한다.</span>\n    <span class=\"hljs-attr\">mode</span>: dev ? <span class=\"hljs-string\">&quot;development&quot;</span> : <span class=\"hljs-string\">&quot;production&quot;</span>,\n    <span class=\"hljs-attr\">optimization</span>: {\n      <span class=\"hljs-attr\">splitChunks</span>: {\n        <span class=\"hljs-comment\">// 청크를 가능한만큼 다 분리한다.</span>\n        <span class=\"hljs-comment\">// 파일 각각의 용량을 줄여들어서 웹페이지 로드속도 감소에 도움이 된다.</span>\n        <span class=\"hljs-attr\">chunks</span>: <span class=\"hljs-string\">&#x27;all&#x27;</span>\n      },\n      <span class=\"hljs-comment\">// 개발중이 아니라면 압축한다.</span>\n      <span class=\"hljs-attr\">minimize</span>: !dev\n    },\n    <span class=\"hljs-comment\">// 진입 파일이다.</span>\n    <span class=\"hljs-comment\">// ./src/index.tsx 파일에 필요한 모듈들을 번들링한다고 이해하면 된다.</span>\n    <span class=\"hljs-comment\">//</span>\n    <span class=\"hljs-comment\">// 즉, 다시 말해 출력파일을 실행하면 ./src/index.tsx을 실행하는 것과 동일한 효과를 가진다,</span>\n    <span class=\"hljs-comment\">// 다만 필요한 모듈들이 같이 번들링되어 있어 웹 환경 등에서도 실행이 용이할 뿐이다.</span>\n    <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&#x27;./src/index.tsx&#x27;</span>,\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.resolve(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),\n        <span class=\"hljs-comment\">// index.js로 하면 splitChunks 속성때문에 오류가 난다.</span>\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;[name].js&#x27;</span>\n    },\n    <span class=\"hljs-attr\">resolve</span>: {\n        <span class=\"hljs-attr\">extensions</span>: [<span class=\"hljs-string\">&#x27;.tsx&#x27;</span>, <span class=\"hljs-string\">&#x27;.ts&#x27;</span>, <span class=\"hljs-string\">&#x27;.js&#x27;</span>, <span class=\"hljs-string\">&#x27;.css&#x27;</span>]\n    },\n    <span class=\"hljs-attr\">module</span>: {\n        <span class=\"hljs-attr\">rules</span>: [\n            <span class=\"hljs-comment\">// 참고: use 속성은 마지막 아이템에서 첫 아이템으로의 순서, 즉 다시 말해 오른쪽에서 왼쪽으로의 순서로 해석된다.</span>\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.tsx?$/</span>,\n                exclude: <span class=\"hljs-regexp\">/node_modules/</span>,\n                use: [\n                    <span class=\"hljs-comment\">// Babel은 현대 자바스크립트를 브라우저 지원여부을 고려할 필요없이 쓸 수 있도록 해준다.</span>\n                    {\n                        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;babel-loader&#x27;</span>,\n                        <span class=\"hljs-attr\">options</span>: {\n                            <span class=\"hljs-attr\">presets</span>: [<span class=\"hljs-string\">&#x27;@babel/preset-react&#x27;</span>, <span class=\"hljs-string\">&#x27;@babel/preset-env&#x27;</span>]\n                        }\n                    },\n                    <span class=\"hljs-comment\">// Typescript를 Javascript로 컴파일해준다.</span>\n                    <span class=\"hljs-string\">&#x27;ts-loader&#x27;</span>\n                ]\n            },\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n                <span class=\"hljs-comment\">// postcss-loader는 TailwindCSS 적용에 이용된다.</span>\n                use: [<span class=\"hljs-string\">&#x27;style-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>]\n            }\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        <span class=\"hljs-comment\">// 빌드전에 dist 디렉토리내 파일들을 먼저 지우고 </span>\n        <span class=\"hljs-keyword\">new</span> CleanWebpackPlugin(),\n        <span class=\"hljs-comment\">// 빌드후 출력파일들이 script태그로 포함된 html파일을 생성한다.</span>\n        <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;Yeonjin Shin&#x27;</span>,\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>\n    })],\n    <span class=\"hljs-comment\">// 디버깅할 때 쓰는 웹서버에 관한 설정이다.</span>\n    <span class=\"hljs-comment\">// webpack serve로 열 수 있다.</span>\n    <span class=\"hljs-attr\">devServer</span>: {\n        <span class=\"hljs-attr\">static</span>: {<span class=\"hljs-attr\">directory</span>: path.join(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>)},\n        <span class=\"hljs-attr\">open</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">port</span>: <span class=\"hljs-string\">&#x27;auto&#x27;</span>,\n    },\n    <span class=\"hljs-comment\">// 이거 안하면 node_modules내 수 많은 파일의 변경여부도 같이 확인하기 때문에</span>\n    <span class=\"hljs-comment\">// 디버깅용 웹서버가 정상적으로 작동하지 않는다.</span>\n    <span class=\"hljs-attr\">watchOptions</span>: {\n        <span class=\"hljs-attr\">ignored</span>: <span class=\"hljs-regexp\">/node_modules/</span>\n    }\n}</code></pre>\n<h2 id=\"tailwindcss-설정하기\">TailwindCSS 설정하기</h2>\n<p>TailwindCSS를 적용하려면 TailwindCSS 설정파일을 생성해야 한다. TailwindCSS 설정 파일은 다음 명령어로 생성할 수 있다. <code>-p</code> 매개변수를 주면 PostCSS 설정파일도 같이 생성해준다.</p>\n<pre><code class=\"hljs language-bash\">npx tailwindcss init -p</code></pre>\n<p><code>postcss.config.js</code>는 생성된 그대로 쓰면 되고, <code>tailwind.config.js</code>만 수정하면 된다. <code>tailwind.config.js</code>에 <code>content</code> 속성에 TailwindCSS를 사용할 파일 패턴을 넣는다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// tailwind.config.js</span>\n<span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">{import(&#x27;tailwindcss&#x27;).Config}</span> </span>*/</span>\n<span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">content</span>: [<span class=\"hljs-string\">&quot;./src/**/*.{js,css,ts,tsx}&quot;</span>],\n  <span class=\"hljs-attr\">theme</span>: {\n    <span class=\"hljs-attr\">extend</span>: {},\n  },\n  <span class=\"hljs-attr\">plugins</span>: [],\n}</code></pre>\n<p>이제 TailwindCSS를 쓰기 위해 한 가지만 더 하면 된다. 다음과 같이 <code>@tailwind</code> 구문들이 들어간 css파일을 생성하고, 그 css 파일을 프론트엔드 코드에서 추가해주면 된다.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/* styles/index.css */</span>\n\n<span class=\"hljs-keyword\">@tailwind</span> base;\n<span class=\"hljs-keyword\">@tailwind</span> components;\n<span class=\"hljs-keyword\">@tailwind</span> utilities;\n\n<span class=\"hljs-comment\">/* ...more css here */</span></code></pre>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// src/index.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;../styles/index.css&#x27;</span>;\n<span class=\"hljs-comment\">// ...more imports and code here</span></code></pre>\n<p>TailwindCSS가 추가하는 CSS 코드는 PostCSS와 <code>postcss-loader</code>에 의해 CSS 파일에 자동으로 추가된다. 그리고 그 CSS 파일은 위와 같이 import만 해주면 <code>style-loader</code>에 의해 웹브라우저에서 html에 자동으로 추가된다.</p>\n<p>이제 TailwindCSS, Webpack, React를 쓰기 위한 준비가 끝났다. 코딩만 하면 된다.</p>\n<h2 id=\"코딩\">코딩</h2>\n<p>아래와 같이 코드를 작성해보자.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/index.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom/client&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;../styles/index.css&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Index</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;bg-gray-400&quot;</span>&gt;</span>\n      Hello, World!\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n}\n\n<span class=\"hljs-keyword\">const</span> rootDiv = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&#x27;div&#x27;</span>);\n<span class=\"hljs-built_in\">document</span>.body.appendChild(rootDiv);\n<span class=\"hljs-keyword\">const</span> root = ReactDOM.createRoot(rootDiv);\nroot.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Index</span> /&gt;</span></span>)</code></pre>\n<p>이렇게 하고 <code>npx webpack build</code>하면 잘 빌드될 것이다. <code>dist/index.html</code> 파일을 웹 브라우저로 열였을 때 &quot;Hello, World!&quot;가 뜨면 정상이다.</p>\n<p>위와 같은 식으로 코딩하면 된다. 개발할 때는 <code>npx webpack serve</code>로 웹 서버를 열면 편하게 디버깅할 수 있다.</p>\n"}},"__N_SSG":true}