{"pageProps":{"article":{"metadata":{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (3)","subtitle":"... + MiniCssExtractPlugin = TA-DA!","author":"LiteHell","date":"2023-07-23T17:25:47.907Z","series":"webpack_and_react_ssg","seriesName":"Webpack과 React를 이용한 정적 웹사이트 만들기","category":"Dev","tags":["React"]},"rendered":"<p>전 글까지 <a href=\"https://webpack.js.org/loaders/style-loader/\">style-loader</a>를 썼다. style-loader는 style 태그를 동적으로 생성하여 CSS를 DOM 안에 주입하는 로더이다. 즉, style-loader를 쓰면 js 스크립트가 실행되면서 style 태그가 동적으로 생성되고, 그 태그 내에 css가 동적으로 삽입되면서 스타일이 적용된다.</p>\n<p>하지만 정적 페이지로 빌드후 속도가 느린 서버로 게시하거나 스크립트 용량이 비대하면, 스크립트가 완전히 다 실행되기 전까지의 찰나동안 스타일이 적용되지 않은 깨진 페이지가 나타난다. 이런 버그를 막기 위해서는 <a href=\"https://webpack.js.org/plugins/mini-css-extract-plugin/\">MiniCssExtractPlugin</a>을 이용하면 된다.</p>\n<p>MiniCssExtractPlugin은 CSS를 스크립트를 통해 DOM에 주입하지 않고 별도의 CSS 파일에 저장한 뒤, 빌드시에 해당 CSS 파일을 삽입하는 link 태그를 HTML에 삽입한다. 즉 동적으로 CSS를 주입하지 않는다. 따라서 이를 이용하면 스크립트가 완전히 다 실행되기 전까지 페이지 스타일이 적용되지 않는 현상을 해결할 수 있다.</p>\n<p>MiniCssExtractPlugin을 이용하기 위해서는 먼저 해당 패키지를 설치해야 한다. 다음 명령어로 해당 패키지를 설치한다.</p>\n<pre><code class=\"hljs language-bash\">yarn add --dev mini-css-extract-plugin</code></pre>\n<p>그 다음 <code>webpack.config.js</code> 파일에서 다음 부분을 다음과 같이 수정한다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 수정 전</span>\n<span class=\"hljs-attr\">module</span>: {\n        ...commons.module,\n        <span class=\"hljs-attr\">rules</span>: [\n            ...commons.module.rules,\n            <span class=\"hljs-comment\">// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)</span>\n            <span class=\"hljs-comment\">// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 </span>\n            <span class=\"hljs-comment\">// src/index.tsx Webpack 설정에만 추가한다.</span>\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n                use: [<span class=\"hljs-string\">&#x27;style-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>]\n            },\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        ...commons.plugins,\n        <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>,\n        <span class=\"hljs-comment\">// template 속성을 추가한다.</span>\n        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;./src/index.html&#x27;</span>\n    })],</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 수정 후</span>\n<span class=\"hljs-attr\">module</span>: {\n        ...commons.module,\n        <span class=\"hljs-attr\">rules</span>: [\n            ...commons.module.rules,\n            <span class=\"hljs-comment\">// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)</span>\n            <span class=\"hljs-comment\">// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 </span>\n            <span class=\"hljs-comment\">// src/index.tsx Webpack 설정에만 추가한다.</span>\n            <span class=\"hljs-comment\">// 그리고 프로덕션 빌드시에는 MiniCssExtractPlugin을 이용하여 js가 다 로드되기 전에는</span>\n            <span class=\"hljs-comment\">// 스타일이 적용되지 않는 버그를 해결한다.</span>\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n                use: [dev ? <span class=\"hljs-string\">&#x27;style-loader&#x27;</span> : MiniCssExtractPlugin.loader, <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>]\n            },\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        ...commons.plugins,\n        <span class=\"hljs-keyword\">new</span> MiniCssExtractPlugin(),\n        <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>,\n        <span class=\"hljs-comment\">// template 속성을 추가한다.</span>\n        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;./src/index.html&#x27;</span>\n    })],</code></pre>\n<p>위와 같이 수정한 후 정적 웹페이지를 빌드하면 이제 스크립트가 불러와지는동안 스타일이 적용되지 않는 문제가 해결된다.</p>\n"},"articleId":"webpack_and_react_ssg_3","series":[{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (1)","articleId":"webpack_and_react_ssg_1"},{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (2)","articleId":"webpack_and_react_ssg_2"},{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (3)","articleId":"webpack_and_react_ssg_3"}],"seriesName":"Webpack과 React를 이용한 정적 웹사이트 만들기","previousPost":{"name":"creating_mastodon_instance","metadata":{"title":"Mastodon 서버 구축하기","subtitle":"6$짜리 VPS와 CloudFlare를 이용한 인스턴스 구축","author":"LiteHell","date":"2023-07-22T15:55:38.110Z","category":"Dev","tags":["Mastodon","ActivityPub"]},"rendered":"<h1 id=\"트위터와-페디버스\">트위터와 페디버스</h1>\n<p>확실히 요즘 트위터는 달라졌다. 일론 머스크가 인수한 이후의 트위터는 확실히 뭔가 달라졌다. 뭔가 보여주겠다는 의지의 표출인가?</p>\n<p>이런 새로워진 트위터에 적응하지 못한 사람들은 <a href=\"https://joinmastodon.org\">마스토돈</a>이나 <a href=\"https://misskey-hub.net/\">미스키</a> 등의 <a href=\"https://www.w3.org/TR/activitypub/\">ActivityPub</a>를 구현한 분산형 SNS 인스턴스로 이주하고 있다. 국내의 이런 분산형 SNS는 대표적으로 다음과 같다.</p>\n<ul>\n<li><a href=\"https://twingyeo.kr/\">트잉여</a></li>\n<li><a href=\"https://planet.moe/\">플래닛</a></li>\n<li><a href=\"https://qdon.space/\">큐돈</a></li>\n<li><a href=\"https://ani.work/\">애니워크</a></li>\n<li><a href=\"https://social.silicon.moe\">SifNet Mastodon</a></li>\n<li><a href=\"https://hoto.moe\">hotomoe</a></li>\n</ul>\n<p>위와 같이 서로 AcitivtyPub 등의 프로토콜을 이용해 통신하는 SNS 서비스들의 집합을 <strong>Fediverse</strong>(페디버스)라 일컬는다. 페디버스는 서버간에 서로 통신할 수 있기 때문에 다른 서버에 있는 사용자와도 소통할 수 있다. 즉, 서버 A에서 서버 B에 있는 사람을 팔로우할 수도 있다.</p>\n<h1 id=\"mastodon-설치\">Mastodon 설치</h1>\n<p>분산형 SNS이니 당연히 본인이 직접 서버를 구축하는 것도 가능하다. 따라서 직접 VPS에 마스토돈을 설치했다. VPS 운영체제로는 데비안을 택했고, 사양은 Vultr $6 VPS로 했다.</p>\n<p>설치 자체는 <a href=\"https://docs.joinmastodon.org/admin/install/\">공식 홈페이지의 문서</a>를 따르는 식으로 진행했으나 중간중간 삽질을 약간 했다.</p>\n<h2 id=\"root-계정-전환\">root 계정 전환</h2>\n<p>마스토돈을 설치하기 위해서는 먼저 root 계정으로 전환한다. <code>su</code> 명령어를 이용하면 된다.</p>\n<h2 id=\"의존성-설치\">의존성 설치</h2>\n<p>그 다음, 의존성을 설치해야 한다. 의존성 설치 자체는 공식 홈페이지에 있는 명령어를 복사-붙여넣기하면 끝난다.</p>\n<p>첫번째로 다음 명령어를 실행해 node.js v16을 설치한다.</p>\n<pre><code class=\"hljs language-bash\">curl -sL https://deb.nodesource.com/setup_16.x | bash -</code></pre>\n<p>그리고 다음 명령어를 실행해 PostgreSQL와 기타 다른 의존성들을 설치한다.</p>\n<pre><code class=\"hljs language-bash\">apt install -y curl wget gnupg apt-transport-https lsb-release ca-certificates\nwget -O /usr/share/keyrings/postgresql.asc https://www.postgresql.org/media/keys/ACCC4CF8.asc\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;deb [signed-by=/usr/share/keyrings/postgresql.asc] http://apt.postgresql.org/pub/repos/apt <span class=\"hljs-subst\">$(lsb_release -cs)</span>-pgdg main&quot;</span> &gt; /etc/apt/sources.list.d/postgresql.list\napt update\napt install -y \\\n  imagemagick ffmpeg libpq-dev libxml2-dev libxslt1-dev file git-core \\\n  g++ libprotobuf-dev protobuf-compiler pkg-config nodejs gcc autoconf \\\n  bison build-essential libssl-dev libyaml-dev libreadline6-dev \\\n  zlib1g-dev libncurses5-dev libffi-dev libgdbm-dev \\\n  nginx redis-server redis-tools postgresql postgresql-contrib \\\n  certbot python3-certbot-nginx libidn11-dev libicu-dev libjemalloc-dev</code></pre>\n<h3 id=\"nodejs-버전-확인\">nodejs 버전 확인</h3>\n<p>다만 여기서 주의해야 하는 것이 있다. 시스템에 따라서 nodejs 16버전이 아닌 그보다 더 최신 버전이 설치됐었을 수도 있다.\n상관없지 않냐고? 상관있다, nodejs v16 버전이 아니면 나중에 webpack precompile 과정에서 오류가 난다.</p>\n<p>설치된 nodejs의 버전은 <code>node --version</code> 명령어로 확인할 수 있다.</p>\n<pre><code class=\"hljs language-bash\">$ node --version\nv18.13.0</code></pre>\n<p>이는 데비안 apt 레포지토리에 있는 <code>nodejs</code> 패키지 버전이 16보다 더 최신이기 때문에 발생한 문제이다. 이를 해결하기 위해서는 먼저 <code>sudo apt-cache policy nodejs</code>를 실행해 어떤 버전이 설치 가능한지 확인해야 한다.</p>\n<pre><code class=\"hljs language-bash\">$ sudo apt-cache policy nodejs\nnodejs:\n  Installed: 18.13.0+dfsg1-1\n  Candidate: 18.13.0+dfsg1-1\n  Version table:\n *** 18.13.0+dfsg1-1 500\n        500 https://deb.debian.org/debian bookworm/main amd64 Packages\n        500 https://debian.mirror.constant.com bookworm/main amd64 Packages\n     16.20.1-deb-1nodesource1 500\n        500 https://deb.nodesource.com/node_16.x bookworm/main amd64 Packages\n        100 /var/lib/dpkg/status</code></pre>\n<p>위 예시에서는 <code>18.13.0+dfsg1-1</code>과 <code>16.20.1-deb-1nodesource1</code> 버전이 설치 가능하다. 우리가 필요한 것은 nodejs v16대 버전이니 <code>16.20.1-deb-1nodesource1</code>을 설치할 것이다.</p>\n<p>apt에서 특정한 버전을 지정해 설치하기 위해서는 다음과 같이 명령어를 실행하면 된다.</p>\n<pre><code class=\"hljs language-bash\">$ sudo apt install nodejs=16.20.1-deb-1nodesource1</code></pre>\n<p>그러면 nodejs v16이 정상적으로 설치된 것을 확인할 수 있다.</p>\n<h3 id=\"yarn-설치\">Yarn 설치</h3>\n<p>위에서 nodejs, PostregreSQL 등의 의존성을 다 설치했으면 <a href=\"https://yarnpkg.com\">Yarn</a>을 설치해야 한다. Yarn은 다음 명령어로 설치한다.</p>\n<pre><code class=\"hljs language-bash\">corepack <span class=\"hljs-built_in\">enable</span>\nyarn <span class=\"hljs-built_in\">set</span> version classic</code></pre>\n<p>혹시 위 명령어가 작동하지 않는다면 다음과 같이 npm을 이용해 설치할 수도 있다.</p>\n<pre><code class=\"hljs language-bash\">sudo npm i -g yarn</code></pre>\n<p>만약 위 npm을 이용한 명령어가 npm이 설치되어 있지 않아 실행되지 않는다면 아래 명령어로 npm을 실치할 수 있다.</p>\n<pre><code class=\"hljs language-bash\">curl -qL https://www.npmjs.com/install.sh | sh</code></pre>\n<h2 id=\"ruby-설치\">Ruby 설치</h2>\n<p>이제 Ruby를 설치해야 한다. 먼저 <code>mastodon</code>이라는 이름의 리눅스 계정을 생성한다.</p>\n<pre><code class=\"hljs language-bash\">adduser --disabled-login mastodon</code></pre>\n<p>그리고 쉘을 지정한다. (안 하면 <code>sudo su - mastodon</code> 명령어가 오류날 수 있다.) 아래 명령어에서는 쉘을 bash로 지정했는데, 쉘이 무조건 bash여야 할 필요는 없다. 선호하는 쉘이 있다면 그 쉘로 지정해도 된다.</p>\n<pre><code class=\"hljs language-bash\">chsh -s /bin/bash mastodon</code></pre>\n<p>이제 mastodon으로 계정을 전환하자.</p>\n<pre><code class=\"hljs language-bash\">sudo su - mastodon</code></pre>\n<p>다음 명령어를 모두 실행해 Ruby를 설치한다.</p>\n<pre><code class=\"hljs language-bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/rbenv/rbenv.git ~/.rbenv\n<span class=\"hljs-built_in\">cd</span> ~/.rbenv &amp;&amp; src/configure &amp;&amp; make -C src\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;eval &quot;$(rbenv init -)&quot;&#x27;</span> &gt;&gt; ~/.bashrc\n<span class=\"hljs-built_in\">exec</span> bash\ngit <span class=\"hljs-built_in\">clone</span> https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build\nRUBY_CONFIGURE_OPTS=--with-jemalloc rbenv install 3.0.6\nrbenv global 3.0.6</code></pre>\n<p>Ruby 설치가 완료됐다면 bundler도 설치한다.</p>\n<pre><code class=\"hljs language-bash\">gem install bundler --no-document</code></pre>\n<p>Ruby와 bundler 설치를 마쳤다면 root 유저로 되돌아간다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">exit</span></code></pre>\n<h2 id=\"postgresql-설정\">PostgreSQL 설정</h2>\n<p>공식 문서에서 pgTune을 쓰고 싶으면 쓰라고 나와있는데 필자는 귀찮아서 건너뛰었다.</p>\n<p>PostgreSQL 설정을 위해 다음 명령어로 PostgreSQL 쉘을 띄운다.</p>\n<pre><code class=\"hljs language-bash\">sudo -u postgres psql</code></pre>\n<p>PostgreSQL 쉘이 띄워졌으면 다음 쿼리를 실행해서 SQL 계정을 생성한다.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span> mastodon CREATEDB;</code></pre>\n<p>계정이 생성됐으면 다음 명령을 쳐서 쉘을 빠져나온다.</p>\n<pre><code class=\"hljs language-sql\">\\q</code></pre>\n<h2 id=\"마스토돈-다운로드\">마스토돈 다운로드</h2>\n<p>이제 마스토돈을 다운로드하고 설정할 때가 왔다. 먼저 mastodon 계정으로 전환한다.</p>\n<pre><code class=\"hljs language-bash\">sudo su - mastodon</code></pre>\n<p>다음 명령어를 실행해 최신 stable 버전의 mastodon을 다운로드한다.</p>\n<pre><code class=\"hljs language-bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/mastodon/mastodon.git live &amp;&amp; <span class=\"hljs-built_in\">cd</span> live\ngit checkout $(git tag -l | grep -v <span class=\"hljs-string\">&#x27;rc[0-9]*$&#x27;</span> | sort -V | tail -n 1)</code></pre>\n<p>이제 Ruby 의존성과 JavaScript 의존성을 설치한다.</p>\n<pre><code class=\"hljs language-bash\">bundle config deployment <span class=\"hljs-string\">&#x27;true&#x27;</span>\nbundle config without <span class=\"hljs-string\">&#x27;development test&#x27;</span>\nbundle install -j$(getconf _NPROCESSORS_ONLN)\nyarn install --pure-lockfile</code></pre>\n<h2 id=\"서버-swap-설정-및-nodejs-heap-용량-설정\">서버 swap 설정 및 nodejs heap 용량 설정</h2>\n<p>마스토돈 설정(바로 다음 문단)을 하는 과정에서 Javascript heap out of memory 오류가 발생할 수 있다. 이는 서버에 RAM이 부족하기 때문이다. 이를 해결하기 위해서는 RAM을 더 꽂거나 swap 파일을 형성하고, 그 다음 node 설정을 수정해야 한다.</p>\n<p>먼저 swap파일을 생성하는 방법은 다음과 같다. 용량은 적절하게 바꾸면 된다.</p>\n<pre><code class=\"hljs language-bash\">sudo fallocate -l 2G /tmp-swapfile\nsudo chmod 600 /tmp-swapfile\nsudo mkswap /tmp-swapfile</code></pre>\n<p>생성된 swap파일은 다음과 같이 적용할 수 있다.</p>\n<pre><code class=\"hljs language-bash\">sudo swapon /tmp-swapfile</code></pre>\n<p>위 명령어로 적용된 swap파일은 재부팅이 될 시 다시 적용되지 않으므로 재부팅을 하면 위 명령어를 다시 쳐줘야 한다. 따라서 swap 파일을 영구적으로 적용하기 위해서는 <code>/etc/fstab</code> 파일을 수정해야 하나, 본 글에서는 마스토돈을 설정하는 동안에만 임시적으로 이용할 swap 파일을 생성하는 것이므로 이 파일을 수정하는 방법에 대해서 언급하지 않는다.</p>\n<p>이제 node 설정을 바꾸어야 한다. 먼저 현재 할당한 힙 용량을 다음 명령어로 확인한다.</p>\n<pre><code class=\"hljs language-bash\">node -e <span class=\"hljs-string\">&#x27;console.log(v8.getHeapStatistics().heap_size_limit/(1024*1024))&#x27;</span></code></pre>\n<p>실행하면 다음과 같이 뜰 것이다.</p>\n<pre><code class=\"hljs language-bash\">$ node -e <span class=\"hljs-string\">&#x27;console.log(v8.getHeapStatistics().heap_size_limit/(1024*1024))&#x27;</span>\n495.75</code></pre>\n<p>위 용량을 참고해서 위 용량보다 적당히 더 큰 용량으로 힙 용량을 설정하면 된다. 힙 용량의 설정은 다음 명령어를 마스토돈 설정 명령어 실행 직전에 실행함으로써 할 수 있다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">export</span> NODE_OPTIONS=--max_old_space_size=800</code></pre>\n<h2 id=\"마스토돈-설정\">마스토돈 설정</h2>\n<p>다음 명령어를 실행해 마스토돈 서버를 설정한다.</p>\n<pre><code class=\"hljs language-bash\">RAILS_ENV=production bundle <span class=\"hljs-built_in\">exec</span> rake mastodon:setup</code></pre>\n<p>만약 Javascript heap out of memory 오류가 떴다면 바로 윗 문단에 따라 힙 용량 및 swap 설정을 하고 다음 명령어를 실행하면 된다.</p>\n<pre><code class=\"hljs language-bash\">RAILS_ENV=production bundle <span class=\"hljs-built_in\">exec</span> rails assets:precompile</code></pre>\n<p>성공적으로 실행됐을 시 마스토돈 관리자 비밀번호가 표시될 것이다. 잊지 말고 메모하도록 하자.</p>\n<h2 id=\"nginx-설정\">nginx 설정</h2>\n<p>다음 명령어를 실행한다.</p>\n<pre><code class=\"hljs language-bash\">cp /home/mastodon/live/dist/nginx.conf /etc/nginx/sites-available/mastodon\nln -s /etc/nginx/sites-available/mastodon /etc/nginx/sites-enabled/mastodon</code></pre>\n<p><code>/etc/nginx/sites-available/mastodon</code> 파일에서 <code>example.com</code>을 모두 자신의 마스토돈 도메인(내 경우에는 <code>social.litehell.info</code>)로 바꾼다. 그리고 다음 명령어를 실행한다.</p>\n<pre><code class=\"hljs language-bash\">systemctl reload nginx</code></pre>\n<h2 id=\"cloudflare-origin-certificate-설정\">CloudFlare Origin Certificate 설정</h2>\n<p>필자는 CloudFlare Origin Certificate를 쓴다. CloudFlare에서 Origin Certificate를 생성한 뒤 서버에 저장하고, <code>/etc/nginx/sites-available/mastodon</code> 파일에서 <code>ssl_certificate</code> 속성과 <code>ssl_certificate_key</code>를 다운받은 서버/서버 개인키 경로로 수정하면 된다.</p>\n<h2 id=\"systemd-설정\">systemd 설정</h2>\n<p>아래 명령어를 실행한다.</p>\n<pre><code class=\"hljs language-bash\">cp /home/mastodon/live/dist/mastodon-*.service /etc/systemd/system/\nsystemctl daemon-reload\nsystemctl <span class=\"hljs-built_in\">enable</span> --now mastodon-web mastodon-sidekiq mastodon-streaming\n</code></pre>\n<p>그러면 마스토돈이 실행될 것이다. 이제 즐기면 된다.</p>\n<h2 id=\"cloudflare-최적화로-인한-사이트-깨짐-문제-해결\">CloudFlare 최적화로 인한 사이트 깨짐 문제 해결</h2>\n<p><img src=\"/img/broken_css_mastodon.png\" alt=\"CSS가 정상적으로 불러와지지 않은 마스토돈 인스턴스의 스크린샷\"></p>\n<p>CloudFlare를 쓰면 위와 같이 마스토돈이 깨지는 문제를 겪을 수 있다.\n이는, 무결성을 위해 HTML 내에 CSS 파일의 해시가 포함되어있는데, CloudFlare가 CSS를 자동 최적화하면서 CSS 파일이 변경되고, 이로 인해 해시가 불일치됨에 따라 웹브라우저가 CSS를 불러오지 않음으로써 발생하는 문제이다.</p>\n<p>이 문제는 CloudFlare에서 Auto Minify를 비활성화하고 모든 캐시를 삭제하여 해결할 수 있다.</p>\n<h2 id=\"릴레이-연결\">릴레이 연결</h2>\n<p>마스토돈에 혼자 있으면 외롭다. 이를 극복하기 위해서는 릴레이를 연결해야 한다. 페디버스 내에서 인스턴스는 기본적으로 게시물을 팔로워가 있는 서버에만 전송한다. 따라서 타 서버의 팔로워가 없는 인스턴스는 외로울 수 밖에 없다. 이를 극복하기 위해 릴레이가 있다.</p>\n<p>릴레이는 구독하는 서버들간에 게시물을 나눈다. 릴레이에 구독된 인스턴스가 게시물을 릴레이로 보내면, 릴레이가 구독된 모든 서버들에게 게시물을 전송하는 방식이다. 따라서 릴레이내에 있는 서버간에는 팔로워가 있는지의 여부와 상관없이 게시물이 서로 공유된다.</p>\n<p>한국어권 릴레이는 다음 세가지 릴레이가 있다. 이 릴레이는 모두 화이트리스트이다.</p>\n<ul>\n<li><a href=\"https://relay.mastodon.kr\">한국 Mastodon 인스턴스 연합(가칭) 릴레이</a></li>\n<li><a href=\"https://interstellar.flights\">인터스텔라 릴레이 커뮤니티</a></li>\n<li><a href=\"https://relay.musubi.moe\">musubi.moe</a></li>\n</ul>\n<p>위 릴레이에 가입하기 위해서는 각 릴레이에서 요구하는 조건을 모두 만족시킨 뒤 릴레이측에 가입 신청을 하면 된다. 가입 신청 방법 및 조건은 릴레이마다 다르다. 가입 신청이 받아들여지면 릴레이 관리 페이지(<code>/admin/relays</code>)에서 해당 릴레이에서 안내하는 주소를 추가하면 된다. 참고로 내 경험상 개인 인스턴스라고 딱히 안 받아주진 않았다. 조건만 맞으면 받아주는 것 같으니 조건이 맞는다면 부담없이 신청해보자.</p>\n<p>모든 릴레이가 화이트리스트인 것은 아니다. <a href=\"https://relaylist.com\">RelayList</a>에서 Registeration이 open으로 되어있는 릴레이는 가입신청을 하지 않아도 되는 릴레이들이다. 다만 대규모 릴레이는 구독이 처리되는 데 시간이 좀 오래 걸릴 수 있다.</p>\n<p><a href=\"https://relay.fedi.buzz/\">#FediBuzz Relay</a> 서비스를 이용하면 특정 마스토돈 인스턴스의 타임라인을 릴레이를 통해 구독할 수도 있다. 해당 사이트의 안내를 따르면 특정 인스턴스의 타임라인을 구독할 수 있다.</p>\n<h2 id=\"publicsystem-용량-문제\">public/system 용량 문제</h2>\n<p><code>public/system</code> 디렉토리는 용량을 많이 잡아먹는다. 다음 두 가지 방법 중 하나를 택하여 해결하면 된다.</p>\n<ul>\n<li>S3-Compatible Object Storage 쓰기</li>\n<li><a href=\"https://docs.joinmastodon.org/admin/setup/#cleanup\">마스토돈 공식 홈페이지의 Running periodic cleanup tasks 문단</a>에 따라 crontab을 생성하고 마스토돈이 설치된 디렉토리에서 다음 명령어 모두 실행하기<pre><code class=\"hljs language-bash\">RAILS_ENV=production ./bin/tootctl accounts prune\nRAILS_ENV=production ./bin/tootctl cache clear\nRAILS_ENV=production ./bin/tootctl media remove --days=0\nRAILS_ENV=production ./bin/tootctl media remove --prune-profiles --days=0\nRAILS_ENV=production ./bin/tootctl preview_cards remove --days=0</code></pre>\n<ul>\n<li>crontab과 위 명령어만으로 부족하면 그냥 대용량 하드디스크 하나 꽂고 <code>/etc/fstab</code> 파일 수정해서 <code>public/system</code> 디렉토리에 영구 마운트해버리기 (좀 무식하게 보일 수도 있지만 간단하고 직빵이다)</li>\n</ul>\n</li>\n</ul>\n<p>마음에 드는 방법을 택하도록 하자.</p>\n"},"nextPost":{"name":"fcitx5_for_101_key_keyboard_kde_laptop","metadata":{"title":"한글 입력을 위한 fcitx5 설치","subtitle":"KDE 노트북에서의 버그없는 한글 입력을 위한 삽질기","author":"LiteHell","date":"2023-10-17T12:34:16.790Z","category":"Linux","tags":["Linux","Korean","Hangul","IM","KDE"],"last_modified_at":"2023-10-17T14:32:47.687Z"},"rendered":"<h1 id=\"서론\">서론</h1>\n<p>필자는 초창기에 <a href=\"https://github.com/ibus/ibus\">ibus</a>를 썼었다. ibus는 웬만한 프로그램에서 아무 버그없이 잘 작동한다. 딱 한가지, 리브레오피스에서 공백 입력이 안 된다는 치명적인 버그만 빼면 말이다.</p>\n<p>그래서 ibus 다음으로 <a href=\"https://github.com/hamonikr/nimf\">하모니카에서 유지보수하는 nimf</a>를 썼었다. nimf는 리브레오피스에서의 치명적인 버그는 없었지만, 엔터키를 누르면 텍스트가 사라지는 버그가 있었다. 근데 이 버그, 처음에만 짜증나지 좀 지나면 적응된다. 그래서 적응해서 쓰다가 생각해보니 &#39;이건 좀 아닌 것 같다&#39;싶어서 다른 입력기를 설치했다.</p>\n<p>본 블로그 글은 <a href=\"https://archlinux.org/\">Arch Linux</a>를 기준으로 설명한다.</p>\n<h2 id=\"kde에서의-키보드-레이아웃\">KDE에서의 키보드 레이아웃</h2>\n<p>입력기를 바꾸기 위해 삽질하는 과정에서 한글키가 오른쪽 Alt키로 인식되는 현상을 확인했다. 분명히 아치 리눅스 설치 초기에 매핑을 했었는데, 시스템 업데이트를 하는 과정에서 원상복구가 된 것 같다. 그래서 이번에는 KDE 설정 프로그램을 이용해 한글키와 한자키를 매핑했다.</p>\n<p><img src=\"/img/kde_keyboard_settings.png\" alt=\"KDE 키보드 설정 프로그램\"></p>\n<p>위와 같이 시스템 설정 프로그램의 <strong>입력 장치 🠞 키보드</strong> 화면에서 <strong>오른쪽 Alt 키를 한/영 키로 만들기</strong>, <strong>오른쪽 Ctrl 키를 한자 키로 만들기</strong> 항목을 체크하면 된다. (키보드 레이아웃에 따라 약간 다를 수 있다.) 노트북 등의 101/104키 호환 레이아웃이라면 위 과정을 반드시 거쳐야 한다.</p>\n<h3 id=\"한영-한자키-인식여부-확인방법\">한/영, 한자키 인식여부 확인방법</h3>\n<p>본인 키보드가 101/104키인지 106키인지 헷갈린다면 <del>키보드 키 갯수 세지말고</del> 먼저 <code>xev</code> 프로그램을 설치한다.</p>\n<pre><code class=\"hljs language-bash\">sudo pacman -S xorg-xev</code></pre>\n<p>그리고 콘솔 창에서 xev 프로그램을 실행한다.</p>\n<pre><code class=\"hljs language-bash\">xev</code></pre>\n<p>xev 프로그램 창을 활성화하고 한글키랑 한자키를 눌러본다. 다음과 같이 콘솔 창에 <em>Hangul</em>이나 <em>Hangul_Hanja</em>키가 인식된 메세지가 출력되면 한/영 키, 한자 키가 정상적으로 인식되는 것이다.</p>\n<pre><code>KeyRelease event, serial 39, synthetic NO, window 0x9000001,\n    root 0x79b, subw 0x0, time 1234567, (-10, 10), root:(10, 10),\n    state 0x0, keycode 108 (keysym 0xff31, Hangul), same_screen YES,</code></pre>\n<pre><code>KeyPress event, serial 39, synthetic NO, window 0x9000001,\n    root 0x79b, subw 0x0, time 1234567, (10, 10), root:(10, 10),\n    state 0x0, keycode 105 (keysym 0xff34, Hangul_Hanja), same_screen YES,</code></pre>\n<p>만약 위와 같은 메세지가 안 뜨고 Alt_R이나 Control_R이 인식된다면 <a href=\"#kde에서의-키보드-레이아웃\">위에 써진 내용</a>에 따라 매핑하면 된다.</p>\n<h2 id=\"fcitx5-설치-방법\">fcitx5 설치 방법</h2>\n<p>먼저, 다음 명령어를 실행해 fcitx5를 설치한다.</p>\n<pre><code class=\"hljs language-bash\">sudo pacman -S fcitx5-im fcitx-hangul</code></pre>\n<p><code>/etc/environment</code> 파일에 다음 내용을 추가한다. 입력기로 fcitx를 쓰도록 지정하는 작업이다.</p>\n<!-- ini파일이 아니지만 syntax highlighting을 위해 형식을 ini으로 지정함 --->\n<pre><code class=\"hljs language-ini\"><span class=\"hljs-attr\">GTK_IM_MODULE</span>=fcitx\n<span class=\"hljs-attr\">QT_IM_MODULE</span>=fcitx\n<span class=\"hljs-attr\">QT4_IM_MODULE</span>=fcitx\n<span class=\"hljs-attr\">QT5_IM_MODULE</span>=fcitx\n<span class=\"hljs-attr\">XMODIFIERS</span>=@im=fcitx</code></pre>\n<p>그 다음에 <code>~/.xprofile</code> 파일에 다음 내용을 추가한다. 부팅시에 fcitx5가 실행되도록 한다.</p>\n<pre><code class=\"hljs language-bash\">fcitx5 -d</code></pre>\n<p>재부팅하고 <code>env | grep fcitx</code> 명령어를 실행해 환경변수가 제대로 변경됐는지 확인해보자. 제대로 변경됐다면 다음과 같이 뜰 것이다.</p>\n<pre><code class=\"hljs language-bash\">GTK_IM_MODULE=fcitx\nQT4_IM_MODULE=fcitx\nXMODIFIERS=@im=fcitx\nQT5_IM_MODULE=fcitx\nQT_IM_MODULE=fcitx</code></pre>\n<p>만약 환경변수가 제대로 변경되지 않았다면 <code>~/.xprofile</code> 파일에서 <code>fcitx5 -d</code> 위에 다음 내용을 추가하고 재부팅한다. 그러면 환경변수가 정상적으로 변경될 것이다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">export</span> $(/usr/lib/systemd/user-environment-generators/30-systemd-environment-d-generator)</code></pre>\n<h2 id=\"fcitx5-설정\">fcitx5 설정</h2>\n<p><code>fcitx5-configtool</code> 명령어를 실행하면 다음 창이 뜬다.\n<img src=\"/img/fcitx5_settings_first_screen.png\" alt=\"fcitx5 KDE 설정 창\"></p>\n<p>위 화면에서 한국어가 안 보이면 <strong>입력기 추가</strong>버튼을 눌러서 추가한다. (입력기 추가 화면에서 한국어가 안 보이면 <strong>현재 언어만 표시</strong> 옵션을 해제하면 된다.)</p>\n<p>밑에서 <strong>전역 옵션 구성하기...</strong> 버튼을 누르면 다음 화면이 뜬다.</p>\n<p><img src=\"/img/fcitx5_global_settings.png\" alt=\"fcitx5 KDE 설정 창\"></p>\n<p><strong>Trigger Input Method</strong>가 한/영을 전환하는 단축키 설정이다. 오른쪽의 <strong>+</strong> 버튼을 눌러 한글 키를 추가하면 된다.</p>\n<p>fcitx5는 기본적으로 한/영을 전환할때 작은 툴팁을 표시한다. 거슬리면 위 화면에서 <strong>Show Input Method Information when switch input method</strong>를 체크 해제하면 된다.</p>\n<p>이제 한글 입력을 버그없이 잘 할 수 있게 됐다. 끝!</p>\n"}},"__N_SSG":true}