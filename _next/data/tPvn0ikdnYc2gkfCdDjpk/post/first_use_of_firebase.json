{"pageProps":{"article":{"metadata":{"title":"Firebase 처음 써본 이야기","subtitle":"데이터베이스 스카마 설계하기 귀찮을 때","author":"LiteHell","date":"2021-02-28T22:40:29+09:00","category":"Dev","tags":["Firebase","React"]},"rendered":"<h1 id=\"발단\">발단</h1>\n<p><a href=\"/post/oauth2_and_oidc\">전 글</a>에서 동아리 인증 시스템을 만들 때, 동아리 소개 홈페이지도 같이 만들었다. 동아리 홈페이지를 만들어두면 나중에 홍보할 때 써먹을 수 있겠다는 판단이 들어서였다. 그래서 그때 당시(2020년 초)에 <a href=\"https://pages.github.com/\">GitHub Pages</a>와 <a href=\"https://startbootstrap.com/theme/creative\">Creative 템플릿</a>을 이용해 간단히 제작했다.</p>\n<p>그 다음 연도(2021년 초)에 회장이 바뀌고 회장 전화번호를 수정하면서 <a href=\"https://getbootstrap.com\">Bootstrap</a> 의존성을 걷어내고 순수 CSS와 HTML, JS(+jQuery)로만 재작성했다. 그 때 당시에는 1페이지의 홈페이지로, 간단한 동아리 소개와 회장단 연락처, 동아리 가입신청 링크만 있었다.</p>\n<p>이때 당시에는, 홈페이지 수정이 1년에 한 두번만 있을 것이라고 생각했었다. 그래서 그냥 간단하게 GitHub Pages를 이용해서 게시했다. 어처피 내가 곧 군대를 가게 될지라도 수정해주고 가면 될 것이라 판단도 있었다.</p>\n<h1 id=\"수정-가능한-형태\">수정 가능한 형태</h1>\n<p>그러나 새 회장은 홈페이지를 보다 더 적극적으로 이용하고자 했다. 그래서 내게 홈페이지를 자신이 수정 가능하게 해달라는 부탁을 했고, 나는 공부도 해볼 겸 나쁘지 않겠다 싶어서 그 요청을 수락했다.</p>\n<h2 id=\"웹사이트-디자인\">웹사이트 디자인</h2>\n<p>먼저 웹 사이트를 수정 가능한 형태로 하려면 웹 사이트 디자인을 먼저 생각해야 한다. 앞서 말한 2020년 초 디자인이 간단한 카드형태였는데, 그때의 디자인을 살리면 괜찮겠다고 생각했다. 그래서 웹 사이트를 &quot;제목, 내용&quot; 이 두가지로 이루어진 &quot;카드&quot;들의 집합으로 정의하고 디자인했다.</p>\n<p>결과는 꽤 그럴싸하게 나왔다. 간단한 CSS 애니메이션을 주니 보기 좋더라. 나는 디자인 지식이 전무한 공학도이기 때문에 근사한 디자인보다는 그럴싸한 디자인이 최선이었다.</p>\n<h2 id=\"rdb를-써볼까\">RDB를 써볼까?</h2>\n<p>처음에는 <a href=\"https://www.mariadb.org\">MariaDB</a>같은 관계형 데이터베이스를 이용하려 했다. 근데 MariaDB를 이용하려면 먼저 데이터베이스 스카마를 설계해야 하는 데 이게 너무 귀찮았다.\n그래서 <a href=\"https://www.mongodb.com/\">MongoDB</a>를 써볼까란 생각도 했었는데 MongoDB를 서버에 설치하는 것도 귀찮았다. 그래서 &#39;어떻게 할까...&#39; 생각하고 있었는데 마침 교내 학술동아리 발표에서 <a href=\"https://firebase.google.com\">Firebase</a>에 관해 말하더라. 생각해보니 Firebase를 써보는 것도 나쁘지 않겠다는 생각이 들었다.</p>\n<h1 id=\"firebase를-써보았다\">Firebase를 써보았다.</h1>\n<p>그래서 Firebase를 썼다. Firebase는 Google에서 출시한 데이터베이스/스토리지/호스팅 등을 한 데 몪아놓은 서비스로, 번잡한 서버구성 없이 바로 사용할 수 있다는 것이 특징이다.\nFirebase의 데이터베이스는 두 가지 종류가 있다. 가장 먼저 나온 것이 실시간 데이터베이스이고, 그 다음에 나온 것이 Cloud Firestore이다. 실시간 데이터베이스는 데이터를 <strong>하나의 JSON 트리</strong>로 보고, Cloud Firestore를 데이터를 <strong>여러개의 JSON 문서들의 집합</strong>(MongoDB를 떠올리면 이해가 쉽다)로 본다.\n어처피 동아리 소개 홈페이지는 하나의 페이지로 이루어져 있기에, 하나의 페이지를 만드는데 필요한 데이터는 하나일 것이라고 생각했다. 따라서 실시간 데이터베이스를 채택했다.</p>\n<h2 id=\"thounghts-in-react\">Thounghts in React</h2>\n<p>이번 동아리 소개 홈페이지를 만들 때는 <a href=\"https://reactjs.org\">React.js</a>를 채택했다. <a href=\"/post/oauth2_and_oidc\">저번</a>에는 Vue를 썼으니 이번에는 React를 써보자는 것이 그 이유였다.\n이번 홈페이지를 만드는 데 있어 복잡도가 그리 높지 않았기에, Redux와 같은 스토어를 이용하지 않았다. 따라서 데이터가 아래로 내려갔다가 위로 다시 올라오는 방식으로 모든 코드를 작성했다.</p>\n<p>본 홈페이지에서 필요한 페이지들은 다음과 같다.</p>\n<ul>\n<li><code>/</code> : 메인 페이지</li>\n<li><code>/edit</code> : 편집 페이지</li>\n<li><code>/edit/preview</code> : 편집할 때 미리보는 페이지</li>\n</ul>\n<p>메인 페이지와 미리보기 페이지는 데이터를 편집할 필요가 없기 때문에 단방향의 데이터 흐름만 구현하면 된다. 따라서 해당 페이지들은 Firebase 데이터베이스에서 데이터를 받아 하위 컴포넌트에 전달하는 방식으로 이루어져 있다. 다만 약간의 차이점이 있다면 메인 페이지는 데이터를 한 번만 받고 (<code>once</code> 메소드) 미리보기 페이지는 데이터가 바뀌면 다시 받는다는 점 (<code>on</code> 메소드)이 있다.</p>\n<p>그러나 편집 페이지는 데이터를 수정해야 하므로 양방향의 데이터 흐름이 필요하다. 따라서 데이터를 하위 컴포넌트에 전달해 표현하고, 수정이 발생하면 하위 컴포넌트에서 상위 컴포넌트로 계속 올라가다 종착지에서 데이터를 수정하는 <a href=\"https://ko.reactjs.org/docs/thinking-in-react.html\">React스러운 사고방식</a>으로 작성했다.</p>\n<p>하위 컴포넌트에서 텍스트 입력 등 변경사항이 발생해 상위 컴포넌트로 올라갈 때 새로운 변경사항이 반영된 데이터를 같이 전달한다. 모든 하위 컴포넌트들은 자신이 담당하는 데이터만을 가지므로 이는 &quot;웹사이트 전체 데이터&quot;의 일부이다. 이 데이터를 전달받은 상위 컴포넌트는 이 전달받은 데이터를 자신이 관리하는 데이터(prop의 값)에 병합한 데이터를 자신의 상위 컴포넌트로 올려보낸다. 이 상위 컴포넌트들은 하위 컴포넌트보다 더 많은 데이터를 관리하므로, 데이터의 규모는 점점 커지게 된다. 따라서 이를 계속 반복하다 보면, 새로운 변경사항이 반영된 &quot;웹사이트 전체의 데이터&quot;를 받게 된다. 이 &quot;웹사이트 전체의 데이터&quot;를 Firebase 실시간 데이터베이스에 저장하게 함으로써 편집 기능을 구현했다.</p>\n<p>데이터베이스에 저장한 이후의 데이터를 표현하는 방식에 관해서는, 데이터베이스에 값이 저장되는 순간 Firebase에서 value 이벤트를 발생시키고, 이에 연결된 이벤트 리스너가 페이지의 prop를 수정하게 된다. 따라서 페이지의 prop이 수정됨에 따라 하위 컴포넌트들의 prop도 같이 수정되게 되므로 별도의 특별한 코드가 필요하지 않았다.</p>\n<h2 id=\"파일-핸들링\">파일 핸들링</h2>\n<p>Firebase는 파일 저장을 위한 Storage 기능도 지원한다. Storage에 저장할 때 mime-type만 지정하면 이미지 표시에는 딱히 큰 지장이 없으므로 파일 이름을 <a href=\"https://github.com/ericelliott/cuid\">cuid</a> 라이브러리를 이용해 난수로 저장하게 했다. 다만 그러면 편집 페이지에서 볼 때 불편한 점이 있으므로 커스텀 메타데이터로 본래 파일이름도 같이 저장하게 했다.</p>\n<h2 id=\"firebase와-인증-통합\">Firebase와 인증 통합</h2>\n<p>Firebase에서 OpenID Connect를 지원했기에, 기존 동아리의 인증 시스템과 Firebase를 통합하는 것은 그리 어렵지 않았다. 다만 의외의 복병은 Firebase가 Id Token Authorization Grant만을 지원한다는 점이였다. 따라서 Authorization code grant만을 지원하던 인증 시스템을 수정하는 번거로움이 약간 있었다.</p>\n<p>Firebase의 인증을 통합할때는 <a href=\"https://cloud.google.com/identity-platform\">Google Identity Platform</a>을 이용하면 된다. 데이터베이스나 스토리지의 보안 규칙을 작성할 때 <code>auth.token.firebase.sign_in_attributes</code> 속성으로 ID 토큰의 커스텀 속성에 접근할 수 있으므로 이를 이용해 기존 인증 시스템의 권한 관리도 통합할 수 있었다.</p>\n<h2 id=\"결론\">결론</h2>\n<p>Firebase는 서비스를 빠르게 개발하는 데에 좋은 것 같다.</p>\n"},"articleId":"first_use_of_firebase","previousPost":{"name":"oauth2_and_oidc","metadata":{"title":"OAuth 2.0과 OpenID Connect Core 1.0","subtitle":"동아리 홈페이지와 통합 인증에 관한 이야기","author":"LiteHell","date":"2021-01-25T18:27:00+09:00","category":"Dev","tags":["SSO","OAuth","OpenID_Connect"]},"rendered":"<h1 id=\"들어가는-말\">들어가는 말</h1>\n<p>얼떨결에 동아리에서 자리를 하나 맡게 되면서 사이트를 인수인계받았다. <a href=\"https://github.com/2du/openNAMU\">오픈나무</a>을 약간 수정해서 자체적으로 운영하던 사이트였는데, 회원들의 사적인 정보가 담겨있었다. 이걸 그냥 개방된 채로 뒀다가 사고가 나면 어떻게 될 지 상상하고 싶지 않더라.\n그래서 사이트를 운영하기에 앞서 다음과 같이 수정해야할 필요가 있었다.</p>\n<ul>\n<li>위키를 외부인에게 공개해선 안 됐다.</li>\n<li>누구나 위키에 가입해선 안 됐다.</li>\n<li>학교 학생임을 증명해야 했다.</li>\n</ul>\n<h1 id=\"오픈나무-수정\">오픈나무 수정</h1>\n<p>첫번째 목표는 오픈나무에서 제공하는 ACL기능을 이용해서 달성할 수 있다. (ACL 기능을 <a href=\"https://github.com/2du/openNAMU/pull/923\">도구로까지 확장하면</a> 더 완벽히 틀어막을 수 있다.)\n다만 두번째 목표부터는 쉽지 않았다. 두번째 목표를 달성하려면 회원가입을 위키 소유자가 통제할 수 있는 기능이 필요했는데, 오픈나무에는 그런 기능이 없었다. 그래서 직접 <a href=\"https://github.com/2du/openNAMU/pull/819\">회원가입 승인 기능</a>을 추가했다. 세번째 목표는 이메일 인증을 강제하고 도메인을 제한하는 방향으로 접근했다. 이걸 하려면 오픈나무에서 제공하는 이메일 화이트리스트 기능을 쓰면 되는데, 사소한 문제가 있었다. 오픈나무가 네이버, G메일, 다음, 카카오 메일을 강제로 자동추가한다는 점이다. (하드코딩이라 삭제도 안 된다.) 그래서 <a href=\"https://github.com/2du/openNAMU/pull/821\">약간의 수정</a>으로 이 문제를 해결했다. 또한 이메일 발송시에 구글을 안 쓰는데 메일 발송 설정에서 구글만을 지원해서 이것도 <a href=\"https://github.com/2du/openNAMU/pull/842\">수정</a>했다.</p>\n<h2 id=\"게시판을-만들까\">게시판을 만들까?</h2>\n<p>그렇게 위키를 수정해서 굴리고 있었는데 문득 게시판이 있으면 좋겠다는 생각이 들었다.\n근데 귀찮다고 XE만 깔고 통치면 위키랑 XE가 아이디가 따로 놀잖아.</p>\n<p>이거는 보기가 별로 예쁘지 않다. 그래서 통합 로그인을 구축하기로 했다.</p>\n<h3 id=\"접근방식\">접근방식</h3>\n<p>로그인을 통합하기 위해서는, 아이디와 비밀번호 등 인증 정보를 관리하는 서비스가 필요했다. 이 문단에서는 이를 <code>통합 로그인 제공자</code>라고 통칭한다.</p>\n<p>위키밖에 없는 상황이니, 통합 로그인 제공자가 있을리 없었다. 이런 때에는 두가지 방법으로 접근할 수 있다.</p>\n<ul>\n<li>위키가 통합 로그인을 제공하도록 하고, 게시판이 위키를 통해 로그인하도록 하기</li>\n<li>통합 로그인을 제공하는 사이트를 만들고, 위키와 게시판이 통합 로그인 제공자를 통해 로그인하도록 하기</li>\n</ul>\n<p>각자 장단점이 있다. 위키에서 통합 로그인을 제공하도록 하는 첫번째 방법은 아래와 같은 장점이 있다.</p>\n<ul>\n<li>장점<ul>\n<li>기존에 있던 위키 이용자들의 인증 정보를 별다른 마이그레이션없이 그대로 쓸 수 있다.</li>\n<li>기존에 있던 위키 소스코드를 수정하기만 하면 된다.</li>\n</ul>\n</li>\n<li>단점<ul>\n<li>위키 소스코드를 수정하는 과정이 굉장히 짜증날 것 같다.</li>\n</ul>\n</li>\n</ul>\n<p>두번째 방법의 장단점은 다음과 같다.</p>\n<ul>\n<li>장점<ul>\n<li>개발하면서 공부를 더 많이 할 수 있다.</li>\n<li>위키와 함께 합쳐두는 것보다는 따로따로 두는 것이 왠지 보기 깔끔할 것 같다.</li>\n</ul>\n</li>\n<li>단점<ul>\n<li>기존 위키의 인증 정보를 새로운 통합 로그인 제공자로 옮겨야 한다.</li>\n<li>오픈나무도 통합 인증을 지원하도록 수정해야 했다.</li>\n</ul>\n</li>\n</ul>\n<p>나는 두번째 방법을 택했다. 그 이유로는 위키를 수정하는 과정이 번거로울 것 같아 차라리 새로 개발하는 게 더 좋을 것 같았고, 그 과정 속에서 공부가 더 많이 될 것 같았다. 인증 통합에 이용할 표준으로는 <a href=\"https://openid.net/specs/openid-connect-core-1_0.html\">OpenID Connect Core 1.0</a>을 채택했는데, SAML2.0같은 다른 표준들은 복잡해 보였기 때문이다. (일단 SAML2.0은 XML을 써서 귀찮지만 OpenID Connect Core 1.0은 OAuth2.0 기반이고 JSON을 쓴다.)</p>\n<h2 id=\"프로토타이핑\">프로토타이핑</h2>\n<p>두번째 방법을 택한 나는 일단 최단기간 안에 개발하기 위해 내게 익숙했던 언어와 프레임워크를 택했다. <a href=\"https://www.typescriptlang.org/\">TypeScript</a> 언어와 <a href=\"https://github.com/koajs/koa\">koajs</a> 프레임워크를 이용하고, 템플릿 엔진으로 <a href=\"https://github.com/koajs/koa\">pugjs</a> 라이브러리를 이용했다. OpenID Connect Core 1.0 개발은 <a href=\"https://github.com/panva/node-oidc-provider\">oidc-provider</a> 라이브러리를 이용했다.</p>\n<p>근데 빠르게 개발한 것이라 그런가 문제가 있었다. 먼저 소스코드가 좀 많이 더러웠고, oidc-provider 라이브러리가 생각 이상으로 무거웠다. oidc-provider가 생성하는 세션과 홈페이지 자체적인 세션이 따로따로 노는 것도 약간 마음에 안 들었다.</p>\n<p>그래도 일단 사이트를 만들긴 했으니 만든 사이트를 사용하고, 나중에 기회가 되면 사이트를 제대로 다시 만들기로 마음먹었다.</p>\n<h2 id=\"리빌딩\">리빌딩</h2>\n<p>2020년 연말에 여유가 남아 사이트 재개발을 하기 시작했다. TypeScript를 이용하되 지난 번과 달리 프론트엔드랑 백엔드를 분리하기로 마음먹었다. 프로토타이핑때 백엔드랑 프론트엔드를 합친 &quot;전통적인 방식&quot;으로 개발했더니 소스코드가 영 보기 좀 그랬다.</p>\n<p>그러려면 프론트엔드랑 백엔드 사이에 통신하는 API 스펙이 필요하다. 단순하게는 JSON 기반의 REST API를 이용하는 방법이 있다. 근데 이런 방식은 경험상 개발하다가도 스스로 API 스펙을 헷갈리기 쉽고, 문서화하기가 굉장히 귀찮았다.</p>\n<p>그래서 어떻게 할까 생각하는데 문득 <a href=\"https://www.oss.kr/notice/show/18f215a2-a650-4c46-aaab-b4cf7d41484e?page=2\">2020 오픈소스 컨트리뷰톤</a>에서 참가했던 <a href=\"https://github.com/dooboolab/hackatalk\">HackaTalk</a> 프로젝트가 떠올랐다. HackaTalk의 서버 기술스택은 <a href=\"https://www.prisma.io\">Prisma</a>-<a href=\"https://nexusjs.org/\">GraphQL Nexus</a>로 이루어진 <a href=\"https://graphql.org/\">GraphQL</a> 기반의 기술스택이다. Prisma는 GraphQL 개발시에 쓰면 편한 ORM이고, GraphQL Nexus는 GraphQL Schema를 작성할 때 쓰는 Code-First 철학의 라이브러리이다. GraphQL Nexus를 쓰면 Nexus에서 TypeScript Type Definition 파일을 자동으로 생성해줘 코딩할 때 인텔리센스와 TypeScript 컴파일러의 도움을 받을 수 있다.</p>\n<p>이런 기술스택을 쓰면 괜찮겠다는 생각이 들어서, 백엔드는 Prisma와 GraphQL Nexus 기반에 <a href=\"https://github.com/prisma-labs/graphql-yoga\">GraphQL Yoga</a>를 이용해 만들기로 했다. 프론트엔드는 <a href=\"https://ko.nuxtjs.org/\">Nuxt.js</a>를 이용하고, GraphQL 요청은 <a href=\"https://www.npmjs.com/package/@nuxtjs/apollo\">@nuxtjs/apollo</a>를 이용했다.</p>\n<p>또한 이번 개발때는 oidc-provider와 같은 라이브러리를 이용하지 않고 OAuth2와 OpenID Connect Core 부분을 직접 개발하기로 마음먹었다.</p>\n<h3 id=\"oauth2\">OAuth2?</h3>\n<p><a href=\"https://tools.ietf.org/html/rfc6749\">OAuth2 (RFC6749)</a>란 리소스 소유자(주로 사용자)와 리소스 서버(주로 API 제공자), 리소스를 이용하고자 하는 HTTP 서비스(이하 클라이언트, 주로 서드파티) 간의 상호작용을 정의한 표준이다. 정보통신표준화위원회 <a href=\"http://committee.tta.or.kr/data/standard_view.jsp?order=t.standard_no&amp;by=asc&amp;pk_num=TTAE.IF-RFC6749&amp;commit_code=PG504\">RFC6749 번역본</a>의 한글 내용요약을 인용하면 다음과 같다.</p>\n<blockquote>\n<p>공개 인증 2.0 프레임워크는 리소스 소유자를 대신하여 리소스 소유자와 HTTP 서비스간에 승인된 상호작용에 의하거나 또는 그 자신을 대신하여 얻은 접근권한을 제삼의 응용에게 제삼의 응용에게 허여하여, HTTP 서비스에 대한 제한적 접근을 획득하도록 제공을 한다. 본 표준은 공개 인증 1.0에 기술된 프로토콜을 대신한다.</p>\n<p>-- 출처 : <a href=\"http://committee.tta.or.kr/data/standard_view.jsp?order=t.standard_no&amp;by=asc&amp;pk_num=TTAE.IF-RFC6749&amp;commit_code=PG504\">TTAE.IF-RFC6749</a></p>\n</blockquote>\n<p>OAuth2는 거의 모든 웹 서비스에서 API 인증 방식으로 쓰이는 범용적인 표준이다. OAuth2가 없을 적에는 클아이너트가 리소스 소유자(주로 사용자)의 접근이 제한된 리소스(예시를 들자면 이메일 주소 같은 것들)에 지속적으로 접근하려면 리소스 소유자의 자격증명(credentials, 주로 비밀번호)을 바람직하지 않은 방법(예시: 평문)으로 저장해야 하는 문제점이 있었다. 또한 클라이언트가 비밀번호를 평문으로 저장하는 경우, 추후 접근 허가를 철회하거나 서드파티를 통제하기도 어렵다는 문제점도 있었다.</p>\n<p>OAuth2는 이러한 문제점을 해결하기 위해 <code>Access Token(엑세스 토큰)</code>이란 개념을 도입한다. 액세스 토큰은 클라이언트가 접근이 제한된 리소스를 취득하기 위해 사용하는 자격증명으로, 토큰 그 자체로는 어떠한 의미도 지니지 않는다. 이 액세스 토큰은 OAuth2에서 정의하는 여러가지 방식에 따라 취득할 수 있는데, 리소스 소유자가 인증을 담당하는 Authorization 서버(혹은 리소스 서버, Authorization 서버와 리소스 서버는 동일할 수 있다.)에 직접 인증하는 방식이 거의 대부분이기에 서드파티에 자격증명을 줄 필요가 없다는 장점이 있다.</p>\n<h4 id=\"authorization-code-grant\">Authorization Code Grant</h4>\n<p><code>Authorization Code Grant</code>는 클라이언트가 Access Token을 얻기 위한 방법 중 하나이다. 아래 그림은 RFC6749 Section 4.1의 Figure 3을 한국어로 옮긴 그림이다.</p>\n<p><a href=\"https://tools.ietf.org/html/rfc6749#section-4.1\"><img src=\"/img/rfc6749_section4.1.1_fig3.svg\" alt=\"RFC6749 Section 4.1 Figure 3: Authorization Code Flow 한국어 번역\"></a></p>\n<p>그림의 설명하자면 다음과 같다. 먼저 클라이언트가 User-Agent(웹브라우저)를 클라이언트 식별자와 리다이렉션 주소가 담긴 Authorization Request 주소로 리다이렉트시키면(그림에서 (A) 단계), Authorization 서버에서는 사용자에게 인증을 요구한다(그림에서 (B) 단계). 사용자가 인증을 완료하면 Authorization 서버는 리다이렉트 주소에 Authorization Code를 <code>code</code> 매개변수로 추가해 User-Agent를 그 주소로 리다이렉트시킨다. (그림에서 (C) 단계) 그러면 클라이언트는 <code>code</code> 매개변수로 Authorization Code를 얻게 되고, 이 코드를 Authorization 서버에 보내 엑세스 토큰과 교환할 것을 요청한다. (그림에서 (D) 단계) 그러면 Authorization 서버는 Authorization Code를 확인하고 그 코드가 올바르다면 액세스 토큰을 발급해 클라이언트에게 제공하게 된다. (그림에서 (E) 단계)</p>\n<p>쉽게 말해, Authorization 서버가 사용자를 확인하면, Authorziation 서버는 클라이언트에게 Authorization Code를 주고, 클라이언트는 그 Authorization Code를 엑세스 토큰과 교환하는 방식이다.</p>\n<p>Authorization Code Grant는, 코드를 주지 않고 바로 엑세스 토큰을 주는 Implicit Grant와 달리, 리소스 소유자에게 엑세스 토큰을 노출하지 않는다는 장점이 있다. 다만 Authorization Code Grant는 클라이언트 인증이 요구되므로 JavaScript 등으로 클라이언트 사이드에서 작동하는 웹 어플리케이션보다는 서버(백엔드)가 있는 웹 사이트에 적합하다.</p>\n<h4 id=\"oauth2-인증의-구현\">OAuth2 인증의 구현</h4>\n<p>OAuth2 인증을 구현하기 위해 백엔드단에서 GraphQL 서버말고 HTTP 서버도 열어야 할 필요가 있다. 따라서 HTTP 서버를 열고 GraphQL 서버와 다른 포트에서 요청을 받도록 수정했다. (어처피 리버스 프록시 쓰면 포트 달라도 서비스하는 데엔 상관없다.)</p>\n<p>OAuth2 인증을 구현하려면, 외적으로는 인증을 하는 Endpoint와(이하 <code>인증 Endpoint</code>, 보통 <code>/authorize</code>와 같은 이름으로 구현함) 토큰을 교환하거나 발급하는 Endpoint(<code>/token</code>과 같은 이름을 구현함.) 두가지를 구현해야 한다.</p>\n<p>그런데 앞서 말했듯 프론트엔드와 백엔드가 분리되어 있다. 그러니 당연히 사용자의 인증정보(세션)도 프론트엔드단에서 관리하고 있으므로, 백엔드에서 프론트엔드를 거치고 않고 직접 받는 HTTP 서비스에서는 프론트엔드의 인증 정보를 바로 편하게 받을 수 없었다. (물론 가능은 하겠지만... &#39;굳이?&#39;라는 생각이 들었다. 그리고 그렇게 하면 코드가 생각보다 복잡해질 것 같았다.)\n그래서, oidc-provider 라이브러리가 <code>/interaction/[Some ID Here]</code>와 같이 리다이렉트하던 것에서 힌트를 받아 다음과 같이 구현했다.</p>\n<ol>\n<li>인증 Endpoint에 요청이 들어오면</li>\n<li>요청받은 내용을 전부 DB에 저장하고 그 DB 데이터의 Primary ID를 받아서</li>\n<li>프론트엔드가 담당하는 페이지로 ID와 같이 전송한다. (예시 : <code>/authorize_oauth2/[Some ID Here]</code>)</li>\n<li>그러면 프론트엔드에서 GraphQL 서버로의 요청을 통해 인증 요청을 처리한다.</li>\n</ol>\n<p>즉, HTTP API 서버의 인증 Endpoint는 요청받은 매개변수를 DB에 저장해 프론트엔드로 넘기는 역할만 하고, 실질적인 인증 처리는 프론트엔드와 GraphQL 서버단에서 이루어지도록 하는 것이다. 이렇게 함으로써 인증 Endpoint와 관련된 문제를 간단히 해결했다.</p>\n<h3 id=\"openid-connect\">OpenID Connect</h3>\n<p>이제 OpenID Connect를 구현해야 한다. OpenID Connect는 OAuth2 프로토콜 위에서 동작하는 표준으로, 사용자에 대한 간단한 정보를 얻고 사용자를 인증할 수 있도록 하는 간단한 레이어 표준이다. <code>openid</code> scope를 포함한 OAuth2 Authorization Request를 보냄으로써 시작하며, <a href=\"http://tools.ietf.org/html/draft-ietf-oauth-json-web-token\">JSON Web Token</a> 표준을 이용해 사용자를 인증해주는 ID Token을 발급한다.</p>\n<p>쉽게 말하면, 내가 Authorization Request를 보낼때 scope에 <code>openid</code>도 포함시키면, 서버에서 액세스 토큰 줄때 ID 토큰도 같이 주고, 이 액세스 토큰과 함께 <code>userinfo</code> Endpoint(후술)에 접근하면 사용자에 관한 정보(닉네임이라던지)도 주는 것에 관한 표준이라는 것이다.</p>\n<p>OpenID Connect를 사용하는 목적과 범위을 통합 인증으로만 극한한다면, <a href=\"https://openid.net/specs/openid-connect-core-1_0.html\">OpenID Connect Core</a> 표준의 일부분(<a href=\"https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth\">Section 3.1</a>, <a href=\"https://openid.net/specs/openid-connect-core-1_0.html#UserInfo\">Section 5.3</a>, <a href=\"https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication\">Section 9</a>, 갱신 토큰도 지원한다면 <a href=\"https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokens\">Section 12</a>도)과 <a href=\"https://openid.net/specs/openid-connect-rpinitiated-1_0.html\">OpenID Connect RP-Initiated Logout 1.0 - draft 01</a>만 구현해도 실사용에는 크게 무리가 없다. <a href=\"https://openid.net/specs/openid-connect-discovery-1_0.html\">OpenID Connect Discovery</a>에서 <a href=\"https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig\">Section 4 (Obtaining OpenID Provider Configuration Information)</a>도 구현하면 서드파티에서 통합 인증을 설정할 때 편하다. <a href=\"https://openid.net/specs/openid-connect-registration-1_0.html\">OpenID Connect Dynamic Discovery</a>는 전체적인 서비스 운영을 폐쇄적으로 할 생각이라면 굳이 구현할 필요가 없다.</p>\n<p>OpenID Connect Core는 다음과 같이 기존 OAuth2 구현을 확장하고 추가적인 <code>userinfo</code> Endpoint와 jwks를 제공하는 Endpoint를 만들어 구현할 수 있다.</p>\n<ol>\n<li>Authorization request 처리시 OpenID Connect Core 스펙에서 정의하는 prompt 매개변수, id_token_hint 매개변수, login_hint 매개변수를 처리하도록 확장한다.<ul>\n<li>prompt 매개변수는 간단하게 prompt=none인데 인증이 안 된 경우라면 무조건 <code>login_required</code> 오류를 반환하도록 구현하면 된다.</li>\n<li>id_token_hint나 login_hint는 id_token_hint와 login_hint에서 가리키는 사용자와 현재 로그인된 사용자가 다르다면 오류를 반환하도록 구현하면 된다.</li>\n<li>state가 있다면 리다이렉트할 때 쿼리 매개변수로 state를 넣어 리다이렉트한다.</li>\n</ul>\n</li>\n<li>토큰 Endpoint에서 엑세스 토큰을 발급할때 <code>openid</code> scope가 포함됐다면 ID 토큰도 함께 발급한다.<ul>\n<li>ID Token 발급시에는 특별한 경우가 아니라면 RS256 알고리즘으로 서명해야 한다. (<a href=\"https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\">OpenID Connect Core 1.0 Section 3.1.3.7. ID Token Validation 문단</a>에서 <code>default of RS256</code>라는 표현으로 명시하고 있음.)</li>\n<li>nonce가 있다면 id_token 발급할 때 nonce를 포함한다.</li>\n<li>state가 있다면 리다이렉트할때 쿼리 매개변수로 state를 넣어 리다이렉트한다.</li>\n</ul>\n</li>\n<li><code>userinfo</code> endpoint는 액세스 토큰의 scope에 따라 적절한 claim(<code>name</code>이나 <code>nickname</code> 같은 것들)들을 JSON 객체로 반환하도록 구현한다.</li>\n<li>jwks를 반환하는 endpoint는 말 그대로 ID Token 발급시 사용하는 jwks의 공개키들을 jwks 형식으로 반환하도록 구현한다.</li>\n</ol>\n<p>RP-Initiated Logout도 구현하기로 했다면, 다음과 같은 행동을 하는 HTTP Endpoint를 하나 더 구현해야 된다.</p>\n<ol>\n<li>id_token_hint 있으면 검증하고</li>\n<li>사용자를 로그아웃시킨 뒤</li>\n<li>id_token_hint와 post_logout_redirect_uri가 <strong>동시에</strong> 주어졌다면 post_logout_redirect_uri가 허가된 주소인지 검증하고, 만약 그렇다면 post_logout_redirect_uri로 리다이렉트한다.<ul>\n<li><strong>동시에</strong>가 중요하다. id_token_hint없이 post_logout_redirect_uri가 주어졌다면 무효한 요청이다.</li>\n<li>요청 매개변수로 state가 주어졌다면 state도 같이 쿼리 매개변수로 붙어서 리다이렉트한다.</li>\n</ul>\n</li>\n</ol>\n<p>RP-Initiated Logout 표준은 OP에서 로그아웃하는 것에 대한 표준이므로, 다른 RP들에 관해서는 언급하고 있지 않다. OP에서 로그아웃할 때 다른 RP들도 로그아웃하는 것을 원한다면 <a href=\"https://openid.net/specs/openid-connect-session-1_0.html\">OpenID Connect Session Management 1.0</a>이나 <a href=\"https://openid.net/specs/openid-connect-backchannel-1_0.html\">OpenID Connect Back-Channel Logout</a>, <a href=\"https://openid.net/specs/openid-connect-frontchannel-1_0.html\">OpenID Connect Front-Channel Logout</a>등의 Draft들 중 마음에 드는 것을 골라 구현하거나, 아니면 직접 자신의 방법으로 구현해야 한다.</p>\n<p>추가적으로, OpenID Connect Discovery 표준도 구현하기로 했다면, 그냥 적절한 OpenID Provider Configuration Information을 반환하는 <code>/.well-known/openid-configuration</code> HTTP Endpoint를 구현하면 된다. 시간이 남으면 표준에서 제시하는 Webfinger 관련 API도 구현해도 되지만, 사이트 관리를 폐쇄적으로 할 계획이라면 굳이 그럴 필요가 없다.</p>\n<h2 id=\"구현-끝\">구현 끝</h2>\n<p>위와 같이 구현하면 간단한 SSO 기능을 제공하는 사이트를 만들 수 있다. 이렇게 SSO를 제공하는 사이트에 회원관리 기능과 가입신청 받는 기능도 덧붙여서 간단한 동아리 회원관리 사이트를 만들었다.</p>\n<p>Nextjs로 SPA를 구현해서 그런가 깔끔하더라. 수정해야 할 게 지금도 좀 있긴 하지만 예전보단 보기 좋아졌다.</p>\n<h2 id=\"그래서-게시판은\">그래서 게시판은?</h2>\n<p>게을려서 아직 안 만들었다. 언젠가 만들지 않을까?\n...농담이고, 사실 만들려고 했다가 &#39;단체채팅방이 있는데 굳이 만들어야 할까?&#39;라는 생각이 들어 만들지 않았다. 그래도 이 홈페이지를 개발하면서 많은 도움이 됐다.</p>\n<p>끝</p>\n"},"nextPost":{"name":"retrospective_of_2021","metadata":{"title":"2021년의 회고","subtitle":"코로나와 군대","author":"LiteHell","date":"2022-02-12T12:16:55.084Z","category":"Life","tags":["Retrospective"],"last_modified_at":"2022-11-19T17:07:57.764Z"},"rendered":"<h1 id=\"들어가는-말\">들어가는 말</h1>\n<p>블로그를 만들었는데 쓸거리가 없다. 하기야 군대에서 스마트폰만 만지막거리며 놀고 있으니 그럴 것이다. 블로그를 썩히고 있는 것이 눈에 보여서 뭐라도 쓸까 생각하다가 회고를 안 한 것이 떠올라 이제서야 쓰려한다.</p>\n<p>돌이켜보면 애매한 타이밍이긴 하다. 2월이니 연초는 맞긴 맞는데, 회고를 쓸 타이밍은 아닌 것 같은 타이밍. 보통 회고는 1월 초에 쓰는 게 무언의 관례니까. 뭐 어떻겠는가, 타이밍이 어쨌든간에 내가 쓰고 싶을 때 쓰면 되는 것이다.</p>\n<p>작년을 간략하게 요약하면 코로나와 군대의 해였다. 코로나때문에 집에서만 지내다가 군대에 들어간 순간 시간이 사라졌다. 올해에는 코로나 팬데믹이 끝나기를 소망하며, 지금부터 회고를 시작한다.</p>\n<h1 id=\"마지막-불꽃-13월\">마지막 불꽃 (1~3월)</h1>\n<p>2021년 3월에 입대가 결정됐다. 3월에 군대가서 전역하면 내년 12월, 복학하기에 큰 무리없는 시기이다. 이를 위해 자격증을 따고 헌혈을 하고 학교증명서를 뗐다. 군대도 스펙을 준비해야 한다니, 우리나라 사람들은 줄세우기를 참 좋아하는 것 같다. 군대와 관련된 이야기를 하면 무심코 어릴 적의 기억이 떠오른다, 한때 통일돼서 군대 안 가기를 기도하던 어린 시절이... 나에게도 그런 순수한 시절이 있었으매, 세월은 느리게 가는 듯하면서도 빠르게 흘러감을 상기한다.</p>\n<p>이제 영장의 주사위는 굴러졌으니, 3월에 군대를 가기 전에 열심히 코딩하고 친구들 만나고 놀고 먹고 다니기로 결심했다. 훈련소에 들어가면 다시는 못 만날 친구들이오, 하기 어려울 코딩일텐데, 지금 최대한으로 해야 후회하지 않을테니까.</p>\n<p>따라서 코딩을 적극적으로 하기 시작했다. 교내 커뮤니티 서비스인 <a href=\"https://eodiro.com\">어디로</a>에 <a href=\"https://github.com/payw-org/eodiro-server/pull/68\">PR</a>도 내고, 지금 보고 있는 <a href=\"https://github.com/litehell/litehell-blog\">블로그</a>도 이때 완성했다. 현재 <a href=\"https://caumd.club\">만화두레 홈페이지</a>을 만드는 데 쓰인 <a href=\"https://github.com/ManhwaDurae/fullcards\">fullcards 프로젝트</a>도 1월부터 3월까지 firebase를 배우며 만들었다. (<a href=\"https://blog.litehell.info/post/first_use_of_firebase\">관련 블로그 글</a>) 관계형 DB 스카마를 설계하기가 귀찮아서 firebase를 골랐는데, 빠르게 개발하는 데엔 나쁘지 않은 선택지이다. 지금 잘 굴러가는 만화두레 회원관리 사이트(<a href=\"https://github.com/ManhwaDurae/manduid-backend\">백엔드</a>, <a href=\"https://github.com/ManhwaDurae/manduid-frontend\">프론트엔드</a>)도 이때 많은 버그를 수정하고 여러 기능들을 개선했다.</p>\n<p>그리고 2~3월동안 내 서버에서 돌아가던 모든 것들을 도커화했다. 여러 노드를 유동적으로 만들어야 하거나 로드밸런싱이 필요한 규모의 서비스는 없었기에, 단순하게 docker-compose를 이용해 서버내 서비스들을 각각 하나의 컨테이너들로 도커화했다. 그 전에는 <a href=\"https://pm2.keymetrics.io/\">pm2</a>를 썼는데, Docker를 쓰니 확실히 편하긴 했다.</p>\n<h1 id=\"군대\">군대</h1>\n<p>3월에 진주로 내려와 입대했다. 코로나19 때문에 입영식같은 행사는 없었다. 차에서 내려 부모님과 헤어진 후 조교들의 지시에 따라 PCR검사를 받고 터벅터벅 생활관으로 걸어갔다. 그 걸어가는 길의 첫 인상은 주머니에 손 넣지 말고 걸으라던 조교의 큰 목소리였다.</p>\n<p>기초군사훈련을 마치고 특기교육을 받았다. 특기학교에서의 큰 변화는 자판기와 기가지니, 그리고 간이 BX가 있다는 점이었다. 수업이 끝나고 쉬는 시간이면 기가지니로 아이돌 노래를 귀에 못이 박히도록 듣고, 간이 BX에서 주전부리를 사 먹으며 특기교육을 받았다. 자판기는 내 심심한 입을 달래주는 좋은 절친이었다. 특기교육은 전공자 기준으로 그리 어려운 내용이 없기에 성적도 무난하게 받을 수 있었다.</p>\n<p>자대에서는 코딩을 쉬고 독서와 그림 그리기를 하고 있다. 코딩이야 어처피 전역하면 질리도록 할테니 부대 내에 있을때는 쉬고 싶었다. 아, 군내에서 해커톤도 열어서 신기했다.</p>\n<h1 id=\"마무리\">마무리</h1>\n<p>회고를 하려했는데 딱히 할 게 없다. 아무래도 코로나와 군대때문에 그런 것 같다. 어서빨리 전역해서 재밌고 즐거운 것들을 하고 싶다.</p>\n"}},"__N_SSG":true}