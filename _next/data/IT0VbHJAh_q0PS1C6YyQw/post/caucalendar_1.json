{"pageProps":{"article":{"metadata":{"title":"학사일정 ICS 서비스 개발기 (上)","subtitle":"Javascript랑 함께 Docker로","author":"LiteHell","date":"2024-09-15T13:06:50.914Z","category":"Dev","series":"puang_network","seriesName":"학사일정/RSS/시간표 미리보기 서비스 개발기"},"rendered":"<h1 id=\"들어가는-글\">들어가는 글</h1>\n<p>나는 캘린더 앱을 적극적으로 활용한다. 시간이나 약속을 머릿속으로만 관리하면 잘 잊어버리기 때문에 캘린더 앱을 적극적으로 활용하고 있다.</p>\n<p>그렇게 캘린더 앱을 적극적으로 쓰다가 대학교에 입학했다. 시험기간이나 수강정정기간 같은 것도 캘린더 앱에 뜨면 좋겠는데 이걸 직접 추가하는 건 귀찮았다. 그래서 <a href=\"https://www.cau.ac.kr/cms/FR_CON/index.do?MENU_ID=590\">중앙대학교 학사일정 페이지</a>를 크롤링하는 어플리케이션을 작성했다. 그리고 캘린더 앱과 내 어플리케이션을 연동하는 데에는 iCalendar 파일 포맷을 이용했다.</p>\n<h2 id=\"icalendar\">iCalendar</h2>\n<p><a href=\"https://calendar.google.com\">Google Calendar</a>나 <a href=\"https://outlook.com\">MS Outlook</a>, 혹은 필자가 이용하는 <a href=\"https://www.fastmail.com\">FastMail</a>에서는 캘린더 기능을 제공한다. 이 캘린더 서비스들은 기본적으로 특정한 iCalendar 주소를 구독하는 기능을 지원한다. 즉, 다시 말해 필자가 구글 캘린더나 아웃룩에 iCalendar 파일 주소를 추가하면, 구글 캘린더나 아웃룩 서버가 주기적으로 iCalendar 주소에 접속해 동기화한다.</p>\n<p>iCalendar 파일은 다음과 같은 형식으로 되어있다.</p>\n<pre><code>BEGIN:VCALENDAR\nVERSION:2.0\nTIMEZONE-ID:Asia/Seoul\nX-WR-TIMEZONE:Asia/Seoul\nX-WR-CALNAME:중앙대학교 학사일정\nX-WR-CALDESC:calendar.puang.network에서 제공하는 중앙대학교 학사일정\nCALSCALE:GREGORIAN\nPRODID:adamgibbons/ics\nMETHOD:PUBLISH\nX-PUBLISHED-TTL:PT1H\nBEGIN:VTIMEZONE\nTZID:Asia/Seoul\nTZURL:http://tzurl.org/zoneinfo-outlook/Asia/Seoul\nX-LIC-LOCATION:Asia/Seoul\nBEGIN:STANDARD\nTZOFFSETFROM:+0900\nTZOFFSETTO:+0900\nTZNAME:KST\nDTSTART:19700101T000000\nEND:STANDARD\nEND:VTIMEZONE\nBEGIN:VEVENT\nUID:552361268d864ef42fff1bee5d295e073f7ab2b2@calendar.puang.network\nSUMMARY:신정(공휴일)\nDTSTAMP:20240825T081930Z\nDTSTART;TZID=Asia/Seoul;VALUE=DATE:20220101\nEND:VEVENT\nBEGIN:VEVENT\nUID:eb57cfcaf7345c4ad83d1e7537dd81016db2d8a7@calendar.puang.network\nSUMMARY:2022년 1학기 재입학 원서접수\nDTSTAMP:20240825T081930Z\nDTSTART;TZID=Asia/Seoul;VALUE=DATE:20220103\nDTEND;TZID=Asia/Seoul;VALUE=DATE:20220107\nEND:VEVENT\nEND:VCALENDAR</code></pre>\n<p>위와 같은 식으로 iCalendar 아이템(<code>VCALENDAR</code>) 속에 여러 일정(<code>VEVENT</code>)들이 나열되어 있다. iCalendar 형식은 할일(<code>VTODO</code>)이나 일기(<code>VJOURNAL</code>)도 지원하지만 이 글에서는 다루지 않는다.</p>\n<h2 id=\"koajs를-이용한-첫-버전\"><a href=\"https://koajs.com/\">Koa.js</a>를 이용한 첫 버전</h2>\n<p>첫 버전은 <a href=\"https://koajs.com/\">Koa 프레임워크</a>를 이용하여 간단하게 작성했다. 원래 이전에는 <a href=\"https://expressjs.com/\">express</a>를 썼었는데, express는 <code>async</code> 함수 핸들러가 바로 지원되지 않아서 약간 귀찮다는 단점이 있었기에 Koa 프레임워크를 이용했다.</p>\n<p>이 프로그램에서 중요한 것은 iCalendar 파일을 제공하는 것이다. 따라서 그 외의 요소는 모두 부수적인 것이다. 그렇기에 프론트엔드는 다음과 같이 디자인이 극단적으로 되어있어도 상관없었다. (사진은 첫 커밋 버전의 메인 페이지이다.)</p>\n<p><img src=\"/img/puang_network/caucalendar_first_commit_html.png\" alt=\"첫 커밋 버전의 caucalendar.online 프로젝트 프론트엔드\"></p>\n<p>다만 그래도 위처럼 만드는 건 좀 심하니 <a href=\"https://bulma.io\">bulma CSS 프레임워크</a>를 이용해 아래와 같이 간단히 꾸몄다.</p>\n<p><img src=\"/img/puang_network/caucalendar_bulma_frontend.png\" alt=\"bulma 프레임워크를 이용한 caucalendar.online 프로젝트 프론트엔드\"></p>\n<p>이때가 2019년 5~6월쯤이였다. 이때의 구조도는 다음과 같다.</p>\n<p><img src=\"/img/puang_network/caucalendar_vps_nodejs.png\" alt=\"서비스 구조도\"></p>\n<p>당시 가상서버에서는 여러 웹서비스가 구동되고 있었기에, Host를 확인하여 알맞은 웹서비스로 트래픽을 전달해야 했다. 따라서 Nginx로 리버스 프록시가 동작하고 있었다.</p>\n<p>위 사진에서 <a href=\"https://pm2.io\">PM2</a>는 프로세스가 꺼지면 다시 켜주는 역할을 한다. <a href=\"https://github.com/librewiki/liberty-engine\">리브레위키의 리버티엔진</a>에서 쓰길래 써봤다.</p>\n<h2 id=\"크롤링-스크립트-분리\">크롤링 스크립트 분리</h2>\n<p>초기에는 크롤링을 분리하기 귀찮아서, 그냥 요청이 들어올 때마다 학교 홈페이지에 접속해 학사일정 iCalendar 파일(이하 &quot;ics 파일&quot;)을 제공했다. 그랬더니 어느순간 학교에서 서버 ip를 차단했다. 이게 2019년 11월 쯤의 일이였다.</p>\n<p>그래서 크롤링하는 코드를 별도의 파일로 분리하고, crontab을 이용해 크롤링 스크립트가 주기적으로 실행되게 했다. 크롤링된 데이터는 <a href=\"https://sequelize.org/\">Sequelize</a> ORM을 이용해 저장했다.</p>\n<h2 id=\"github-action\">GitHub Action</h2>\n<p>학사일정 서비스에 버그가 생겼다고 캘린더 앱에서 잘 보이던 일정이 갑자기 사라지진 않는다. 그래서 동작에 이상이 생겨도 기존에 쓰던 사람들은 티가 잘 안난다.</p>\n<p>그래서 동작이 정상적으로 이루어지는 지 주기적으로 확인하기 위해 다음과 같이 GitHub Action을 추가했다.\n푸시나 커밋시가 아닌 특정 주기에 따라 반복되는 GitHub CI로 테스트가 주기적으로 이루어지도록 했다.</p>\n<p>따라서 이를 통해 학교 홈페이지의 갑작스런 디자인/API 변경에도 대응할 수 있었다. </p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">test</span>\n\n<span class=\"hljs-attr\">on:</span>\n  <span class=\"hljs-attr\">schedule:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">cron:</span> <span class=\"hljs-string\">&#x27;0 19 * * *&#x27;</span>\n  <span class=\"hljs-attr\">push:</span>\n\n<span class=\"hljs-attr\">jobs:</span>\n  <span class=\"hljs-attr\">build:</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>\n    <span class=\"hljs-attr\">steps:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">docker</span> <span class=\"hljs-string\">build</span> <span class=\"hljs-string\">--target</span> <span class=\"hljs-string\">test</span> <span class=\"hljs-string\">.</span></code></pre>\n<p>푸시나 커밋시가 아닌 cron으로 GitHub CI를 추가하여 학교 홈페이지의 갑작스런 디자인/API 변경에도 대응할 수 있도록 했다.</p>\n<h2 id=\"도커라이징\">도커라이징</h2>\n<p>개인서버에서 돌아가던 서비스들을 다 도커 컨테이너에 감싸는 작업을 했었다. 그때 학사일정 ics 서비스도 도커 컨테이너로 감쌌다. crontab을 이용해 따로 돌아가던 크롤링 스크립트는 어플리케이션에 다시 집어넣어서, 어플리케이션 실행시 크롤링이 자동으로 주기적으로 실행되도록 수정했다. Docker에서 crontab을 쓰려면 약간 귀찮기 때문이다.</p>\n<p>처음에는 <code>node:14</code> 도커 이미지를 기반으로 썼는데 값싼 가상서버에서 쓰기에는 디스크를 너무 많이 차지했다. 그래서 나중에 Alpine Linux 기반 도커를 기반으로 바꿨다. Alpine Linux 기반 이미지를 쓰니 디스크 소비량을 줄일 수 있었다. 이때가 2021년 2~3월인가 그랬을 것이다.</p>\n<h2 id=\"go-언어로의-재작성\">Go 언어로의 재작성</h2>\n<p>그렇게 Javascript로 작성해서 잘 쓰다가 문득 이런 생각이 들었다. &#39;Go를 쓰면 더 빠르지 않을까?&#39; Javascript는 인터프리터 언어이고, Go는 컴파일 언어이니, 알고리즘의 효율성이 유사하다는 가정하에 Go가 더 빠를 수도 있지 않을까란 생각이 들었다. 물론 Go 언어를 한 번 써보고 싶은 생각도 없진 않았다.</p>\n<p>그래서 Go 언어로 학사일정 서비스를 재작성했다. 크롤러는 다음과 같이 고루틴을 이용하여 비동기적으로 동시에 구동되도록 했다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;time&quot;</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">crawlWorker</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">for</span> {\n        time.Sleep(time.Hour * <span class=\"hljs-number\">1</span>)\n        fetchAllYears()\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">setupCrawller</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">go</span> crawlWorker()\n}</code></pre>\n<h2 id=\"docker를-이용한-테스팅\">Docker를 이용한 테스팅</h2>\n<p>DigiCert CA 인증서와 관련된 문제가 있어 해당 CA 인증서를 추가하여 문제를 해결했었다. 물론 HTTP 요청시 인증서 오류를 모두 무시하도록 하는 방법도 있지만, 그 방법은 보안이 취약해지기에 채택하지 않았다.</p>\n<p>다만 이렇게 CA 인증서를 추가하는 식으로 해결할 시에는 <code>go test -v</code> 명령어만으로 테스트를 할 수 없다는 문제점이 있었다. 그래서 <a href=\"/post/docker_for_testing\">Docker를 테스트에도 활용할 수 있도록 다음과 같이 Dockerfile을 수정했다.</a></p>\n<pre><code class=\"hljs language-dockerfile\"><span class=\"hljs-keyword\">FROM</span> golang:alpine AS base\n\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n\n<span class=\"hljs-comment\"># To avoid tls error from swedu.cau.ac.kr</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> digicert-ca.pem /usr/<span class=\"hljs-built_in\">local</span>/share/ca-certificates/digicert-ca.crt</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> cat /usr/<span class=\"hljs-built_in\">local</span>/share/ca-certificates/digicert-ca.crt &gt;&gt; /etc/ssl/certs/ca-certificates.crt</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> go.mod go.sum ./</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> go mod download &amp;&amp; go mod verify</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> static ./static</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> *.go ./</span>\n\n<span class=\"hljs-keyword\">FROM</span> base AS deployment\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> go build -v -o /app/app</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">&quot;/app/app&quot;</span>]</span>\n\n<span class=\"hljs-keyword\">FROM</span> base As test\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> go <span class=\"hljs-built_in\">test</span> -v ./...</span></code></pre>\n<h2 id=\"서버리스\">서버리스</h2>\n<p>위와 같이 만들어서 굴리다가 추후 AWS Lambda 함수를 이용한 서버리스로 재작성했다. 이에 대해선 다음 글에서 이어서 작성하도록 하겠다.</p>\n"},"articleId":"caucalendar_1","series":[{"title":"학사일정 ICS 서비스 개발기 (上)","articleId":"caucalendar_1"}],"seriesName":"학사일정/RSS/시간표 미리보기 서비스 개발기","previousPost":{"name":"bidrum_on_rust","metadata":{"title":"Rust와 SDL2","subtitle":"게임 개발에 Rust를 써보셨나요?","author":"LiteHell","date":"2024-08-11T14:35:24.968Z","category":"Dev","series":"bidrum","tags":["Game"]},"rendered":"<h1 id=\"들어가는-글\">들어가는 글</h1>\n<p><em>※ 참고: 이 시리즈의 글은 시간순 작성을 최대한 목표하고 있으나, 글의 짜임새나 가독성을 위해 미리시점이나 과거시점의 이야기가 섞이거나 순서가 일부 달라질 수 있습니다.</em></p>\n<p>내가 만들고 싶은 게임은 아케이드 리듬게임이였다. 마침 내 방에 라즈베리 파이(4B Rev 1.2)가 있어서, 라즈베리 파이로 게임을 구동하고 싶었다. Unity나 Unreal Engine으로 만든 게임이 라즈베리 파이 위에서 돌아갈까? 아마도 돌아가지 않을 것이다. 실제로 돌려본 적은 없지만 라즈베리 파이가 성능이 좋은 편은 아니니까.</p>\n<p>그래서 필자는 마침 <a href=\"https://www.rust-lang.org/\">Rust</a> 프로그래밍 언어를 한 번 써보고 싶은 생각도 있었기에, Rust로 직접 게임을 만들어보기로 결심했다. 게임 엔진을 쓰면 나중에 게임이 유명해졌을 때 라이선스비를 내야 한다는 것도 하나의 이유였다. (좀 과한 김칫국이긴 하지만...) 그래서 유니티니 언리얼이니 하는 게임 엔진을 쓰지 않고 Rust로 기초부터 쌓아올리기 시작했다.</p>\n<h1 id=\"sdl2를-이용한-게임-프로그래밍\">SDL2를 이용한 게임 프로그래밍</h1>\n<p>Rust에는 <a href=\"https://github.com/Rust-SDL2/rust-sdl2\">rust-sdl2</a>라는 라이브러리 바인딩이 있다. SDL2는 오디오, 키보드, 마우스, 그래픽, 조이스틱을 다를 수 있게 하는 크로스플랫폼 라이브러리이다. 즉, 그래픽이나 마우스 등에 대한 Direct3D/OpenGL 등의 운영체제/플랫폼 종속적인 API를 추상화하고 단일한 인터페이스로 통일하여 크로스 플랫폼으로 개발할 수 있게 하는 라이브러리이다.</p>\n<p>따라서 SDL2를 이용하면 Mac OS X/Windows/Linux에서 크로스플랫폼으로 실행할 수 있고, 라이브러리도 별로 무겁지 않다. 그래서 SDL2를 이용하게 됐다.</p>\n<h2 id=\"sdl2\">SDL2</h2>\n<p>SDL2는 rust-sdl 레포 내의 예제 코드를 보면서 따라하면 사용하기 쉽다. SDL2는 먼저 Window(창)을 만든 뒤, Window의 Canvas에 원하는 것을 그리고 렌더링하고 클리어하는 것을 반복한다. 이를 순서대로 나타내면 다음과 같다.</p>\n<blockquote>\n<p>(A) Window 생성 → (B) Window의 Canvas를 Clear한다 → (C) Canvas에 뭔가를 그린다. → (D) Window의 Canvas를 Present한다. → (E) 화면이 표시한다. → (F) B로 되돌아간다.</p>\n</blockquote>\n<p>학부 수준의 컴퓨터그래픽스 수업을 들었거나 OpenGL 프로그래밍을 조금이라도 맛보았다면 매우 이해하기 쉬울 것이다.</p>\n<p>SDL2는 키보드나 조이스틱 인식을 위한 EventPump 기능을 제공한다. 키보드 인풋이 들어오면 EventPump에 Event가 생성된다. 게임은 이 EventPump에 Event가 있는지 확인하여 만약 Event가 있다면 해당 Event의 데이터를 활용해 키보드 인풋을 처리할 수 있다. 게임 특성상 이 EventPump은 디버깅 용으로만 주로 이용됐다.</p>\n<h2 id=\"gamecommoncontext\">GameCommonContext</h2>\n<p>위에서 언급한 바에 같이 그래픽을 렌더링하기 위해서는 Canvas 객체에 대한 접근이 필요하다. 그래서 초기 게임 초기화시 Canvas와 Window, SDL Context 등을 담은 GameCommonContext 객체를 만들고 이를 함수간에 서로 주고받는 형태로 빠르게 게임을 구현했다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> kira::manager::AudioManager;\n<span class=\"hljs-keyword\">use</span> sdl2::{render::Canvas, EventPump, video::Window};\n\n<span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">GameCommonContext</span></span> {\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) coins: <span class=\"hljs-built_in\">u32</span>,\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) price: <span class=\"hljs-built_in\">u32</span>,\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) sdl_context: sdl2::Sdl,\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) audio_manager: AudioManager,\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) canvas: Canvas&lt;Window&gt;,\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) event_pump: EventPump,\n}</code></pre>\n<p>(속성은 나중에 게임이 개발되면 될 수록 더 늘어난다.)</p>\n<p>그리고 이는 추후 대규모 리팩토링으로 Rust의 특징을 온몸으로 깨닫는 계기가 됐다.... 나중에 소유권이랑 lifetime 문제가 미친 듯이 터져나와서 그거 씨름하느라 엄청 고생하게 됐다.</p>\n<h2 id=\"rust에서의-시리얼-통신\">Rust에서의 시리얼 통신</h2>\n<p>게임을 장구 하드웨어와 연동하기 위해서는 시리얼 통신이 필요하다.</p>\n<p>Arduino Leonardo 등 HID 에뮬레이션을 지원하는 보드가 있으면 장구 하드웨어에서 키보드 인풋을 주도록 할 수도 있다. 그런데 당장 내 방에 있는 게 Arduino UNO 호환보드(흔히 &quot;짭두이노&quot;라고 불리는 보드)밖에 없었다. 그래서 시리얼 통신으로 구현했다. 나중의 미래에 레오나르도 보드를 사서 키보드 인풋으로도 구현해보긴 했는데.... 딱따구리마냥 장구 채를 갖다대기만 해도 장구 채를 미친듯이 연타한 것마냥 동작하는 버그가 있어서 그냥 시리얼 통신을 계속 쓰게 됐다.</p>\n<p>Rust에서는 시리얼 통신을 어떻게 할까? 고맙게도 <a href=\"https://docs.rs/serialport/latest/serialport/\">serialport</a>라는 라이브러리가 있다. 이를 이용해 장구 하드웨어와의 시리얼 통신 코드를 작성했다. 그리고 장구 하드웨어로부터 인풋을 읽는 코드를 멀티쓰레딩으로 분리하고 <code>AtomicU8</code>을 이용하여 게임 쓰레드와 인풋 쓰레드 간에 장구 인풋 상태를 서로 공유했다.</p>\n<p>왜 뜬끔없이 <code>AtomicU8</code>이냐? 장구 컨트롤러의 상태를 나타내는 데에는 4개의 비트만 있으면 충분하다. 그래서 컨트롤러는 1바이트의 데이터를 무한히 연속적으로 보낸다. 이 1바이트를 해석하는 코드는 다음과 같다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">parse_janggu_bits</span></span>(bits: <span class=\"hljs-built_in\">u8</span>) -&gt; JangguState {\n    JangguState {\n        궁채: <span class=\"hljs-keyword\">if</span> bits &amp; <span class=\"hljs-number\">1</span> != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-literal\">Some</span>(DrumPane::채편)\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> bits &amp; <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-literal\">Some</span>(DrumPane::북편)\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-literal\">None</span>\n        },\n        북채: <span class=\"hljs-keyword\">if</span> bits &amp; <span class=\"hljs-number\">4</span> != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-literal\">Some</span>(DrumPane::채편)\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> bits &amp; <span class=\"hljs-number\">8</span> != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-literal\">Some</span>(DrumPane::북편)\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-literal\">None</span>\n        },\n    }\n}</code></pre>\n<p>장구 컨트롤러와 연동하는 쓰레드는 컨트롤러로부터 시리얼 통신으로 받은 데이터를 바로 <code>GameCommonContext</code> 개체의 <code>janggu_bits_ptr</code> 필드에 저장한다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">// ... (생략) ....</span>\n\n<span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">GameCommonContext</span></span> {\n   <span class=\"hljs-comment\">// ... (생략) ...</span>\n   <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) janggu_bits_ptr: Arc&lt;AtomicU8&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span> GameCommonContext {\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">read_janggu_state</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; JangguState {\n        <span class=\"hljs-keyword\">return</span> parse_janggu_bits(\n            <span class=\"hljs-keyword\">self</span>.janggu_bits_ptr\n                .load(std::sync::atomic::Ordering::Relaxed),\n        );\n    }\n}\n</code></pre>\n<p>게임 쓰레드에서 장구의 상태를 확인할 때는 <code>read_janggu_state</code> 메소드를 이용한다.</p>\n<p>추후 미래에 <code>AtomicU8</code>을 없애고 Product-Consumer Lock으로 <code>JangguState</code> 객체를 직접 공유해보기도 했는데, 렉이 너무 심해서 그냥 <code>AtomicU8</code>을 계속 쓰게 됐다.</p>\n<h1 id=\"결론\">결론</h1>\n<p>Rust를 이용한 게임 개발은 초창기에는 할만했는데 뒤로 갈수록 어려웠다. 소유권, 대여, lifetime 문제를 해결하느라 골머리를 참 많이 썩었다. 그래서 결론적으로 짧은 기간 안에 게임을 개발해야 한다면 Rust는 별로 좋은 선택이 아니지 않을까라는 생각이 들었다.</p>\n"}},"__N_SSG":true}