{"pageProps":{"article":{"metadata":{"title":"떨어져 있는 커밋 합치기","subtitle":"의외로 간단한 git interactive rebase 활용법","author":"LiteHell","date":"2023-01-10T05:32:23.209Z","category":"Dev","tags":["Git"]},"rendered":"<h1 id=\"들어가는-글\">들어가는 글</h1>\n<p>글에 들어가기에 앞서, 이 글의 예시에서 rebase 전의 커밋 순서는 다음과 같다고 가정하자: ... → First commit → Secod commit → Third commit → Bugfix related to third commit → Bugfix related to second commit → Fourth commit → Second bugfix related to third commit</p>\n<h1 id=\"연속된-커밋-합치기\">연속된 커밋 합치기</h1>\n<p><a href=\"https://git-scm.com/docs/git-rebase\">git rebase -i</a>를 이용하면 간단하게 연속된 커밋을 합칠 수 있다.</p>\n<pre><code>pick 89b7a0c First commit\nreword 7d62023 Secod commit\npick d3c0a39 Third commit\nfixup 4eb60d0 Bugfix related to third commit\npick 69a520d Bugfix related to second commit\npick 584974e Fourth commit\npick 3f9e8fa Second bugfix related to third commit</code></pre>\n<p>위 to-do를 실행하면 <code>reword</code>로 커밋 <code>7d62023</code>의 메세지를 수정하게 된다. (이 예시에서는 오타를 정정했다고 가정하자.) 그리고 <code>fixup</code>으로 연속하는 커밋 <code>d3c0a39</code>와 <code>4eb60d0</code>을 합치고, 커밋 <code>4eb60d0</code>의 메세지는 버려지게 된다. (메세지도 같이 합치고 싶다면 <code>squash</code>를 쓰면 된다.)</p>\n<p>이를 실행하면 git 히스토리는 다음과 같이 된다: First commit → Second commit → Third commit → Bugfix related to second commit → Fourth commit → Second bugfix related to third commit</p>\n<p>그렇다면 우리는 여기서 궁금증이 생긴다. 연속하지 않는 커밋을 합치고 싶을 땐 어떻게 하면 될까?</p>\n<h2 id=\"연속하지-않는-커밋-합치기\">연속하지 않는 커밋 합치기</h2>\n<p>답은 간단하다. 그냥 to-do에서 커밋 순서를 바꾸면 된다.</p>\n<pre><code>pick 89b7a0c First commit\nreword 7d62023 Secod commit\nfixup 69a520d Bugfix related to second commit\npick d3c0a39 Third commit\nfixup 4eb60d0 Bugfix related to third commit\nfixup 3f9e8fa Second bugfix related to third commit\npick 584974e Fourth commit</code></pre>\n<p>interactive rebase에서 커밋 순서를 무조건 동일하게 해야할 필요는 없다. 연속하지 않는 커밋을 합쳐야 한다면 그냥 순서를 바꿔서 합치면 된다. (이 예시에서도 <code>reword</code>로 커밋 <code>7d62023</code>의 오타를 정정했다고 가정하자.)</p>\n<p>위와 같이 실행하면 git 히스토리는 다음과 같다: First commit → Second commit → Third commit → Fourth commit. Git History가 깔끔하게 된 것을 확인할 수 있다.</p>\n"},"articleId":"rebase_non_consecutive_commits","previousPost":{"name":"webpack_and_react_ssg_2","metadata":{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (2)","subtitle":"... + Static HTML Generation = TA-DA!","author":"LiteHell","date":"2023-01-10T05:00:54.358Z","category":"Dev","series":"webpack_and_react_ssg","tags":["React"]},"rendered":"<h1 id=\"들어가는-글\">들어가는 글</h1>\n<p>1편에서와 같이 개발하면 매우 잘 된다, 구조가 단순하기 때문이다. 1편의 방식을 개발했을 때 빌드된 결과물을 보면 다음과 같이 생겼을 것이다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- dist/index.html --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 참고로 이 예시는 예시일뿐이며, 세부사항은 개개인의 상황에 따라 다를 수 있다. --&gt;</span>\n<span class=\"hljs-meta\">&lt;!doctype <span class=\"hljs-meta-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Lorem ipsum<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">defer</span>=<span class=\"hljs-string\">&quot;defer&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;166.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">defer</span>=<span class=\"hljs-string\">&quot;defer&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;main.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n<p>1편에서 번들링된 파일이 script 태그로 삽입되어 HTML 문서가 불려와진 후 모두 끝난 후 실행되는 형태이다. (<code>defer</code>속성은 스크립트가 문서 분석 이후에 실행되도록 한다.)</p>\n<p>즉, <strong>CSR(Client-Side Rendering)</strong> 방식이다. body 태그 내에 div 태그를 만들고 해당 태그에 React Component를 렌더링하는 코드가 클라이언트단에서 모두 실행되는 방식이다. 빌드 단계에서 렌더링이 이루어지지 않으며, 빌드 단계에서 이루어지는 것은 오직 코드 번들링뿐이다.</p>\n<p>리소스가 한 번만 로드되고 후속 페이지 로드시간이 빠르다는 장점이 있지만 몇가지 단점도 있다.</p>\n<ul>\n<li>SEO(검색 엔진 최적화)에 불리하다.</li>\n<li>초기 페이지 로드시간이 느리며, 다 로드되기 전까진 흰 화면만 뜬다. (필요한 JavaScript와 CSS를 다 불러와야 하기 때문이다.)</li>\n</ul>\n<p>이러한 단점들을 극복하려면 어떻게 해야할까?</p>\n<h2 id=\"with-react-hydration\">with React Hydration</h2>\n<p>빌드시에 초기 HTML을 생성하고, 진입 스크립트을 hydration을 하는 방식으로 수정하면 된다. 여기서 hydration이란 ReactDOMServer에 의해 렌더링된 초기 마크업 코드에 이벤트 리스너를 연결(즉, 요약하자면 재활용)하는 것이다.</p>\n<p>이 방식을 이용하면 HTML 마크업 코드는 빌드 단계에서 생성되고, 클라이언트단에서는 React가 이미 생성된 HTML 코드에 부착(attach)하여 동작한다. 이 방식의 장점은 다음과 같다.</p>\n<ul>\n<li>SEO(검색 엔진 최적화)에 유리하다.</li>\n<li>JavaScript와 CSS가 다 불려와지기 전까지 흰화면만 뜨는 현상을 수정할 수 있다.</li>\n</ul>\n<p>이 방식을 채택하기 전에 먼지 어떤 사항을 확인해야 하는지 한 번 알아보자.</p>\n<h3 id=\"유효한-html코드-작성\">유효한 HTML코드 작성</h3>\n<p>모든 HTML 코드는 유효하게 작성되어야 한다. 예시를 들자면, p태그 안에는 p태그가 들어갈 수 없다.</p>\n<p>React hydration을 하기 위해서는, 빌드단에서 생성된 HTML 코드와 React Component가 생성하는 UI 코드가 일치해야 한다. 만약 초기 UI 불일치 오류가 나타난다면, 유효하지 않은 HTML 코드를 작성한 건 아닌지 한 번 확인해봐야 한다.</p>\n<h3 id=\"클라이언트단에서만-작동하는-코드-수정\">클라이언트단에서만 작동하는 코드 수정</h3>\n<p>Node.js 환경에서 실행되면 오류가 나는 코드가 있다. 이런 코드들은 브라우저 환경에서만 실행되도록 수정해야 한다.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// 예시</span>\n\n<span class=\"hljs-keyword\">const</span> isBrowser = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">window</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">document</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span>\n\n<span class=\"hljs-keyword\">if</span> (isBrowser())\n    <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;../some_module_that_works_only_on_browser&#x27;</span>);</code></pre>\n<p>또한, 브라우저단에서 결과가 결정되거나 항상 일정하지 않은 코드는 <code>useEffect</code> 등을 이용해 UI가 렌더링된 이후에 실행되도록 수정해야 한다. \n<code>useState</code>와 <code>useEffect</code> 등은 브라우저단에서만 렌더링된다.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> { useState, useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-comment\">// 예시</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">AreYouKorean</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// const isKorean = navigator.language === &#x27;ko&#x27;;</span>\n    <span class=\"hljs-keyword\">const</span> [isKorean, setIsKorean] = useState&lt;<span class=\"hljs-built_in\">boolean</span> | <span class=\"hljs-literal\">null</span>&gt;(<span class=\"hljs-literal\">null</span>);\n    useEffect(<span class=\"hljs-function\">() =&gt;</span> {\n        setIsKorean(navigator.language === <span class=\"hljs-string\">&#x27;ko&#x27;</span>);\n    });\n\n    <span class=\"hljs-keyword\">let</span> message: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;...&#x27;</span>;\n    <span class=\"hljs-keyword\">if</span> (isKorean !== <span class=\"hljs-literal\">null</span>)\n        message = isKorean ? <span class=\"hljs-string\">&#x27;한국인이시군요.&#x27;</span> : <span class=\"hljs-string\">&quot;You&#x27;re not Korean!&quot;</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{ message }<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n}</code></pre>\n<h3 id=\"결과가-불명확한-코드-수정\">결과가 불명확한 코드 수정</h3>\n<p>이런 코드는 당연히 빌드할 때 생긴 초기 UI와 클라이언트 렌더링시의 초기 UI가 서로 다르게 한다. 빌드시 시간의 초 단위가 짝수면 결과는 *Yes!*가 렌더링될텐데, 사용자가 로드할 때 시간이 홀수면 *No!*가 렌더링되니 서로 불일치하다. 이런 코드가 있다면 수정해야 한다.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isTimeEven</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">const</span> time = (<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()).getSeconds() % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">return</span> time ? <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> Yes! <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span> : <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> No! <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n}</code></pre>\n<h2 id=\"hydration-적용\">hydration 적용</h2>\n<p>위에서 언급한 문제를 모두 수정했다면 hydration시 초기 UI 불일치 오류는 없을 것이다. 이제 hydration을 적용해보자.</p>\n<h3 id=\"진입-스크립트-수정\">진입 스크립트 수정</h3>\n<p>먼저, hydrate하도록 <code>src/index.tsx</code>를 수정하자.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/index.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom/client&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;../styles/index.css&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> isBrowser <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./isBrowser&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Index</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;bg-gray-400&quot;</span>&gt;</span>\n      Hello, World!\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n}\n\n<span class=\"hljs-comment\">// 만약 브라우저라면</span>\n<span class=\"hljs-keyword\">if</span> (isBrowser()) {\n    <span class=\"hljs-comment\">// body &gt; #root 태그에</span>\n    <span class=\"hljs-keyword\">const</span> rootDiv = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;body &gt; #root&#x27;</span>)!;\n    <span class=\"hljs-comment\">// hydration이 필요하다면 (빌드 결과물)</span>\n    <span class=\"hljs-keyword\">if</span> (rootDiv.classList.contains(<span class=\"hljs-string\">&#x27;hydrate&#x27;</span>)) {\n        <span class=\"hljs-comment\">// Index 컴포넌트를 hydrate한다.</span>\n        ReactDOM.hydrateRoot(rootDiv, <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Index</span> /&gt;</span></span>);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-comment\">/* 만약 hydration이 필요없다면 (webpack serve) */</span> {\n        <span class=\"hljs-comment\">// 그냥 렌더링 한다.</span>\n        <span class=\"hljs-keyword\">const</span> root = ReactDOM.createRoot(rootDiv);\n        root.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Index</span> /&gt;</span></span>)\n    }\n}</code></pre>\n<p>브라우저 환경 여부를 판단하는 <code>src/isBrowser.ts</code>도 간단하게 작성한다.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// src/isBrowser.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isBrowser</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">window</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">document</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span>;\n}</code></pre>\n<p><code>src/index.tsx</code>는 빌드 스크립트에서도 import된다. 따라서 브라우저단에서만 실행되야 하는 코드는 브라우저단에서만 실행되도록 수정해야 한다.</p>\n<h3 id=\"html-템플릿-생성\">HTML 템플릿 생성</h3>\n<p>그 다음으로, 간단한 HTML 템플릿을 생성한다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- src/index.html --&gt;</span>\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;ko&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf8&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Lorem ipsum<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;root&quot;</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n<h3 id=\"html-생성-스크립트-추가\">HTML 생성 스크립트 추가</h3>\n<p>초기 HTML 코드를 생성하는 스크립트를 작성해야 한다. 먼저 스크립트 작성 전에 의존성을 몇가지 설치하자.</p>\n<pre><code class=\"hljs language-bash\">yarn add cheerio tmp-promise</code></pre>\n<p>그 다음으로, 다음과 같이 스크립트를 작성한다.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/generate.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> { load <span class=\"hljs-keyword\">as</span> loadHTML } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;cheerio&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { createWriteStream, promises <span class=\"hljs-keyword\">as</span> fs } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;fs&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> server <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom/server&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> tmp <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;tmp-promise&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> Index <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./index&#x27;</span>;\n\n(<span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-comment\">// 임시 파일을 생성한다.</span>\n    <span class=\"hljs-keyword\">const</span> tmpFile = <span class=\"hljs-keyword\">await</span> tmp.file();\n\n    <span class=\"hljs-comment\">// Webpack 번들러에 의해 생성된 HTML 파일의 위치이다.</span>\n    <span class=\"hljs-keyword\">const</span> filename = <span class=\"hljs-string\">&#x27;./dist/index.html&#x27;</span>;\n\n    <span class=\"hljs-comment\">// 초기 UI 코드를 생성하는 ReactDOMServer의 스트림이다.</span>\n    <span class=\"hljs-keyword\">const</span> reactStream = server.renderToPipeableStream(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Index</span> /&gt;</span></span>);\n\n    <span class=\"hljs-comment\">// 스트림을 임시 파일에 쓴다.</span>\n    <span class=\"hljs-keyword\">const</span> fileStream = createWriteStream(tmpFile.path);\n\n    <span class=\"hljs-comment\">// 초기 UI 코드가 임시 파일에 모두 써졌으면</span>\n    reactStream.pipe(fileStream).on(<span class=\"hljs-string\">&#x27;finish&#x27;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n        <span class=\"hljs-comment\">// 웹팩에 의해 번들링된 HTML 파일을 읽는다.</span>\n        <span class=\"hljs-keyword\">const</span> htmlText = <span class=\"hljs-keyword\">await</span> fs.readFile(filename, { <span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">&#x27;utf8&#x27;</span> });\n\n        <span class=\"hljs-comment\">// HTML 파일의 id가 root인 태그에 초기 UI 코드를 넣는다.</span>\n        <span class=\"hljs-keyword\">const</span> dom = loadHTML(htmlText);\n        dom(<span class=\"hljs-string\">&#x27;body &gt; #root&#x27;</span>).html(<span class=\"hljs-keyword\">await</span> fs.readFile(tmpFile.path, { <span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">&#x27;utf8&#x27;</span> }));\n        dom(<span class=\"hljs-string\">&#x27;body &gt; #root&#x27;</span>).addClass(<span class=\"hljs-string\">&#x27;hydrate&#x27;</span>);\n        dom(<span class=\"hljs-string\">&#x27;body &gt; #root&#x27;</span>);\n\n        <span class=\"hljs-comment\">// HTML 코드를 저장한다.</span>\n        <span class=\"hljs-keyword\">await</span> fs.writeFile(filename, dom.html());\n    });\n})();</code></pre>\n<h3 id=\"webpack-설정-수정\">Webpack 설정 수정</h3>\n<p>Webpack 설정 파일에 생성 스크립트로 번들링하는 설정을 추가한다.\nNode.js를 타켓팅할 시 일부 모듈은 C/C++ 에드온을 이용할 수 있다. 따라서 해당 경우에 대응할 수 있도록 <a href=\"https://www.npmjs.com/package/node-loader\">node-loader</a> 의존성을 같이 설치한다. (만약 그러한 모듈이 없다면 이 문단에서 <code>.node</code> 관련 내용은 무시해도 된다.) <a href=\"https://www.npmjs.com/package/empty-loader\">empty-loader</a> 모듈은 빌드 스크립트에서 CSS 파일을 무시하는 데 이용된다.</p>\n<pre><code class=\"hljs language-bash\">yarn add --dev node-loader empty-loader</code></pre>\n<p>그리고 다음과 같이 <code>webpack.config.js</code>를 수정한다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack.config.js</span>\n\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> HtmlWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;html-webpack-plugin&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> { CleanWebpackPlugin } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;clean-webpack-plugin&#x27;</span>);\n\n<span class=\"hljs-keyword\">const</span> dev = process.env.NODE_ENV === <span class=\"hljs-string\">&#x27;development&#x27;</span>;\n\n<span class=\"hljs-comment\">// src/index.tsx 설정과 src/generate.ts 설정에 공통적으로 들어가는 항목들이다.</span>\n<span class=\"hljs-keyword\">const</span> commons = {\n    <span class=\"hljs-attr\">mode</span>: dev ? <span class=\"hljs-string\">&quot;development&quot;</span> : <span class=\"hljs-string\">&quot;production&quot;</span>,\n    <span class=\"hljs-attr\">resolve</span>: {\n        <span class=\"hljs-comment\">// .node가 추가되었다.</span>\n        <span class=\"hljs-attr\">extensions</span>: [<span class=\"hljs-string\">&#x27;.tsx&#x27;</span>, <span class=\"hljs-string\">&#x27;.ts&#x27;</span>, <span class=\"hljs-string\">&#x27;.js&#x27;</span>, <span class=\"hljs-string\">&#x27;.css&#x27;</span>, <span class=\"hljs-string\">&#x27;.node&#x27;</span>]\n    },\n    <span class=\"hljs-attr\">module</span>: {\n        <span class=\"hljs-attr\">rules</span>: [\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.tsx?$/</span>,\n                exclude: <span class=\"hljs-regexp\">/node_modules/</span>,\n                use: [\n                    {\n                        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;babel-loader&#x27;</span>,\n                        <span class=\"hljs-attr\">options</span>: {\n                            <span class=\"hljs-attr\">presets</span>: [<span class=\"hljs-string\">&#x27;@babel/preset-react&#x27;</span>, <span class=\"hljs-string\">&#x27;@babel/preset-env&#x27;</span>]\n                        }\n                    },\n                    <span class=\"hljs-string\">&#x27;ts-loader&#x27;</span>\n                ]\n            },\n            {\n                <span class=\"hljs-comment\">// .node 파일을 로드한다.</span>\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.node$/</span>,\n                use: <span class=\"hljs-string\">&#x27;node-loader&#x27;</span>\n            }\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-keyword\">new</span> CleanWebpackPlugin()]\n};\n\n<span class=\"hljs-built_in\">module</span>.exports = [<span class=\"hljs-comment\">/* src/index.tsx 설정 */</span>{\n    ...commons,\n    <span class=\"hljs-attr\">optimization</span>: {\n      <span class=\"hljs-attr\">splitChunks</span>: {\n        <span class=\"hljs-attr\">chunks</span>: <span class=\"hljs-string\">&#x27;all&#x27;</span>\n      },\n      <span class=\"hljs-attr\">minimize</span>: !dev\n    },\n    <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&#x27;./src/index.tsx&#x27;</span>,\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.resolve(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;[name].js&#x27;</span>\n    },\n    <span class=\"hljs-attr\">module</span>: {\n        ...commons.module,\n        <span class=\"hljs-attr\">rules</span>: [\n            ...commons.module.rules,\n            <span class=\"hljs-comment\">// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)</span>\n            <span class=\"hljs-comment\">// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 </span>\n            <span class=\"hljs-comment\">// src/index.tsx Webpack 설정에만 추가한다.</span>\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n                use: [<span class=\"hljs-string\">&#x27;style-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>]\n            },\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        ...commons.plugins,\n        <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>,\n        <span class=\"hljs-comment\">// template 속성을 추가한다.</span>\n        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;./src/index.html&#x27;</span>\n    })],\n    <span class=\"hljs-attr\">devServer</span>: {\n        <span class=\"hljs-attr\">static</span>: {<span class=\"hljs-attr\">directory</span>: path.join(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>)},\n        <span class=\"hljs-attr\">open</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">port</span>: <span class=\"hljs-string\">&#x27;auto&#x27;</span>,\n    },\n    <span class=\"hljs-attr\">watchOptions</span>: {\n        <span class=\"hljs-attr\">ignored</span>: <span class=\"hljs-regexp\">/node_modules/</span>\n    }\n}, <span class=\"hljs-comment\">/* src/generate.tsx 설정 */</span> {\n    ...commons,\n    <span class=\"hljs-comment\">// node로 실행할 스크립트이기 때문에 target을 node로 한다.</span>\n    <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;node&#x27;</span>,\n    <span class=\"hljs-comment\">// entry는 src/generate.tsx로 한다.</span>\n    <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&#x27;./src/generate.tsx&#x27;</span>,\n    <span class=\"hljs-attr\">module</span>: {\n        ...commons.module,\n        <span class=\"hljs-attr\">rules</span>: [\n            ...commons.module.rules,\n            {\n                <span class=\"hljs-comment\">// css파일은 무시한다.</span>\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n                use: [<span class=\"hljs-string\">&#x27;empty-loader&#x27;</span>]\n            },\n        ]\n    },\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.resolve(__dirname, <span class=\"hljs-string\">&#x27;dist-builder&#x27;</span>),\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.js&#x27;</span>\n    }\n}]</code></pre>\n<h2 id=\"빌드-스크립트-실행\">빌드 스크립트 실행</h2>\n<p>이제 거의 다 됐다. 다음 명령어로 빌드해보자.</p>\n<pre><code class=\"hljs language-bash\">npx webpack build\nnode ./dist-builder</code></pre>\n<p>별 다른 오류없이 잘 될 것이다. 축하한다. 이제 앞으로 위 명령어로 빌드하면 초기 HTML 코드가 들어가있는 파일이 빌드될 것이다. 해당 빌드의 결과는 다음과 같다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- dist/index.html --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 참고로 이 예시는 예시일뿐이며, 세부사항은 개개인의 상황에 따라 다를 수 있다. --&gt;</span>\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;ko&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf8&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Lorem ipsum<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">defer</span>=<span class=\"hljs-string\">&quot;defer&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;166.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">defer</span>=<span class=\"hljs-string\">&quot;defer&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;main.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;root&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bg-gray-400&quot;</span>&gt;</span>Hello, World!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n"},"nextPost":{"name":"bypassing_safe2go_datepicker_bug","metadata":{"title":"Safe2GO PASS 출발지 날짜 선택 안되는 버그 우회하기","subtitle":"인천국제공항 코로나19 검사예약하려는 사람들을 위하여","author":"LiteHell","date":"2023-01-30T17:03:29.886Z","category":"Dev","tags":["Web"],"last_modified_at":"2023-02-04T06:23:15.268Z"},"rendered":"<h1 id=\"2023-02-04-수정사항\">2023-02-04 수정사항</h1>\n<p>현재는 해당 버그가 고쳐졌다.</p>\n<del>\n\n<h1 id=\"들어가는-글\">들어가는 글</h1>\n<p>사람에 따라서는, 해외여행을 가기위해선 PCR 검사를 해야하는 경우가 있다. 이런 사람들은 민간병원이나 <a href=\"https://www.airport.kr/ap_cnt/ko/svc/covid19/medical/medical.do\">인천국제공항 코로나19 검사센터</a>에서 검사를 받아야 한다. 인천국제공항 코로나19 검사센터에서 검사를 예약하려면 <a href=\"https://safe2gopass.com/\">Safe2GO PASS</a>라는 웹사이트를 이용해야 한다.</p>\n<h1 id=\"safe2go-pass의-버그\">Safe2GO Pass의 버그</h1>\n<p>그런데 Safe2GO PASS에는 버그가 있다. (적어도 지금 글을 쓰는 2023-01-31 새벽에는 있었다.) 이 버그는 Chrome, Firefox, Edge, 데스크톱, 모바일에서 똑같이 발생했다.</p>\n<p>Safe2GO PASS에서는 코로나19 검사를 예약하려면 여행일정을 추가해야 한다. 그런데 무슨 이유에선지 이 웹사이트는 출발지 날짜를 선택하려고 클릭하면 아무것도 뜨지 않고 입력할 수도 없었다. (참고로 도착일은 선택이 잘 된다.)</p>\n<p><img src=\"/img/safe2go_pass_departure_date_click.png\" alt=\"Safe2GO PASS의 출발일 날짜란을 클릭하였으나 아무 일도 일어나지 않는 모습\"></p>\n<p>(이 상태에서 출발일 날짜를 선택할 수 없었다.)</p>\n<p>인천국제공항에서 출발하는 여행일정이라면 출발일 날짜를 지정해야 하는데 위와 같이 지정을 할 수가 없으니 코로나19 검사를 예약할 방법이 없다. 그렇다면 우리는 어떻게 해야할까?</p>\n<h2 id=\"해결방법\">해결방법</h2>\n<p>버그가 언제 수정될 지는 알 수 없으니, 일단 임시방편으로 버그를 우회해야 한다.</p>\n<p>먼저, 해당 화면에서 F12키를 눌러 개발자 도구를 킨다. 그리고 콘솔(혹은 Console) 탭을 연다.</p>\n<p>그 다음, 다음 스크립트에서 날짜 부분(<code>2023-06-01</code>)을 원하는 출발일 날짜로 바꿔 복사-붙여넣기한다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;.s-container&#x27;</span>).__vue__.start.date = <span class=\"hljs-string\">&quot;2023-06-01&quot;</span>;</code></pre>\n<p>이때, 위에서 날짜부분은 <code>YYYY-MM-DD</code> 형식을 정확하게 지켜야 한다. 즉, 예시를 들어 2020년 1월 1일이라면 <code>2020-1-1</code>이 아닌 <code>2020-01-01</code>로 바꿔야 한다. 혹시나하는 마음에 덧붙이자면, <code>2020-01-01</code>이 아닌 <code>2020.01.01</code>은 당연히 안 된다.</p>\n<p>복사-붙여넣기를 하면 아래 사진과 같이 맨 하단에 스크립트가 입력되어 있을 것이다. 참고로 아래 사진은 Firefox 웹 브라우저를 이용한 모습이다. (어처피 Chrome도 개발자도구 콘솔은 비슷하게 생겼으므로 참고하는 데 큰 어려움은 없을 것이다.)</p>\n<p><img src=\"/img/safe2go_pass_dev_console.png\" alt=\"Firefox 개발자도구에서 스크립트를 복사 붙여넣기한 모습\"></p>\n<p>이제 위 상태에서 엔터 키를 누르면 아래와 같이 출발일이 잘 입력된 것을 확인할 수 있다. 이제 나머지 정보를 입력해서 여행일정을 추가하면 된다.\n<img src=\"/img/safe2go_pass_start_date_entered.png\" alt=\"Safe2GO Pass 여행일정 추가 화면에서 출발일 날짜가 입력된 모습\"></p>\n<h1 id=\"마무리\">마무리</h1>\n<p>웹사이트내에는 버그 제보를 받는 곳이 딱히 안 보여서, 아마도 담당자의 메일 주소인 것 같은 곳으로 버그 제보 메일을 보냈다. 어서 빨리 이 버그가 수정됐으면 좋겠다.\n</del></p>\n"}},"__N_SSG":true}