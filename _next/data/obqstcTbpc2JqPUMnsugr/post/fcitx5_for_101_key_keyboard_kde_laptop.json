{"pageProps":{"article":{"metadata":{"title":"한글 입력을 위한 fcitx5 설치","subtitle":"KDE 노트북에서의 버그없는 한글 입력을 위한 삽질기","author":"LiteHell","date":"2023-10-17T12:34:16.790Z","category":"Linux","tags":["Linux","Korean","Hangul","IM","KDE"],"last_modified_at":"2023-10-17T14:32:47.687Z"},"rendered":"<h1 id=\"서론\">서론</h1>\n<p>필자는 초창기에 <a href=\"https://github.com/ibus/ibus\">ibus</a>를 썼었다. ibus는 웬만한 프로그램에서 아무 버그없이 잘 작동한다. 딱 한가지, 리브레오피스에서 공백 입력이 안 된다는 치명적인 버그만 빼면 말이다.</p>\n<p>그래서 ibus 다음으로 <a href=\"https://github.com/hamonikr/nimf\">하모니카에서 유지보수하는 nimf</a>를 썼었다. nimf는 리브레오피스에서의 치명적인 버그는 없었지만, 엔터키를 누르면 텍스트가 사라지는 버그가 있었다. 근데 이 버그, 처음에만 짜증나지 좀 지나면 적응된다. 그래서 적응해서 쓰다가 생각해보니 &#39;이건 좀 아닌 것 같다&#39;싶어서 다른 입력기를 설치했다.</p>\n<p>본 블로그 글은 <a href=\"https://archlinux.org/\">Arch Linux</a>를 기준으로 설명한다.</p>\n<h2 id=\"kde에서의-키보드-레이아웃\">KDE에서의 키보드 레이아웃</h2>\n<p>입력기를 바꾸기 위해 삽질하는 과정에서 한글키가 오른쪽 Alt키로 인식되는 현상을 확인했다. 분명히 아치 리눅스 설치 초기에 매핑을 했었는데, 시스템 업데이트를 하는 과정에서 원상복구가 된 것 같다. 그래서 이번에는 KDE 설정 프로그램을 이용해 한글키와 한자키를 매핑했다.</p>\n<p><img src=\"/img/kde_keyboard_settings.png\" alt=\"KDE 키보드 설정 프로그램\"></p>\n<p>위와 같이 시스템 설정 프로그램의 <strong>입력 장치 🠞 키보드</strong> 화면에서 <strong>오른쪽 Alt 키를 한/영 키로 만들기</strong>, <strong>오른쪽 Ctrl 키를 한자 키로 만들기</strong> 항목을 체크하면 된다. (키보드 레이아웃에 따라 약간 다를 수 있다.) 노트북 등의 101/104키 호환 레이아웃이라면 위 과정을 반드시 거쳐야 한다.</p>\n<h3 id=\"한영-한자키-인식여부-확인방법\">한/영, 한자키 인식여부 확인방법</h3>\n<p>본인 키보드가 101/104키인지 106키인지 헷갈린다면 <del>키보드 키 갯수 세지말고</del> 먼저 <code>xev</code> 프로그램을 설치한다.</p>\n<pre><code class=\"hljs language-bash\">sudo pacman -S xorg-xev</code></pre>\n<p>그리고 콘솔 창에서 xev 프로그램을 실행한다.</p>\n<pre><code class=\"hljs language-bash\">xev</code></pre>\n<p>xev 프로그램 창을 활성화하고 한글키랑 한자키를 눌러본다. 다음과 같이 콘솔 창에 <em>Hangul</em>이나 <em>Hangul_Hanja</em>키가 인식된 메세지가 출력되면 한/영 키, 한자 키가 정상적으로 인식되는 것이다.</p>\n<pre><code>KeyRelease event, serial 39, synthetic NO, window 0x9000001,\n    root 0x79b, subw 0x0, time 1234567, (-10, 10), root:(10, 10),\n    state 0x0, keycode 108 (keysym 0xff31, Hangul), same_screen YES,</code></pre>\n<pre><code>KeyPress event, serial 39, synthetic NO, window 0x9000001,\n    root 0x79b, subw 0x0, time 1234567, (10, 10), root:(10, 10),\n    state 0x0, keycode 105 (keysym 0xff34, Hangul_Hanja), same_screen YES,</code></pre>\n<p>만약 위와 같은 메세지가 안 뜨고 Alt_R이나 Control_R이 인식된다면 <a href=\"#kde에서의-키보드-레이아웃\">위에 써진 내용</a>에 따라 매핑하면 된다.</p>\n<h2 id=\"fcitx5-설치-방법\">fcitx5 설치 방법</h2>\n<p>먼저, 다음 명령어를 실행해 fcitx5를 설치한다.</p>\n<pre><code class=\"hljs language-bash\">sudo pacman -S fcitx5-im fcitx-hangul</code></pre>\n<p><code>/etc/environment</code> 파일에 다음 내용을 추가한다. 입력기로 fcitx를 쓰도록 지정하는 작업이다.</p>\n<!-- ini파일이 아니지만 syntax highlighting을 위해 형식을 ini으로 지정함 --->\n<pre><code class=\"hljs language-ini\"><span class=\"hljs-attr\">GTK_IM_MODULE</span>=fcitx\n<span class=\"hljs-attr\">QT_IM_MODULE</span>=fcitx\n<span class=\"hljs-attr\">QT4_IM_MODULE</span>=fcitx\n<span class=\"hljs-attr\">QT5_IM_MODULE</span>=fcitx\n<span class=\"hljs-attr\">XMODIFIERS</span>=@im=fcitx</code></pre>\n<p>그 다음에 <code>~/.xprofile</code> 파일에 다음 내용을 추가한다. 부팅시에 fcitx5가 실행되도록 한다.</p>\n<pre><code class=\"hljs language-bash\">fcitx5 -d</code></pre>\n<p>재부팅하고 <code>env | grep fcitx</code> 명령어를 실행해 환경변수가 제대로 변경됐는지 확인해보자. 제대로 변경됐다면 다음과 같이 뜰 것이다.</p>\n<pre><code class=\"hljs language-bash\">GTK_IM_MODULE=fcitx\nQT4_IM_MODULE=fcitx\nXMODIFIERS=@im=fcitx\nQT5_IM_MODULE=fcitx\nQT_IM_MODULE=fcitx</code></pre>\n<p>만약 환경변수가 제대로 변경되지 않았다면 <code>~/.xprofile</code> 파일에서 <code>fcitx5 -d</code> 위에 다음 내용을 추가하고 재부팅한다. 그러면 환경변수가 정상적으로 변경될 것이다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">export</span> $(/usr/lib/systemd/user-environment-generators/30-systemd-environment-d-generator)</code></pre>\n<h2 id=\"fcitx5-설정\">fcitx5 설정</h2>\n<p><code>fcitx5-configtool</code> 명령어를 실행하면 다음 창이 뜬다.\n<img src=\"/img/fcitx5_settings_first_screen.png\" alt=\"fcitx5 KDE 설정 창\"></p>\n<p>위 화면에서 한국어가 안 보이면 <strong>입력기 추가</strong>버튼을 눌러서 추가한다. (입력기 추가 화면에서 한국어가 안 보이면 <strong>현재 언어만 표시</strong> 옵션을 해제하면 된다.)</p>\n<p>밑에서 <strong>전역 옵션 구성하기...</strong> 버튼을 누르면 다음 화면이 뜬다.</p>\n<p><img src=\"/img/fcitx5_global_settings.png\" alt=\"fcitx5 KDE 설정 창\"></p>\n<p><strong>Trigger Input Method</strong>가 한/영을 전환하는 단축키 설정이다. 오른쪽의 <strong>+</strong> 버튼을 눌러 한글 키를 추가하면 된다.</p>\n<p>fcitx5는 기본적으로 한/영을 전환할때 작은 툴팁을 표시한다. 거슬리면 위 화면에서 <strong>Show Input Method Information when switch input method</strong>를 체크 해제하면 된다.</p>\n<p>이제 한글 입력을 버그없이 잘 할 수 있게 됐다. 끝!</p>\n"},"articleId":"fcitx5_for_101_key_keyboard_kde_laptop","previousPost":{"name":"webpack_and_react_ssg_3","metadata":{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (3)","subtitle":"... + MiniCssExtractPlugin = TA-DA!","author":"LiteHell","date":"2023-07-23T17:25:47.907Z","series":"webpack_and_react_ssg","seriesName":"Webpack과 React를 이용한 정적 웹사이트 만들기","category":"Dev","tags":["React"]},"rendered":"<p>전 글까지 <a href=\"https://webpack.js.org/loaders/style-loader/\">style-loader</a>를 썼다. style-loader는 style 태그를 동적으로 생성하여 CSS를 DOM 안에 주입하는 로더이다. 즉, style-loader를 쓰면 js 스크립트가 실행되면서 style 태그가 동적으로 생성되고, 그 태그 내에 css가 동적으로 삽입되면서 스타일이 적용된다.</p>\n<p>하지만 정적 페이지로 빌드후 속도가 느린 서버로 게시하거나 스크립트 용량이 비대하면, 스크립트가 완전히 다 실행되기 전까지의 찰나동안 스타일이 적용되지 않은 깨진 페이지가 나타난다. 이런 버그를 막기 위해서는 <a href=\"https://webpack.js.org/plugins/mini-css-extract-plugin/\">MiniCssExtractPlugin</a>을 이용하면 된다.</p>\n<p>MiniCssExtractPlugin은 CSS를 스크립트를 통해 DOM에 주입하지 않고 별도의 CSS 파일에 저장한 뒤, 빌드시에 해당 CSS 파일을 삽입하는 link 태그를 HTML에 삽입한다. 즉 동적으로 CSS를 주입하지 않는다. 따라서 이를 이용하면 스크립트가 완전히 다 실행되기 전까지 페이지 스타일이 적용되지 않는 현상을 해결할 수 있다.</p>\n<p>MiniCssExtractPlugin을 이용하기 위해서는 먼저 해당 패키지를 설치해야 한다. 다음 명령어로 해당 패키지를 설치한다.</p>\n<pre><code class=\"hljs language-bash\">yarn add --dev mini-css-extract-plugin</code></pre>\n<p>그 다음 <code>webpack.config.js</code> 파일에서 다음 부분을 다음과 같이 수정한다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 수정 전</span>\n<span class=\"hljs-attr\">module</span>: {\n        ...commons.module,\n        <span class=\"hljs-attr\">rules</span>: [\n            ...commons.module.rules,\n            <span class=\"hljs-comment\">// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)</span>\n            <span class=\"hljs-comment\">// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 </span>\n            <span class=\"hljs-comment\">// src/index.tsx Webpack 설정에만 추가한다.</span>\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n                use: [<span class=\"hljs-string\">&#x27;style-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>]\n            },\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        ...commons.plugins,\n        <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>,\n        <span class=\"hljs-comment\">// template 속성을 추가한다.</span>\n        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;./src/index.html&#x27;</span>\n    })],</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 수정 후</span>\n<span class=\"hljs-attr\">module</span>: {\n        ...commons.module,\n        <span class=\"hljs-attr\">rules</span>: [\n            ...commons.module.rules,\n            <span class=\"hljs-comment\">// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)</span>\n            <span class=\"hljs-comment\">// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 </span>\n            <span class=\"hljs-comment\">// src/index.tsx Webpack 설정에만 추가한다.</span>\n            <span class=\"hljs-comment\">// 그리고 프로덕션 빌드시에는 MiniCssExtractPlugin을 이용하여 js가 다 로드되기 전에는</span>\n            <span class=\"hljs-comment\">// 스타일이 적용되지 않는 버그를 해결한다.</span>\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n                use: [dev ? <span class=\"hljs-string\">&#x27;style-loader&#x27;</span> : MiniCssExtractPlugin.loader, <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>]\n            },\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        ...commons.plugins,\n        <span class=\"hljs-keyword\">new</span> MiniCssExtractPlugin(),\n        <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>,\n        <span class=\"hljs-comment\">// template 속성을 추가한다.</span>\n        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;./src/index.html&#x27;</span>\n    })],</code></pre>\n<p>위와 같이 수정한 후 정적 웹페이지를 빌드하면 이제 스크립트가 불러와지는동안 스타일이 적용되지 않는 문제가 해결된다.</p>\n"},"nextPost":{"name":"docker_for_testing","metadata":{"title":"Docker로 테스트하기","subtitle":"Docker로 빌드만 하지 말고 테스트도 하자","author":"LiteHell","date":"2023-10-25T14:49:49.041Z","category":"Dev","tags":["Docker"],"last_modified_at":"2024-12-27T13:05:23.710Z"},"rendered":"<h1 id=\"들어가는-글\">들어가는 글</h1>\n<p>필자는 중앙대학교 공지사항을 <a href=\"https://rss.puang.network\">RSS</a>로 만들어서 구독한다. RSS로 만든 후 메신지 봇을 붙이면 알아서 알려주니 편하다.</p>\n<p>그러나 최근 해당 RSS 프로그램의 테스트가 실패하는 현상이 발견됐다. 확인한 결과, <a href=\"https://swedu.cau.ac.kr\">중앙대학교 SW교육원</a> 홈페이지의 TLS 인증서 이슈였던 것으로 확인됐다. 따라서 이를 해결하기 위해 일단 실행되고 있는 Docker 컨테이너에 직접 접근해서 해당 사이트의 CA 인증서를 설치했다.</p>\n<h1 id=\"기존-테스트-방법의-한계점\">기존 테스트 방법의 한계점</h1>\n<p>버그는 일단 임시방편으로 수정한 것이니 레포에는 반영되지 않았다. 따라서 테스트 실패 메일이 매일매일 내 메일함으로 전송됐다.</p>\n<p>어떻게 하면 이 버그를 수정하고 잘 테스트할 수 있을까? 먼저 이 버그를 수정하려면 Dockerfile을 수정해야 한다. Dockerfile에 다음 내용을 추가하여 Docker 이미지 빌드시 CA 인증서를 복사하도록 했다. <a href=\"https://github.com/LiteHell/cau-rss/commit/d765d53d61e9370f5a284068ed273570d21013a3\">LiteHell/cau-rss 레포의 커밋 21013a3</a>에서 확인할 수 있다.</p>\n<pre><code class=\"hljs language-Dockerfile\"><span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> swedu-cert.pem /usr/<span class=\"hljs-built_in\">local</span>/share/ca-certificates/swedu-cert.crt</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> cat /usr/<span class=\"hljs-built_in\">local</span>/share/ca-certificates/swedu-cert.crt &gt;&gt; /etc/ssl/certs/ca-certificates.crt</span></code></pre>\n<p>이제 위 버그 수정도 같이 테스트해야 한다. 아래에 있는 기존의 GitHub Action으로는 이 버그 수정을 테스트할 수 없다. <code>go test -v ./...</code> 명령어가 빌드된 Docker 이미지 내에서 실행되는 것이 아니기 때문이다.</p>\n<pre><code class=\"hljs language-yaml\">      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">go</span> <span class=\"hljs-string\">build</span> <span class=\"hljs-string\">-v</span> <span class=\"hljs-string\">./...</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Test</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">go</span> <span class=\"hljs-string\">test</span> <span class=\"hljs-string\">-v</span> <span class=\"hljs-string\">./...</span></code></pre>\n<p>어떻게 하면 테스트할 수 있을까? 답은 간단하다. Docker로 테스트도 하면 된다.</p>\n<h1 id=\"docker를-이용한-테스트\">Docker를 이용한 테스트</h1>\n<h2 id=\"multi-stage-빌드\">Multi-stage 빌드</h2>\n<p>Docker는 빌드를 여러 단계로 나누어 진행할 수 있다. 아래 예시 Dockerfile을 보자.</p>\n<pre><code class=\"hljs language-Dockerfile\"><span class=\"hljs-keyword\">FROM</span> node AS base\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n<span class=\"hljs-keyword\">ADD</span><span class=\"bash\"> src package.json package-lock.json tsconfig.json .</span>\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm i</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm bulid</span>\n\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">&quot;npm&quot;</span>, <span class=\"hljs-string\">&quot;run&quot;</span>, <span class=\"hljs-string\">&quot;start&quot;</span>]</span></code></pre>\n<p>Typescript 프로젝트를 위한 간단한 Dockerfile이다. 이를 다음과 같이 여러개의 단계(stage)로 쪼갤 수 있다.</p>\n<pre><code class=\"hljs language-Dockerfile\"><span class=\"hljs-keyword\">FROM</span> node AS base\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n<span class=\"hljs-keyword\">ADD</span><span class=\"bash\"> src package.json package-lock.json tsconfig.json .</span>\n\n<span class=\"hljs-keyword\">FROM</span> base AS deps\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm i</span>\n\n<span class=\"hljs-keyword\">FROM</span> deps AS build\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm bulid</span>\n\n<span class=\"hljs-keyword\">FROM</span> build AS deployment\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">&quot;npm&quot;</span>, <span class=\"hljs-string\">&quot;run&quot;</span>, <span class=\"hljs-string\">&quot;start&quot;</span>]</span>\n</code></pre>\n<p>위와 같은 Dockerfile을 이용하면 Docker 빌드시 특정 스테이지까지만 빌드할 수 있다. 예를 들어 아래 명령어는 deps 스테이지까지만 빌드한다.</p>\n<pre><code class=\"hljs language-bash\">docker build --target deps</code></pre>\n<p>스테이지가 직선적이여야 할 필요는 없다. 다음과 같이 스테이지가 중간에 분기하도록 작성할 수도 있다.</p>\n<pre><code class=\"hljs language-Dockerfile\"><span class=\"hljs-keyword\">FROM</span> node AS base\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n<span class=\"hljs-keyword\">ADD</span><span class=\"bash\"> src package.json package-lock.json tsconfig.json .</span>\n\n<span class=\"hljs-keyword\">FROM</span> base AS deps\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm i</span>\n\n<span class=\"hljs-keyword\">FROM</span> deps AS build\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm bulid</span>\n\n<span class=\"hljs-keyword\">FROM</span> build AS english\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> english .</span>\n\n<span class=\"hljs-keyword\">FROM</span> english AS deployment-international\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">&quot;npm&quot;</span>, <span class=\"hljs-string\">&quot;run&quot;</span>, <span class=\"hljs-string\">&quot;start&quot;</span>, <span class=\"hljs-string\">&quot;--lang=english&quot;</span>]</span>\n\n<span class=\"hljs-keyword\">FROM</span> build AS korean\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> korean .</span>\n\n<span class=\"hljs-keyword\">FROM</span> korean AS deployment-domestic\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">&quot;npm&quot;</span>, <span class=\"hljs-string\">&quot;run&quot;</span>, <span class=\"hljs-string\">&quot;start&quot;</span>, <span class=\"hljs-string\">&quot;--lang=korean&quot;</span>]</span></code></pre>\n<p>위 Dockerfile의 경우 build 스테이지에서 english 스테이지와 korean 스테이지로 분기한다.</p>\n<h3 id=\"buildkit\">BuildKit</h3>\n<pre><code class=\"hljs language-Dockerfile\"><span class=\"hljs-keyword\">FROM</span> node AS base\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n<span class=\"hljs-keyword\">ADD</span><span class=\"bash\"> src package.json package-lock.json tsconfig.json .</span>\n\n<span class=\"hljs-keyword\">FROM</span> base AS deps\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm i</span>\n\n<span class=\"hljs-keyword\">FROM</span> deps AS build\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm bulid</span>\n\n<span class=\"hljs-keyword\">FROM</span> build AS english\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> english .</span>\n\n<span class=\"hljs-keyword\">FROM</span> english AS deployment-international\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">&quot;npm&quot;</span>, <span class=\"hljs-string\">&quot;run&quot;</span>, <span class=\"hljs-string\">&quot;start&quot;</span>, <span class=\"hljs-string\">&quot;--lang=english&quot;</span>]</span>\n\n<span class=\"hljs-keyword\">FROM</span> build AS korean\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> korean .</span>\n\n<span class=\"hljs-keyword\">FROM</span> korean AS deployment-domestic\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">&quot;npm&quot;</span>, <span class=\"hljs-string\">&quot;run&quot;</span>, <span class=\"hljs-string\">&quot;start&quot;</span>, <span class=\"hljs-string\">&quot;--lang=korean&quot;</span>]</span></code></pre>\n<p>위 Dockerfile을 가지고 아래 명령어를 실행한다고 가정해보자.</p>\n<pre><code class=\"hljs language-bash\">docker build --target deployment-domestic</code></pre>\n<p>위 경우 빌드에 필요한 스테이지는 <code>base</code>, <code>deps</code>, <code>build</code>, <code>korean</code>, <code>deployment-domestic</code>이다. 그러나 실제로 위 명령어를 실행해보면 불필요한 <code>english</code>, <code>deployment-international</code> 스테이지도 빌드하는 것을 확인할 수 있다.</p>\n<p>이는 도커 레거시 빌더를 이용하기 때문에 생기는 문제이다. <a href=\"https://docs.docker.com/build/buildkit/\">Docker BuildKit</a>은 사용되지 않는 스테이지를 자동으로 파악하여 불필요한 스테이지는 빌드를 생략한다. 따라서 Docker BuildKit을 설치한 후 다음 명령어로 빌드하면 필요한 스테이지만 빌드할 수 있다.</p>\n<pre><code class=\"hljs language-bash\">DOCKER_BUILDKIT=1 docker build --target deployment-domestic</code></pre>\n<h2 id=\"multi-stage-빌드를-이용한-테스트\">Multi-stage 빌드를 이용한 테스트</h2>\n<p>이제 Docker를 이용해 테스트를 하는 방법에 대해 알아보자. 다음은 <a href=\"https://github.com/LiteHell/cau-rss\">cau-rss 레포</a>의 Dockerfile 내용을 약간 수정한 예시이다.</p>\n<pre><code class=\"hljs language-Dockerfile\"><span class=\"hljs-keyword\">FROM</span> golang:alpine AS base\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> go.mod go.sum ./</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> go mod download &amp;&amp; go mod verify</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> cau_parser ./cau_parser</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> server ./server</span>\n\n<span class=\"hljs-comment\"># To avoid tls error from swedu.cau.ac.kr</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> swedu-cert.pem /usr/<span class=\"hljs-built_in\">local</span>/share/ca-certificates/swedu-cert.crt</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> cat /usr/<span class=\"hljs-built_in\">local</span>/share/ca-certificates/swedu-cert.crt &gt;&gt; /etc/ssl/certs/ca-certificates.crt</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> static ./static</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> html ./html</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> *.go ./</span>\n\n<span class=\"hljs-keyword\">FROM</span> base AS build\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> go build -v -o ./app ./</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">&quot;/app/app&quot;</span>]</span>\n\n<span class=\"hljs-keyword\">FROM</span> base AS test\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> [<span class=\"hljs-string\">&quot;go&quot;</span>, <span class=\"hljs-string\">&quot;test&quot;</span> ,<span class=\"hljs-string\">&quot;-v&quot;</span>, <span class=\"hljs-string\">&quot;./...&quot;</span>]</span>\n</code></pre>\n<p><code>base</code> 스테이지에서 의존성을 설치한 뒤 각종 필요한 파일들을 복사하고 TLS 인증서 오류 해결을 위한 CA 인증서를 복사한다. <code>test</code> 스테이지는 <code>base</code> 스테이지에서 테스트 명령어를 실행하는 스테이지이며, <code>build</code> 스테이지는 <code>base</code> 스테이지를 바탕으로 도커 이미지를 빌드하는 스테이지이다.</p>\n<p>따라서 위 Dockerfile을 이용해 <code>build</code> 스테이지까지 빌드하면 도커 이미지를 만드는 것이며, <code>test</code> 스테이지까지 빌드하면 테스트를 실행하게 되는 것이다. 이를 명령어로 나타내면 다음과 같으며, 캐시로 인해 테스트가 진행되지 않는 것을 방지하기 위해 <code>--no-cache</code> 매개변수를 추가했다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># Test</span>\nDOCKER_BUILDKIT=1 docker build --no-cache --target <span class=\"hljs-built_in\">test</span> .\n\n<span class=\"hljs-comment\"># Build</span>\nDOCKER_BUILDKIT=1 docker build --target build</code></pre>\n<p>테스트 실패시 Docker 빌드 오류가 발생한다. 이를 응용하면 다음과 같이 테스트 성공시 빌드를 진행하고, 실패시 오류 메세지를 출력하는 bash 스크립트를 작성할 수 있다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">export</span> DOCKER_BUILDKIT=1\n\ndocker build --no-cache --target <span class=\"hljs-built_in\">test</span> .\ntest_status=$?\n<span class=\"hljs-keyword\">if</span> [ <span class=\"hljs-variable\">$test_status</span> -eq 0 ]; <span class=\"hljs-keyword\">then</span>\n  docker build --taget build . --tag example-application\n<span class=\"hljs-keyword\">else</span>\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;ERROR while testing!&quot;</span>\n<span class=\"hljs-keyword\">fi</span></code></pre>\n<h2 id=\"github-action을-이용한-활용\">Github Action을 이용한 활용</h2>\n<p>GitHub Action을 이용하면 다음과 같이 push시 테스트가 이루어지도록 할 수 있다.</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Test</span>\n<span class=\"hljs-attr\">on:</span> <span class=\"hljs-string\">push</span>\n\n<span class=\"hljs-attr\">jobs:</span>\n  <span class=\"hljs-attr\">test:</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>\n    <span class=\"hljs-attr\">steps:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Set</span> <span class=\"hljs-string\">up</span> <span class=\"hljs-string\">Docker</span> <span class=\"hljs-string\">Buildx</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">docker/setup-buildx-action@v3</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Test</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">docker</span> <span class=\"hljs-string\">build</span> <span class=\"hljs-string\">--no-cache</span> <span class=\"hljs-string\">--target</span> <span class=\"hljs-string\">test</span> <span class=\"hljs-string\">.</span>\n        <span class=\"hljs-attr\">env:</span>\n          <span class=\"hljs-attr\">DOCKER_BUILDKIT:</span> <span class=\"hljs-number\">1</span>\n</code></pre>\n<p>빌드도 잘 되는지 확인하고 싶다면 빌드하는 job을 하나 더 추가하면 된다.</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">test</span>\n<span class=\"hljs-attr\">on:</span> <span class=\"hljs-string\">push</span>\n\n<span class=\"hljs-attr\">jobs:</span>\n  <span class=\"hljs-attr\">build:</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>\n    <span class=\"hljs-attr\">steps:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Set</span> <span class=\"hljs-string\">up</span> <span class=\"hljs-string\">Docker</span> <span class=\"hljs-string\">Buildx</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">docker/setup-buildx-action@v3</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">docker</span> <span class=\"hljs-string\">build</span> <span class=\"hljs-string\">--target</span> <span class=\"hljs-string\">build</span> <span class=\"hljs-string\">.</span>\n        <span class=\"hljs-attr\">env:</span>\n          <span class=\"hljs-attr\">DOCKER_BUILDKIT:</span> <span class=\"hljs-number\">1</span>\n\n  <span class=\"hljs-attr\">test:</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>\n    <span class=\"hljs-attr\">steps:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Set</span> <span class=\"hljs-string\">up</span> <span class=\"hljs-string\">Docker</span> <span class=\"hljs-string\">Buildx</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">docker/setup-buildx-action@v3</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Test</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">docker</span> <span class=\"hljs-string\">build</span> <span class=\"hljs-string\">--no-cache</span> <span class=\"hljs-string\">--target</span> <span class=\"hljs-string\">test</span> <span class=\"hljs-string\">.</span>\n        <span class=\"hljs-attr\">env:</span>\n          <span class=\"hljs-attr\">DOCKER_BUILDKIT:</span> <span class=\"hljs-number\">1</span>\n</code></pre>\n<h1 id=\"결론\">결론</h1>\n<p>Docker 이미지로 배포를 진행하는 경우, Docker로 테스트도 같이 진행하면 실제 배포 환경과 유사한 환경에서 테스트를 진행할 수 있다는 큰 장점이 있다. 따라서 복잡한 어플리케이션이라면 이 글을 참고해 Docker로 테스트도 같이 하는 것이 좋은 선택이 될 수 있다.</p>\n"}},"__N_SSG":true}