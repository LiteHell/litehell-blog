{"pageProps":{"article":{"metadata":{"title":"쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기","subtitle":"학교 캡스톤디자인 작품으로 장구 리듬게임 만든 이야기","author":"LiteHell","date":"2024-07-19T12:53:12.021Z","series":"bidrum","seriesName":"리듬게임 바이드럼 개발기","category":"Dev","tags":["Game"]},"rendered":"<h1 id=\"서문\">서문</h1>\n<p>문득 장구를 이용한 리듬 게임을 만들고 싶었다. 태고의 달인도 있는데 장구의 달인이 안 될 이유가 있을까? 그래서 군대 있을 때 계속 장구 게임을 상상만 하다가 복학하고 3학년 2학기에 캡스톤디자인 과목을 듣게 됐다.</p>\n<p>3학년 2학기 캡스톤디자인 과목에서 게임 아이디어를 제시했지만, 다른 팀원들은 리스크가 너무 크다고 반대했다. 지금 막 개강했는데 하드웨어 개발부터 시작하면 십중팔구 프로젝트가 망할 것이라는 지적이였다. 반박하기에는 너무나도 맞는 말이였다. 그래서 그냥 받아들이고 &quot;알고모여&quot;라는 웹 어플리케이션 프로젝트를 하게 됐다. 의외로 교수님의 평가가 계속 호평이여서 손쉽게 A+를 받았다.</p>\n<p>중앙대학교는 캡스톤디자인을 2번 해야 졸업이 가능하다. 그래서 4학년 1학기에도 캡스톤디자인을 해야 했는데, 이때 게임 아이디어를 다시 꺼내고 싶었다. 그러나 하드웨어도 없이 빈손으로 아이디어를 꺼낸다면 또다시 팀원들로부터 리스크 우려를 받을 것 같았다. 그래서 일단 프로토타이핑을 해서 설득해야 되겠단 판단이 들었다. 판단이 이루어졌으면 바로 실천해야 하지 않겠는가? 바로 당근마켓으로 45,000원짜리 어린이 장구를 샀고, 곧이어 아두이노랑 쿠킹호일, 그리고 몇가지 부품을 구매했다.</p>\n<h1 id=\"프로토타이핑\">프로토타이핑</h1>\n<h2 id=\"유선과-무선\">유선과 무선</h2>\n<p>내가 만드는 게임은 단순히 타격 여부만을 인식하지 않는다. &quot;어떤 채로 어떤 면이 타격됐는가&quot;를 인식한다. 즉, 다시 말해 열편으로 궁편을 친다면 &quot;궁편이 타격됐다&quot;라는 정보가 아닌 &quot;열편으로 궁편이 타격됐다&quot;라는 정보가 인식된다.</p>\n<p>이를 구현하려면 채에도 센서가 있어야 된다. 그리고 이 센서는 게임 본체랑 연결되어야 한다. 어떻게 연결한 것인가? 무선과 유선 두가지 방법이 있다.</p>\n<p>무선과 유선 각 두 가지 방법의 장단점은 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>무선</th>\n<th>유선</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>장점</td>\n<td>선이 걸리지 않음</td>\n<td>정확도가 매우 높고 딜레이가 낮음</td>\n</tr>\n<tr>\n<td>단점</td>\n<td>너무 낮은 정확도 및 높은 딜레이</td>\n<td>선이 걸리적거림</td>\n</tr>\n</tbody></table>\n<p>무선 통신은 정확도가 너무 낮다는 단점이 있다. 무선으로 채의 위치를 측정한다고 가정해보자. <a href=\"https://www.inpixon.com/technology/standards/ultra-wideband\">Inpixion</a>의 자료에서의 무선 위치 측정 시스템의 정확도와 레어턴시는 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>UWB</th>\n<th>Chirp (CSS)</th>\n<th>BLE</th>\n<th>Wi-Fi</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>정확도</td>\n<td>10~50 cm</td>\n<td>1~2m</td>\n<td>&lt; 5 m</td>\n<td>10 m</td>\n</tr>\n<tr>\n<td>레이턴시</td>\n<td>&lt; 1 ms</td>\n<td>&lt; 1 ms</td>\n<td>3~5s</td>\n<td>3~5s</td>\n</tr>\n</tbody></table>\n<p>정확도가 너무 낮아서 무선 위치 측정 시스템은 쓸 수가 없다. 블루투스와 와이파이는 레이턴시때문에 리듬게임 컨트롤러로 쓸 수조차 없다.</p>\n<p>&#39;그렇다면 무선이되 다른 방법을 쓰면 되는 것 아닌가?&#39;라는 생각이 들 수도 있는데, 내 머리로는 그렇게 할 수 있는 방법이 딱히 떠오르지 않았다. 그래서 그냥 유선으로 연결하기로 하고, 걸리적거리는 문제는 나중에 해결하기로 했다.</p>\n<h2 id=\"시분할\">시분할</h2>\n<p>자, 이제 유선으로 채의 종류를 인식하기로 했다. 장구는 두 개의 채와 두 개의 접촉면이 있다. 이 경우 가능한 경우의 수는 총 몇 가지인가? 답은 아래 표에서 볼 수 있듯 9가지이다. 두 개의 채로 하나의 접촉면을 동시에 치는 경우(아래 표에서 5번, 9번)도 고려해야 하므로 9가지이다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>궁채</th>\n<th>북채</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>2</td>\n<td>궁면</td>\n<td>X</td>\n</tr>\n<tr>\n<td>3</td>\n<td>북면</td>\n<td>X</td>\n</tr>\n<tr>\n<td>4</td>\n<td>X</td>\n<td>궁면</td>\n</tr>\n<tr>\n<td>5</td>\n<td>궁면</td>\n<td>궁면</td>\n</tr>\n<tr>\n<td>6</td>\n<td>북면</td>\n<td>궁면</td>\n</tr>\n<tr>\n<td>7</td>\n<td>X</td>\n<td>북면</td>\n</tr>\n<tr>\n<td>8</td>\n<td>궁면</td>\n<td>북면</td>\n</tr>\n<tr>\n<td>9</td>\n<td>북면</td>\n<td>북면</td>\n</tr>\n</tbody></table>\n<p>전기는 색깔이 없다. 접촉면에서 흐르는 전기가 궁채에서 흐르는 전기인지 북채에서 흐르는 전기인지 알 수 없다. 그렇다면 접촉면에 닿은 채가 어떤 채인지 어떻게 구분해야 할까? 필자는 FDM(주파수 분할)과 TDM(시분할)을 생각했다. 처음엔 FDM을 생각했었는데, 아두이노로 구현하기에는 난이도가 높을 것 같아 비교적 구현이 손쉬운 TDM으로 결정했다.</p>\n<h3 id=\"알고리즘\">알고리즘</h3>\n<p>시분할 알고리즘은 매우 단순하다.</p>\n<ol>\n<li>궁채에 전기를 흘리고 북채에 전기를 흘리지 않는다.</li>\n<li>북면에 전기가 흐르는 지 확인한다. 북면에 전기가 흐르면 궁채는 북면에 접촉하고 있다.</li>\n<li>궁면에 전기가 흐르는 지 확인한다. 궁면에 전기가 흐르면 궁채는 궁면에 접촉하고 있다.</li>\n<li>북채에 전기를 흘리고 궁채에 전기를 흘리지 않는다.</li>\n<li>북면에 전기가 흐르는 지 확인한다. 북면에 전기가 흐르면 북채는 북면에 접촉하고 있다.</li>\n<li>궁면에 전기가 흐르는 지 확인한다. 궁면에 전기가 흐르면 북채는 궁면에 접촉하고 있다.</li>\n<li>2, 3, 5, 6번에서의 정보를 종합하면 어떤 채가 어떤 접촉면에 접촉하고 있는 지 알 고 있다.</li>\n</ol>\n<p>이를 도식도로 나타내면 다음과 같다.</p>\n<p><img src=\"/img/bidrum/controller-algorithm.png\" alt=\"알고리즘의 도식도\"></p>\n<p>위를 실제 회로로 구현하기 위해서는 특정 회로를 신호로 열거나 닫을 수 있어야 한다.</p>\n<h3 id=\"릴레이\">릴레이</h3>\n<p>특정 회로를 신호로 열거나 닫는 대표적인 부품은 릴레이이다. 릴레이는 일종의 스위치 역할을 하는 부품으로, 전자석을 이용하여 회로를 열거나 닫는다.</p>\n<p><img src=\"/img/bidrum/relay.jpg\" alt=\"아두이노 릴레이 모듈 사진\"></p>\n<p>매우 직관적이고 만들기 쉬워서 처음에 릴레이를 시도했었다. 그러나 문제가 있었다. 릴레이는 딜레이가 너무 크고(5ms) 결정적으로 딱따구리 같은 소음이 난다. 위 알고리즘을 빠르게 무한반복해야 하는 특성상 릴레이 열고닫기를 반복하니 전자석 딱딱거리는 소리가 무한히 들리는 것이었다.</p>\n<h3 id=\"트랜지스터\">트랜지스터</h3>\n<p>그래서 주변 분들의 조언을 받아 트랜지스터를 이용했다. 주변 분께 딜레이가 1ms이하인 릴레이가 있나고 여쭤보니, 그 분께서 그런 릴레이는 없으니 트랜지스터를 쓰라고 답변해주신 것이 큰 도움이 됐다. 트랜지스터는 라디오 만들 때나(증폭) 쓰는 건 줄 알았는데 검색해보니 트랜지스터도 스위치처럼 쓸 수 있음을 알게 됐다.</p>\n<p>NPN 트랜지스터와 저항으로 약간의 시행착오를 겪으니 잘 인식됐다. 트랜지스터를 이용한 회로는 아래와 같다.</p>\n<p><img src=\"/img/bidrum/janggu_prototype_circuit_1.png\" alt=\"트랜지스터를 이용한 아두이노 컨트롤러 회로\"></p>\n<p>위 회로에서 궁채, 열채, 북편, 채편 기호는 각각의 부위에 붙은 전도체를 의미한다.</p>\n<h2 id=\"전도체\">전도체</h2>\n<p>전기가 흘려야 하니 채와 접촉면에는 전도체 물질을 부착해야 한다. 뭘 붙일까 고민하다가 <a href=\"https://blog.naver.com/b4crazy1/221481730264\">펌프 발판을 수작업으로 제작할 때 은박지를 이용했다는 글</a>이 생각났다. 그래서 다이소에서 쿠킹호일을 사다가 붙였다. 내구성은 썩 좋은 것 같진 않았지만 꽤 잘 인식됐다.</p>\n<p><img src=\"/img/bidrum/janggu_prototype_1.jpg\" alt=\"장구 컨트롤러 프토토타입 사진\"></p>\n<p>사진은 위와 같다. 사진에는 보이지 않지만, 장구의 면에도 은박지가 부착되어 있다.</p>\n<h1 id=\"결론\">결론</h1>\n<p>쿠킹호일과 NPN 트랜지스터, 저항, 그리고 아두이노를 이용해 장구 컨트롤러를 만들었다. 내구성은 썩 좋지 않았지만 인식은 잘 됐다. 2023년 겨울방학의 일이었다.</p>\n"},"articleId":"bidrum_and_janggu_controller_prototyping","series":[{"title":"쿠킹호일과 트랜지스터로 리듬게임 컨트롤러 만들기","articleId":"bidrum_and_janggu_controller_prototyping"},{"title":"Rust와 SDL2","articleId":"bidrum_on_rust"},{"title":"내 첫 특허 출원기","articleId":"my_first_patent"}],"seriesName":"리듬게임 바이드럼 개발기","previousPost":{"name":"show_all_slides_of_pptx_and_convert_to_pdf_batch_operation","metadata":{"title":"PPTX 파일 모든 슬라이드 숨김 해제하고 PDF 변환 일괄 작업하기","subtitle":"Python과 LibreOffice를 이용한 pptx 일괄 처리","author":"LiteHell","date":"2024-03-06T08:33:00.099Z","category":"Dev","tags":["Python"]},"rendered":"<h1 id=\"서문\">서문</h1>\n<p>이번 학기에 데이터베이스시스템 과목을 수강하게 됐다. 이 과목의 강의자료는 교재 홈페이지에서 제공하는 pptx 파일을 이용하는데, 숨김 처리된 슬라이드도 모두 활용한다. 따라서 숨겨진 슬라이드를 모두 숨김 해제해야 했다.</p>\n<p>파일이 한두개면 그냥 직접 숨겨진 슬라이드를 숨김 해제하면 된다. 하지만 강의가 시작되는 Chapter 12이후의 파일은 약 20개 정도였다. 물론 그 pptx들을 다 강의하진 않겠지만, 한두개의 파일이 아닐 것임은 확실했다.</p>\n<p>이걸 어떻게 하면 일괄처리할 수 있을까?</p>\n<h1 id=\"해결\">해결</h1>\n<h2 id=\"pptx-파일의-구조\">pptx 파일의 구조</h2>\n<p>pptx 파일은 zip 파일이다. pptx파일을 압축 프로그램을 열면 다음과 같은 구조를 볼 수 있다.</p>\n<p><img src=\"/img/show_all_slides_of_pptx_and_convert_to_pdf_batch_operation/pptx_zip_structure.png\" alt=\"pptx파일을 압축 프로그램 KDE Ark로 연 화면\"></p>\n<p><code>ppt/slides</code> 디렉토리 내의 xml 파일들이 슬라이드를 나타내는 xml 파일이다. 숨김 처리된 슬라이드의 xml 파일을 보면 다음과 같이 루트 요소의 <code>show</code> 속성이 <code>0</code>으로 설정되어 있음을 확인할 수 있다.</p>\n<p><img src=\"/img/show_all_slides_of_pptx_and_convert_to_pdf_batch_operation/hidden_slide_xml.png\" alt=\"숨겨진 slide를 나타내는 xml 파일의 상단\"></p>\n<p>그렇다면 <code>ppt/slides</code> 디렉토리 내의 xml 파일의 루트 요소에서 <code>show</code> 속성만 제거하면 되지 않을까?</p>\n<h2 id=\"python-스크립팅\">Python 스크립팅</h2>\n<p>python을 이용하면 기본으로 제공되는 라이브러리만으로 간단히 해결할 수 있다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-comment\">#!/bin/python3</span>\n<span class=\"hljs-keyword\">import</span> re\n<span class=\"hljs-keyword\">from</span> os <span class=\"hljs-keyword\">import</span> listdir\n<span class=\"hljs-keyword\">from</span> os.path <span class=\"hljs-keyword\">import</span> isfile, join\n<span class=\"hljs-keyword\">from</span> zipfile <span class=\"hljs-keyword\">import</span> ZipFile\n<span class=\"hljs-keyword\">import</span> xml.etree.ElementTree <span class=\"hljs-keyword\">as</span> ET\n\npptx_dir = <span class=\"hljs-string\">&quot;.&quot;</span>\n<span class=\"hljs-comment\"># pptx_dir 디렉토리 내에서 파일명이 .pptx로 끝나는 파일의 목록을 가져온다.</span>\npptx_files = [f <span class=\"hljs-keyword\">for</span> f <span class=\"hljs-keyword\">in</span> listdir(pptx_dir) <span class=\"hljs-keyword\">if</span> isfile(join(pptx_dir, f)) <span class=\"hljs-keyword\">and</span> f.endswith(<span class=\"hljs-string\">&quot;.pptx&quot;</span>)]\n<span class=\"hljs-comment\"># ppt/slides/*.xml 패턴을 검사하기 위한 정규표현식</span>\nslide_xml_filename_pattern = re.<span class=\"hljs-built_in\">compile</span>(<span class=\"hljs-string\">&quot;ppt/slides/[^/]+\\\\.xml&quot;</span>)\n\n<span class=\"hljs-keyword\">for</span> pptx_file <span class=\"hljs-keyword\">in</span> pptx_files:\n    print(<span class=\"hljs-string\">&quot;Processing pptx %s &quot;</span> % pptx_file)\n    <span class=\"hljs-comment\"># pptx파일을 zip 파일로 연다.</span>\n    <span class=\"hljs-keyword\">with</span> ZipFile(pptx_file, <span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-keyword\">as</span> zipfile:\n        <span class=\"hljs-comment\"># ppt/slides/*.xml 형태의 파일 목록을 가져온다.</span>\n        slide_xml_filenames = [i <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> zipfile.namelist() <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> slide_xml_filename_pattern.fullmatch(i) <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>]\n        <span class=\"hljs-keyword\">for</span> slide_xml_filename <span class=\"hljs-keyword\">in</span> slide_xml_filenames:\n            print(<span class=\"hljs-string\">&quot;Processing xml %s&quot;</span> % slide_xml_filename)\n            xml = <span class=\"hljs-literal\">None</span>\n            <span class=\"hljs-comment\"># xml을 파싱한다.</span>\n            <span class=\"hljs-keyword\">with</span> zipfile.<span class=\"hljs-built_in\">open</span>(slide_xml_filename, mode = <span class=\"hljs-string\">&#x27;r&#x27;</span>) <span class=\"hljs-keyword\">as</span> file:\n                xml = ET.parse(file)\n            <span class=\"hljs-comment\"># 루트 요소에 show 속성이 있다면 제거한다.</span>\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&quot;show&quot;</span> <span class=\"hljs-keyword\">in</span> xml.getroot().attrib:\n                xml.getroot().attrib.pop(<span class=\"hljs-string\">&quot;show&quot;</span>)\n            <span class=\"hljs-comment\"># 수정된 xml을 pptx 파일 내에 쓴다.</span>\n            <span class=\"hljs-keyword\">with</span> zipfile.<span class=\"hljs-built_in\">open</span>(slide_xml_filename, mode = <span class=\"hljs-string\">&#x27;w&#x27;</span>) <span class=\"hljs-keyword\">as</span> file:\n                xml.write(file)</code></pre>\n<p>위 스크립트는 디렉토리내의 pptx 파일을 열고, pptx 파일 내에서 파일명이 <code>ppt/slides/*.xml</code> 형태인 파일을 xml로 파상한 뒤, 루트 요소에서 <code>show</code> 속성을 삭제하고 다시 쓰는 것을 일괄 반복하는 스크립트이다.</p>\n<p>사용 시에는 <code>pptx_dir</code> 변수값만 필요에 따라 수정하여 쓰면 된다. 위 스크립트를 실행하면 <code>pptx_dir</code> 변수에 설정된 디렉토리 내에 있는 pptx 파일들에서 숨김 처리된 슬라이드를 모두 숨김 해제한다.</p>\n<h2 id=\"pptx-➡️-pdf-일괄-변환\">pptx ➡️ pdf 일괄 변환</h2>\n<p>필자는 OneNote를 쓰는데 OneNote는 인쇄물 삽입을 pdf나 docx로만 해야한다. 따라서 모든 pptx를 pdf로 변환할 필요가 있다.</p>\n<p>이건 쉽다. 그냥 <a href=\"https://www.libreoffice.org/\">LibreOffice</a> 명령어 한 줄이면 끝난다.</p>\n<pre><code class=\"hljs language-bash\">libreoffice --headless --convert-to pdf *.pptx</code></pre>\n<h1 id=\"결론\">결론</h1>\n<p>이상으로 여러개의 pptx 파일에서 숨김 처리된 슬라이드를 모두 일괄 숨김 해제하고 pdf로 일괄 변환하는 방법에 대해 알아보았다.</p>\n<p>다른 사람들에게 도움이 됐으면 좋겠다.</p>\n"},"nextPost":{"name":"bidrum_on_rust","metadata":{"title":"Rust와 SDL2","subtitle":"게임 개발에 Rust를 써보셨나요?","author":"LiteHell","date":"2024-08-11T14:35:24.968Z","category":"Dev","series":"bidrum","tags":["Game"]},"rendered":"<h1 id=\"들어가는-글\">들어가는 글</h1>\n<p><em>※ 참고: 이 시리즈의 글은 시간순 작성을 최대한 목표하고 있으나, 글의 짜임새나 가독성을 위해 미리시점이나 과거시점의 이야기가 섞이거나 순서가 일부 달라질 수 있습니다.</em></p>\n<p>내가 만들고 싶은 게임은 아케이드 리듬게임이였다. 마침 내 방에 라즈베리 파이(4B Rev 1.2)가 있어서, 라즈베리 파이로 게임을 구동하고 싶었다. Unity나 Unreal Engine으로 만든 게임이 라즈베리 파이 위에서 돌아갈까? 아마도 돌아가지 않을 것이다. 실제로 돌려본 적은 없지만 라즈베리 파이가 성능이 좋은 편은 아니니까.</p>\n<p>그래서 필자는 마침 <a href=\"https://www.rust-lang.org/\">Rust</a> 프로그래밍 언어를 한 번 써보고 싶은 생각도 있었기에, Rust로 직접 게임을 만들어보기로 결심했다. 게임 엔진을 쓰면 나중에 게임이 유명해졌을 때 라이선스비를 내야 한다는 것도 하나의 이유였다. (좀 과한 김칫국이긴 하지만...) 그래서 유니티니 언리얼이니 하는 게임 엔진을 쓰지 않고 Rust로 기초부터 쌓아올리기 시작했다.</p>\n<h1 id=\"sdl2를-이용한-게임-프로그래밍\">SDL2를 이용한 게임 프로그래밍</h1>\n<p>Rust에는 <a href=\"https://github.com/Rust-SDL2/rust-sdl2\">rust-sdl2</a>라는 라이브러리 바인딩이 있다. SDL2는 오디오, 키보드, 마우스, 그래픽, 조이스틱을 다를 수 있게 하는 크로스플랫폼 라이브러리이다. 즉, 그래픽이나 마우스 등에 대한 Direct3D/OpenGL 등의 운영체제/플랫폼 종속적인 API를 추상화하고 단일한 인터페이스로 통일하여 크로스 플랫폼으로 개발할 수 있게 하는 라이브러리이다.</p>\n<p>따라서 SDL2를 이용하면 Mac OS X/Windows/Linux에서 크로스플랫폼으로 실행할 수 있고, 라이브러리도 별로 무겁지 않다. 그래서 SDL2를 이용하게 됐다.</p>\n<h2 id=\"sdl2\">SDL2</h2>\n<p>SDL2는 rust-sdl 레포 내의 예제 코드를 보면서 따라하면 사용하기 쉽다. SDL2는 먼저 Window(창)을 만든 뒤, Window의 Canvas에 원하는 것을 그리고 렌더링하고 클리어하는 것을 반복한다. 이를 순서대로 나타내면 다음과 같다.</p>\n<blockquote>\n<p>(A) Window 생성 → (B) Window의 Canvas를 Clear한다 → (C) Canvas에 뭔가를 그린다. → (D) Window의 Canvas를 Present한다. → (E) 화면이 표시한다. → (F) B로 되돌아간다.</p>\n</blockquote>\n<p>학부 수준의 컴퓨터그래픽스 수업을 들었거나 OpenGL 프로그래밍을 조금이라도 맛보았다면 매우 이해하기 쉬울 것이다.</p>\n<p>SDL2는 키보드나 조이스틱 인식을 위한 EventPump 기능을 제공한다. 키보드 인풋이 들어오면 EventPump에 Event가 생성된다. 게임은 이 EventPump에 Event가 있는지 확인하여 만약 Event가 있다면 해당 Event의 데이터를 활용해 키보드 인풋을 처리할 수 있다. 게임 특성상 이 EventPump은 디버깅 용으로만 주로 이용됐다.</p>\n<h2 id=\"gamecommoncontext\">GameCommonContext</h2>\n<p>위에서 언급한 바에 같이 그래픽을 렌더링하기 위해서는 Canvas 객체에 대한 접근이 필요하다. 그래서 초기 게임 초기화시 Canvas와 Window, SDL Context 등을 담은 GameCommonContext 객체를 만들고 이를 함수간에 서로 주고받는 형태로 빠르게 게임을 구현했다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">use</span> kira::manager::AudioManager;\n<span class=\"hljs-keyword\">use</span> sdl2::{render::Canvas, EventPump, video::Window};\n\n<span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">GameCommonContext</span></span> {\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) coins: <span class=\"hljs-built_in\">u32</span>,\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) price: <span class=\"hljs-built_in\">u32</span>,\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) sdl_context: sdl2::Sdl,\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) audio_manager: AudioManager,\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) canvas: Canvas&lt;Window&gt;,\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) event_pump: EventPump,\n}</code></pre>\n<p>(속성은 나중에 게임이 개발되면 될 수록 더 늘어난다.)</p>\n<p>그리고 이는 추후 대규모 리팩토링으로 Rust의 특징을 온몸으로 깨닫는 계기가 됐다.... 나중에 소유권이랑 lifetime 문제가 미친 듯이 터져나와서 그거 씨름하느라 엄청 고생하게 됐다.</p>\n<h2 id=\"rust에서의-시리얼-통신\">Rust에서의 시리얼 통신</h2>\n<p>게임을 장구 하드웨어와 연동하기 위해서는 시리얼 통신이 필요하다.</p>\n<p>Arduino Leonardo 등 HID 에뮬레이션을 지원하는 보드가 있으면 장구 하드웨어에서 키보드 인풋을 주도록 할 수도 있다. 그런데 당장 내 방에 있는 게 Arduino UNO 호환보드(흔히 &quot;짭두이노&quot;라고 불리는 보드)밖에 없었다. 그래서 시리얼 통신으로 구현했다. 나중의 미래에 레오나르도 보드를 사서 키보드 인풋으로도 구현해보긴 했는데.... 딱따구리마냥 장구 채를 갖다대기만 해도 장구 채를 미친듯이 연타한 것마냥 동작하는 버그가 있어서 그냥 시리얼 통신을 계속 쓰게 됐다.</p>\n<p>Rust에서는 시리얼 통신을 어떻게 할까? 고맙게도 <a href=\"https://docs.rs/serialport/latest/serialport/\">serialport</a>라는 라이브러리가 있다. 이를 이용해 장구 하드웨어와의 시리얼 통신 코드를 작성했다. 그리고 장구 하드웨어로부터 인풋을 읽는 코드를 멀티쓰레딩으로 분리하고 <code>AtomicU8</code>을 이용하여 게임 쓰레드와 인풋 쓰레드 간에 장구 인풋 상태를 서로 공유했다.</p>\n<p>왜 뜬끔없이 <code>AtomicU8</code>이냐? 장구 컨트롤러의 상태를 나타내는 데에는 4개의 비트만 있으면 충분하다. 그래서 컨트롤러는 1바이트의 데이터를 무한히 연속적으로 보낸다. 이 1바이트를 해석하는 코드는 다음과 같다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">parse_janggu_bits</span></span>(bits: <span class=\"hljs-built_in\">u8</span>) -&gt; JangguState {\n    JangguState {\n        궁채: <span class=\"hljs-keyword\">if</span> bits &amp; <span class=\"hljs-number\">1</span> != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-literal\">Some</span>(DrumPane::채편)\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> bits &amp; <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-literal\">Some</span>(DrumPane::북편)\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-literal\">None</span>\n        },\n        북채: <span class=\"hljs-keyword\">if</span> bits &amp; <span class=\"hljs-number\">4</span> != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-literal\">Some</span>(DrumPane::채편)\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> bits &amp; <span class=\"hljs-number\">8</span> != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-literal\">Some</span>(DrumPane::북편)\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-literal\">None</span>\n        },\n    }\n}</code></pre>\n<p>장구 컨트롤러와 연동하는 쓰레드는 컨트롤러로부터 시리얼 통신으로 받은 데이터를 바로 <code>GameCommonContext</code> 개체의 <code>janggu_bits_ptr</code> 필드에 저장한다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">// ... (생략) ....</span>\n\n<span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">GameCommonContext</span></span> {\n   <span class=\"hljs-comment\">// ... (생략) ...</span>\n   <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) janggu_bits_ptr: Arc&lt;AtomicU8&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span> GameCommonContext {\n    <span class=\"hljs-keyword\">pub</span>(<span class=\"hljs-keyword\">crate</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">read_janggu_state</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; JangguState {\n        <span class=\"hljs-keyword\">return</span> parse_janggu_bits(\n            <span class=\"hljs-keyword\">self</span>.janggu_bits_ptr\n                .load(std::sync::atomic::Ordering::Relaxed),\n        );\n    }\n}\n</code></pre>\n<p>게임 쓰레드에서 장구의 상태를 확인할 때는 <code>read_janggu_state</code> 메소드를 이용한다.</p>\n<p>추후 미래에 <code>AtomicU8</code>을 없애고 Product-Consumer Lock으로 <code>JangguState</code> 객체를 직접 공유해보기도 했는데, 렉이 너무 심해서 그냥 <code>AtomicU8</code>을 계속 쓰게 됐다.</p>\n<h1 id=\"결론\">결론</h1>\n<p>Rust를 이용한 게임 개발은 초창기에는 할만했는데 뒤로 갈수록 어려웠다. 소유권, 대여, lifetime 문제를 해결하느라 골머리를 참 많이 썩었다. 그래서 결론적으로 짧은 기간 안에 게임을 개발해야 한다면 Rust는 별로 좋은 선택이 아니지 않을까라는 생각이 들었다.</p>\n"}},"__N_SSG":true}