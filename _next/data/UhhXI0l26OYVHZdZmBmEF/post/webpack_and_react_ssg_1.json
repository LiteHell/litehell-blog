{"pageProps":{"article":{"metadata":{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (1)","subtitle":"Webpack + TypeScript + React + TailwindCSS = TA-DA!","author":"LiteHell","date":"2023-01-10T05:00:48.244Z","series":"webpack_and_react_ssg","seriesName":"Webpack과 React를 이용한 정적 웹사이트 만들기","category":"Dev","tags":["React"]},"rendered":"<h1 id=\"들어가는-글\">들어가는 글</h1>\n<p>본래 <a href=\"https://litehell.info\">내 개인 웹사이트</a>는 <a href=\"https://nextjs.org/docs/advanced-features/static-html-export\">Next.js의 Static HTML Export 기능</a>과 <a href=\"https://pages.github.com/\">GitHub Pages</a>를 이용해 배포됐다. 디자인에는 <a href=\"https://bulma.io\">bulma CSS 프레임워크</a>를 이용했다.</p>\n<p><img src=\"/img/homepage_before_redesign_2022.png\" alt=\"홈페이지 재디자인 전의 이미지\"></p>\n<p>위와 같이 bulma에서 제공하는 component들을 이용해 간단하게 디자인했다.</p>\n<p>그러나 내 웹사이트를 몇 번 보다보니 디자인을 좀 설렁설렁하게 한 느낌이 들었다. 그래서 디자인을 한 번 바꿔보고 싶었고, 이번 기회에 Next.js를 쓰지 않고 직접 정적 파일로 배포하는 경험도 해보고 싶었다.</p>\n<p>이 글은 개인 홈페이지를 재작성한 경험에 기반하여 쓰는 글이지만, 독자들이 따라하며 참고할 수 있도록 일부 변형하여 작성했다. 설명을 최대한 자세하게 하려 노력했지만, 글 쓰는 실력이 좋은 편이 아니라 읽기 불편할 수 있으니 양해해주셨으면 좋겠다.</p>\n<h1 id=\"webpack과-babel-그리고-typescript\">Webpack과 Babel, 그리고 Typescript</h1>\n<p>Next.js는 쓰지 않았다. 간단한 한 페이지 정적 페이지 만드는 데에는 Webpack이면 충분하다.</p>\n<p>이제 어떤 기술스택을 쓸 지 정했다, 이제 필요한 의존성을 먼저 설치하면 된다. 의존성을 한 번 설치해보자.</p>\n<h2 id=\"의존성-설치하기\">의존성 설치하기</h2>\n<p>먼저 React와 Typescript를 설치한다. 재디자인 전에 했듯이 이번에도 React로 개발할 것이다.</p>\n<pre><code class=\"hljs language-bash\">yarn add react-dom react\nyarn add --dev typescript react @types/react @types/react-dom</code></pre>\n<p>그 다음, 다음 명령어로 tsconfig.json을 생성한다.</p>\n<pre><code class=\"hljs language-bash\">npx tsc --init</code></pre>\n<p>생성된 tsconfig.json에서 <code>jsx</code> 속성을 <code>react</code>로(다르게 해도 되긴 한데 나는 이렇게 했다), 그리고 <code>moduleResolution</code> 속성은 <code>node</code>로 바꾸어야 한다. 이 외에 나머지 속성들은 개인 취향대로 하면 된다. 일단 개인 취향대로 하고 나중에 코딩하다 <code>tsconfig.json</code>때문에 오류나면 그때 수정하면 된다.</p>\n<p>참고로 내 <code>tsconfig.json</code>는 다음과 같다.</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">&quot;compilerOptions&quot;</span>: {\n    <span class=\"hljs-attr\">&quot;target&quot;</span>: <span class=\"hljs-string\">&quot;es2016&quot;</span>,\n    <span class=\"hljs-attr\">&quot;lib&quot;</span>: [<span class=\"hljs-string\">&quot;DOM&quot;</span>],\n    <span class=\"hljs-attr\">&quot;jsx&quot;</span>: <span class=\"hljs-string\">&quot;react&quot;</span>,\n    <span class=\"hljs-attr\">&quot;module&quot;</span>: <span class=\"hljs-string\">&quot;ESNext&quot;</span>,\n    <span class=\"hljs-attr\">&quot;moduleResolution&quot;</span>: <span class=\"hljs-string\">&quot;node&quot;</span>,\n    <span class=\"hljs-attr\">&quot;typeRoots&quot;</span>: [<span class=\"hljs-string\">&quot;node_modules/@types&quot;</span>, <span class=\"hljs-string\">&quot;src/types&quot;</span>],\n    <span class=\"hljs-attr\">&quot;allowJs&quot;</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">&quot;checkJs&quot;</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">&quot;allowSyntheticDefaultImports&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;strict&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;noImplicitAny&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;strictNullChecks&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;strictFunctionTypes&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;alwaysStrict&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;noUnusedLocals&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;noUnusedParameters&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">&quot;skipLibCheck&quot;</span>: <span class=\"hljs-literal\">true</span>\n  },\n  <span class=\"hljs-attr\">&quot;include&quot;</span>: [<span class=\"hljs-string\">&quot;src/**/*.tsx&quot;</span>, <span class=\"hljs-string\">&quot;src/**/*.ts&quot;</span>],\n  <span class=\"hljs-attr\">&quot;exclude&quot;</span>: [<span class=\"hljs-string\">&quot;node_modules&quot;</span>]\n}\n</code></pre>\n<p>그 다음으로는 Webpack이 필요하다. 다음 명령어로 Webpack을 추가하자.</p>\n<pre><code class=\"hljs language-bash\">yarn add webpack webpack-cli\nyarn add --dev webpack-dev-server ts-loader style-loader clean-webpack-plugin css-loader html-webpack-plugin</code></pre>\n<p>각 패키지들의 설명은 다음과 같다.</p>\n<ul>\n<li><code>webpack</code>, <code>webpack-cli</code> : Webpack이다. 설명이 필요없다.</li>\n<li><code>webpack-dev-server</code> : 수정이 되면 자동으로 webpack 재빌드해서 새로고침되는 웹 서버를 열기 위해 이용한다. 디버깅이 편해진다.</li>\n<li>webpack loader: Webpack에서 특정 유형의 파일을 불러오거나 변형한다.<ul>\n<li><code>ts-loader</code>: <code>.ts</code>나 <code>.tsx</code>파일을 Webpack에서 읽을 때 쓴다.</li>\n<li><code>css-loader</code>: css 파일에서 <code>@import</code>나 <code>url()</code> 구절들을 <code>import/require()</code>와 같은 식으로 해석하는 loader다.</li>\n<li><code>style-loader</code>: css를 웹페이지에 추가하는 loader다</li>\n</ul>\n</li>\n<li>webpack plugin<ul>\n<li><code>clean-webpack-plugin</code>: 출력 디렉토리내 파일들을 삭제하는 플러그인이다.</li>\n<li><code>html-webpack-plugin</code>: 생성된 js 파일의 스크립트 태그들이 추가된 html파일을 자동으로 생성한다</li>\n</ul>\n</li>\n</ul>\n<p>나는 이번에 babel을 쓸 것이다. babel은 최신 버전의 자바스크립트 기능을 브라우저 지원에 신경쓰지 않고 쓸 수 있게 해준다. 아래 명령어로 babel도 설치하자.</p>\n<pre><code class=\"hljs language-bash\">yarn add --dev @babel/core @babel/preset-env @babel/preset-react babel-loader</code></pre>\n<p><a href=\"https://tailwindcss.com/\">TailwindCSS</a>가 웹사이트 빠르게 만드는 데 좋다갈래 반신반의하는 느낌으로 한 번 써보려 한다. TailwindCSS를 쓰려면 다음 패키지들을 설치해야 한다.</p>\n<pre><code class=\"hljs language-bash\">yarn add --dev autoprefixer postcss postcss-loader tailwindcss</code></pre>\n<h2 id=\"webpack-설정하기\">Webpack 설정하기</h2>\n<p>이제 Webpack을 설정해야 한다. 루트 디렉토리에 <code>webpack.config.js</code>를 생성하고 내용을 다음과 같이 한다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack.config.js</span>\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> HtmlWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;html-webpack-plugin&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> { CleanWebpackPlugin } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;clean-webpack-plugin&#x27;</span>);\n\n<span class=\"hljs-keyword\">const</span> dev = process.env.NODE_ENV === <span class=\"hljs-string\">&#x27;development&#x27;</span>;\n<span class=\"hljs-built_in\">module</span>.exports = {\n    <span class=\"hljs-comment\">// 개발시라면 개발 모드로 한다.</span>\n    <span class=\"hljs-attr\">mode</span>: dev ? <span class=\"hljs-string\">&quot;development&quot;</span> : <span class=\"hljs-string\">&quot;production&quot;</span>,\n    <span class=\"hljs-attr\">optimization</span>: {\n      <span class=\"hljs-attr\">splitChunks</span>: {\n        <span class=\"hljs-comment\">// 청크를 가능한만큼 다 분리한다.</span>\n        <span class=\"hljs-comment\">// 파일 각각의 용량을 줄여들어서 웹페이지 로드속도 감소에 도움이 된다.</span>\n        <span class=\"hljs-attr\">chunks</span>: <span class=\"hljs-string\">&#x27;all&#x27;</span>\n      },\n      <span class=\"hljs-comment\">// 개발중이 아니라면 압축한다.</span>\n      <span class=\"hljs-attr\">minimize</span>: !dev\n    },\n    <span class=\"hljs-comment\">// 진입 파일이다.</span>\n    <span class=\"hljs-comment\">// ./src/index.tsx 파일에 필요한 모듈들을 번들링한다고 이해하면 된다.</span>\n    <span class=\"hljs-comment\">//</span>\n    <span class=\"hljs-comment\">// 즉, 다시 말해 출력파일을 실행하면 ./src/index.tsx을 실행하는 것과 동일한 효과를 가진다,</span>\n    <span class=\"hljs-comment\">// 다만 필요한 모듈들이 같이 번들링되어 있어 웹 환경 등에서도 실행이 용이할 뿐이다.</span>\n    <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&#x27;./src/index.tsx&#x27;</span>,\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.resolve(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),\n        <span class=\"hljs-comment\">// index.js로 하면 splitChunks 속성때문에 오류가 난다.</span>\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;[name].js&#x27;</span>\n    },\n    <span class=\"hljs-attr\">resolve</span>: {\n        <span class=\"hljs-attr\">extensions</span>: [<span class=\"hljs-string\">&#x27;.tsx&#x27;</span>, <span class=\"hljs-string\">&#x27;.ts&#x27;</span>, <span class=\"hljs-string\">&#x27;.js&#x27;</span>, <span class=\"hljs-string\">&#x27;.css&#x27;</span>]\n    },\n    <span class=\"hljs-attr\">module</span>: {\n        <span class=\"hljs-attr\">rules</span>: [\n            <span class=\"hljs-comment\">// 참고: use 속성은 마지막 아이템에서 첫 아이템으로의 순서, 즉 다시 말해 오른쪽에서 왼쪽으로의 순서로 해석된다.</span>\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.tsx?$/</span>,\n                exclude: <span class=\"hljs-regexp\">/node_modules/</span>,\n                use: [\n                    <span class=\"hljs-comment\">// Babel은 현대 자바스크립트를 브라우저 지원여부을 고려할 필요없이 쓸 수 있도록 해준다.</span>\n                    {\n                        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;babel-loader&#x27;</span>,\n                        <span class=\"hljs-attr\">options</span>: {\n                            <span class=\"hljs-attr\">presets</span>: [<span class=\"hljs-string\">&#x27;@babel/preset-react&#x27;</span>, <span class=\"hljs-string\">&#x27;@babel/preset-env&#x27;</span>]\n                        }\n                    },\n                    <span class=\"hljs-comment\">// Typescript를 Javascript로 컴파일해준다.</span>\n                    <span class=\"hljs-string\">&#x27;ts-loader&#x27;</span>\n                ]\n            },\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n                <span class=\"hljs-comment\">// postcss-loader는 TailwindCSS 적용에 이용된다.</span>\n                use: [<span class=\"hljs-string\">&#x27;style-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>]\n            }\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        <span class=\"hljs-comment\">// 빌드전에 dist 디렉토리내 파일들을 먼저 지우고 </span>\n        <span class=\"hljs-keyword\">new</span> CleanWebpackPlugin(),\n        <span class=\"hljs-comment\">// 빌드후 출력파일들이 script태그로 포함된 html파일을 생성한다.</span>\n        <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;Yeonjin Shin&#x27;</span>,\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>\n    })],\n    <span class=\"hljs-comment\">// 디버깅할 때 쓰는 웹서버에 관한 설정이다.</span>\n    <span class=\"hljs-comment\">// webpack serve로 열 수 있다.</span>\n    <span class=\"hljs-attr\">devServer</span>: {\n        <span class=\"hljs-attr\">static</span>: {<span class=\"hljs-attr\">directory</span>: path.join(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>)},\n        <span class=\"hljs-attr\">open</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">port</span>: <span class=\"hljs-string\">&#x27;auto&#x27;</span>,\n    },\n    <span class=\"hljs-comment\">// 이거 안하면 node_modules내 수 많은 파일의 변경여부도 같이 확인하기 때문에</span>\n    <span class=\"hljs-comment\">// 디버깅용 웹서버가 정상적으로 작동하지 않는다.</span>\n    <span class=\"hljs-attr\">watchOptions</span>: {\n        <span class=\"hljs-attr\">ignored</span>: <span class=\"hljs-regexp\">/node_modules/</span>\n    }\n}</code></pre>\n<h2 id=\"tailwindcss-설정하기\">TailwindCSS 설정하기</h2>\n<p>TailwindCSS를 적용하려면 TailwindCSS 설정파일을 생성해야 한다. TailwindCSS 설정 파일은 다음 명령어로 생성할 수 있다. <code>-p</code> 매개변수를 주면 PostCSS 설정파일도 같이 생성해준다.</p>\n<pre><code class=\"hljs language-bash\">npx tailwindcss init -p</code></pre>\n<p><code>postcss.config.js</code>는 생성된 그대로 쓰면 되고, <code>tailwind.config.js</code>만 수정하면 된다. <code>tailwind.config.js</code>에 <code>content</code> 속성에 TailwindCSS를 사용할 파일 패턴을 넣는다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// tailwind.config.js</span>\n<span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">{import(&#x27;tailwindcss&#x27;).Config}</span> </span>*/</span>\n<span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">content</span>: [<span class=\"hljs-string\">&quot;./src/**/*.{js,css,ts,tsx}&quot;</span>],\n  <span class=\"hljs-attr\">theme</span>: {\n    <span class=\"hljs-attr\">extend</span>: {},\n  },\n  <span class=\"hljs-attr\">plugins</span>: [],\n}</code></pre>\n<p>이제 TailwindCSS를 쓰기 위해 한 가지만 더 하면 된다. 다음과 같이 <code>@tailwind</code> 구문들이 들어간 css파일을 생성하고, 그 css 파일을 프론트엔드 코드에서 추가해주면 된다.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/* styles/index.css */</span>\n\n<span class=\"hljs-keyword\">@tailwind</span> base;\n<span class=\"hljs-keyword\">@tailwind</span> components;\n<span class=\"hljs-keyword\">@tailwind</span> utilities;\n\n<span class=\"hljs-comment\">/* ...more css here */</span></code></pre>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// src/index.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;../styles/index.css&#x27;</span>;\n<span class=\"hljs-comment\">// ...more imports and code here</span></code></pre>\n<p>TailwindCSS가 추가하는 CSS 코드는 PostCSS와 <code>postcss-loader</code>에 의해 CSS 파일에 자동으로 추가된다. 그리고 그 CSS 파일은 위와 같이 import만 해주면 <code>style-loader</code>에 의해 웹브라우저에서 html에 자동으로 추가된다.</p>\n<p>이제 TailwindCSS, Webpack, React를 쓰기 위한 준비가 끝났다. 코딩만 하면 된다.</p>\n<h2 id=\"코딩\">코딩</h2>\n<p>아래와 같이 코드를 작성해보자.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/index.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom/client&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;../styles/index.css&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Index</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;bg-gray-400&quot;</span>&gt;</span>\n      Hello, World!\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n}\n\n<span class=\"hljs-keyword\">const</span> rootDiv = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&#x27;div&#x27;</span>);\n<span class=\"hljs-built_in\">document</span>.body.appendChild(rootDiv);\n<span class=\"hljs-keyword\">const</span> root = ReactDOM.createRoot(rootDiv);\nroot.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Index</span> /&gt;</span></span>)</code></pre>\n<p>이렇게 하고 <code>npx webpack build</code>하면 잘 빌드될 것이다. <code>dist/index.html</code> 파일을 웹 브라우저로 열였을 때 &quot;Hello, World!&quot;가 뜨면 정상이다.</p>\n<p>위와 같은 식으로 코딩하면 된다. 개발할 때는 <code>npx webpack serve</code>로 웹 서버를 열면 편하게 디버깅할 수 있다.</p>\n"},"articleId":"webpack_and_react_ssg_1","series":[{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (1)","articleId":"webpack_and_react_ssg_1"},{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (2)","articleId":"webpack_and_react_ssg_2"},{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (3)","articleId":"webpack_and_react_ssg_3"}],"seriesName":"Webpack과 React를 이용한 정적 웹사이트 만들기","previousPost":{"name":"retrospective_of_2022","metadata":{"title":"2022년의 회고","subtitle":"군대와 전역","author":"LiteHell","date":"2023-01-08T15:01:25.655Z","category":"Life","tags":["Retrospective"]},"rendered":"<h1 id=\"들어가는-말\">들어가는 말</h1>\n<p>대단한 성취를 이루지도 못했는데 벌써 2022년이 다 지나갔다. 올해는 다르리라 다짐하는 의미에서 2022년에 무엇을 했는지 되짚어보고자 한다.</p>\n<h1 id=\"부대안에서\">부대안에서</h1>\n<p>군대에서만큼은 잠시 코딩을 쉬고 싶었다. 그래서 부대에서 코딩을 열심히 하진 않았는데, 그럼에도 불구하고 휴식을 제대로 취하진 못했다. 아무래도 밖에 자유롭게 못 나가는 것에, 군대 특유의 통제도 있었고, 또 교대근무를 하다보니 몸이 피로했다. 육체적으로 힘든 일을 하진 않았지만, 모든 사람에게 군대가 그렇듯 다시 하고 싶은 경험은 아니었다. 그래서 그런지 쉬어가는 텀이 되진 못했다.</p>\n<p>내가 부대에서 목표로 한 것은 딱 3가지였다: 자격증, 그림, 운동. 운동은 게을려서 하지 못했지만 나머지 2개는 이뤘다. 그림 연습을 거의 매일 하는데 성공했고, 자격증도 취득했다.</p>\n<h2 id=\"정보처리산업기사-취득2021\">정보처리산업기사 취득(2021)</h2>\n<p>2021년 12월 31일에 정보처리산업기사를 취득했다. </p>\n<p>군내시험이라 필기를 CBT가 아닌 OMR 마킹형식으로 했다. (실기는 사회와 똑같이 필답형이다.) 개정된 산업기사 시험이었는데, 난이도는 그리 어렵진 않았다. 알고리즘 문제가 순서도 그림이 아닌 코드 형태로 나와서 오히려 편했다.</p>\n<p>공군은 산업기사를 취득하면 휴가 1일(정확히는 휴가 하루치의 병영생활 가점)을 준다. 덕분에 휴가 하루 받아서 잘 다녀왔다.</p>\n<p>원래 2021년 회고에 들어갈 내용이지만, 어떤 이유에선지 까먹고 안 썼길래 이번 회고에 썼다.</p>\n<h2 id=\"상공회의소-한자-3급-취득\">상공회의소 한자 3급 취득</h2>\n<p>2022년 3월에 상공회의소 한자 3급을 취득했다. <a href=\"https://www.cau.ac.kr/cms/FR_CON/index.do?MENU_ID=130&amp;P_TAB_NO=7&amp;TAB_NO=3\">중앙대학교는 졸업필수요건으로 모든 재학생에게 한자급수 3급 이상(예체능은 4급 이상)을 취득한 것을 요구한다.</a> 졸업을 하려면 좋든 싫든 한자 자격증을 따거나 한자 관련 교양 수업 2개이상을 들어야 한다.</p>\n<p>내 주변 사람들 중에서는 <a href=\"https://www.cau.ac.kr/cms/FR_CON/BoardView.do?MENU_ID=100&amp;CONTENTS_NO=2&amp;SITE_NO=2&amp;BOARD_SEQ=4&amp;BOARD_CATEGORY_NO=26&amp;BBS_SEQ=23797&amp;P_TAB_NO=2\">군 e-러닝</a>으로 한자 교양을 듣는 사람이 꽤 있었다. 졸업요건도 채우고 성적 잘 받으면 휴가도 받으니 1석2조다. 그러나 난 그러진 않았다. 첫번째 이유로는 학점을 이미 많이 들었고 두번째 이유로는 최대한 빠르게 끝내고 싶었다.</p>\n<p>그래서 <a href=\"https://book.eduwill.net/goods/select.action?goodsId=0100003113\">에듀윌 상공회의소 한자 3급 2주끝장</a>을 사서 일단 4급 한자 900자만 공부했다. (3급 900자는 몰라도 합격하는 데 지장없다.) 근데 완벽하게 외우지 않고 대충 외우고 갔더니 떨어졌다.</p>\n<p>비록 <a href=\"https://www.mnd.go.kr/user/boardList.action?boardId=I_4492133&amp;siteId=mnd&amp;cboardType=02&amp;boardSeq=I_8637767&amp;command=albumView&amp;warningYn=N&amp;id=mnd_020701000000\">장병 자기개발비 지원사업</a>으로 시험비용을 일부 환급받긴 했지만 돈이 아까웠다. 그래서 이번에는 <a href=\"https://quizlet.com/\">Quizlet</a> 앱과 책을 같이 병행하여 확실하게 공부했다.</p>\n<p>앱을 이용하니 확실히 외우는 데 큰 도움이 됐다. 퀴즐렛에 카드를 좌우로 넘기면서 학습하는 기능이 있는데, 이 기능은 가물가물하던 한자를 다시 외우는 데 탁월한 효과가 있다.</p>\n<p>위와 같이 한자를 반복적으로 외우고 인터넷에 올라온 기출문제들을 다 받아서 풀며 열심히 준비했다. 그렇게 열심히 공부하여 2022년 3월 17일날 시험을 봤고, 그 결과 당당하게 합격했다.</p>\n<h2 id=\"개발\">개발</h2>\n<p>위에서 코딩 안했다고 했는데, 아예 안하진 않았다. 부대사 사이버지식정보방에서 <a href=\"https://github.com/features/codespaces\">GitHub Codespaces</a>를 이용해 어느정도 개발을 했다.</p>\n<p>군 복무중일때는 주로 <a href=\"https://github.com/ManhwaDure\">만화동아리</a> 사이트들의 버그를 고치는 데 주력했다. 그 외에도 나는 개인적으로 싼 서버를 개인서버로 쓰는데 Docker가 쓰는 용량을 줄이기 위해 3월에 Docker 이미지들을 전부 다 alpine 기반으로 바꾸기도 했다. 이 블로그의 RSS/Atom/Json 피드와 <a href=\"https://ogp.me/\">OpenGraph</a> 코드도 3월에 추가된 것이다.</p>\n<h3 id=\"fullcards\">fullcards</h3>\n<p><a href=\"https://github.com/ManhwaDure/fullcards\">fullcards</a>는 <a href=\"https://caumd.club\">만화동아리 홈페이지</a>를 만드는 데 이용되는 웹 어플리케이션이다.</p>\n<p>4월에 해당 프로젝트를 정적 파일을 생성하는 형태로 바꾸려고 시도했다가 Nextjs 프레임워크 위에서 하려니 자꾸 꼬여서 포기하기도 했다. 이 건은 지금 다시 재시도하고 있다.</p>\n<p>5월에는 <a href=\"https://firebase.google.com\">Firebase</a>를 제거하고 <a href=\"https://typeorm.io\">TypeORM 라이브러리</a>를 이용해 <a href=\"https://mariadb.org/\">MariaDB</a> 기반으로 전환했다. 기존에 Firebase를 쓸 때는 홈페이지 초반에 로딩이 잠깐 걸렸는 데 그걸 없애고 싶었다.</p>\n<p>Firebase에서 다른 데이터베이스로 마이그레이션하기는 귀찮았다. 그래서 처음에 서버사이드에서 Firebase 데이터를 받아서 주는 방식을 시도해봤는데, 끔찍하게 느렸다. 따라서 그냥 Firebase를 제거하고 서버에서 홈페이지를 렌더링할때 사이트 데이터를 함께 주는 방식으로 진행했다.</p>\n<p>지금은 로딩이 반짝 뜨긴 하지만, 전에 비하면 확실히 개선됐다. 이 반짝 뜨는 현상도 추후 수정 예정이다.</p>\n<h1 id=\"말년휴가\">말년휴가</h1>\n<p>9월 말에 말년휴가를 나왔다. 확실히 좋았다. 중간에 부대 잠깐 찍고 다시 휴가나오기만 몇 번하면 되니, 사실상 민간인이었다.</p>\n<p>이때부터 연말까지 코딩을 꽤 많이 했다. fullcards의 에디터도 <a href=\"https://github.com/zenoamaro/react-quill\">react-quill</a>에서 <a href=\"https://ui.toast.com/tui-editor\">TOAST UI Editor</a>로 바꾸었고, 특히 <a href=\"https://github.com/LiteHell/theseed-skin-buma\">theseed-skin-buma</a>의 개발을 집중적으로 했다. 기존에 존재하던 버그들을 거의 다 수정하고, 이 과정에서 <a href=\"https://github.com/Tenpower\">Tenpower</a>님의 큰 도움을 받았다.</p>\n<p>11월에 <a href=\"https://flutter.dev/\">Flutter</a>에 관심이 생겨서 공부를 시작했다. React와 Vue를 둘 다 해본 사람이라 그런지 입문하고 이해하는 데 큰 어려움은 겪지 못했다. <a href=\"https://blog.litehell.info/post/review_of_gdg_songdo_devfest_songdo_2022\">GDG Songdo Devfest도 이때 다녀왔다.</a></p>\n<h1 id=\"전역\">전역</h1>\n<p>12월 중에 전역했다. 말년휴가를 나가있던 사람이라 그런지 막 대단한 감흥을 느끼진 못했다.</p>\n<p>12월(정확히는 11월 30일)에는 <a href=\"https://flutter.dev\">Flutter</a> 공부도 할 겸 <a href=\"http://reference.sketchdaily.net/\">SketchDaily reference</a> 모바일 앱의 개발을 시작했다. 사이트 주인분께 허락도 받았고 아는 분께 앱 디자인도 부탁드렸다. 플레이스토어에 직접 배포해본 적이 없었는데, 이번 개발을 통해 한 번 해보고 싶다.</p>\n<h1 id=\"다짐\">다짐</h1>\n<p>올해는 열심히 살 것이다. 코딩테스트를 준비하고, 전공공부에 집중할 것이다. 그리하여 마지막에 노력과 행운을 합쳐 좋은 기업에 취업하고 싶다.</p>\n"},"nextPost":{"name":"webpack_and_react_ssg_2","metadata":{"title":"Webpack과 React를 이용한 정적 웹사이트 만들기 (2)","subtitle":"... + Static HTML Generation = TA-DA!","author":"LiteHell","date":"2023-01-10T05:00:54.358Z","category":"Dev","series":"webpack_and_react_ssg","tags":["React"]},"rendered":"<h1 id=\"들어가는-글\">들어가는 글</h1>\n<p>1편에서와 같이 개발하면 매우 잘 된다, 구조가 단순하기 때문이다. 1편의 방식을 개발했을 때 빌드된 결과물을 보면 다음과 같이 생겼을 것이다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- dist/index.html --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 참고로 이 예시는 예시일뿐이며, 세부사항은 개개인의 상황에 따라 다를 수 있다. --&gt;</span>\n<span class=\"hljs-meta\">&lt;!doctype <span class=\"hljs-meta-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Lorem ipsum<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">defer</span>=<span class=\"hljs-string\">&quot;defer&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;166.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">defer</span>=<span class=\"hljs-string\">&quot;defer&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;main.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n<p>1편에서 번들링된 파일이 script 태그로 삽입되어 HTML 문서가 불려와진 후 모두 끝난 후 실행되는 형태이다. (<code>defer</code>속성은 스크립트가 문서 분석 이후에 실행되도록 한다.)</p>\n<p>즉, <strong>CSR(Client-Side Rendering)</strong> 방식이다. body 태그 내에 div 태그를 만들고 해당 태그에 React Component를 렌더링하는 코드가 클라이언트단에서 모두 실행되는 방식이다. 빌드 단계에서 렌더링이 이루어지지 않으며, 빌드 단계에서 이루어지는 것은 오직 코드 번들링뿐이다.</p>\n<p>리소스가 한 번만 로드되고 후속 페이지 로드시간이 빠르다는 장점이 있지만 몇가지 단점도 있다.</p>\n<ul>\n<li>SEO(검색 엔진 최적화)에 불리하다.</li>\n<li>초기 페이지 로드시간이 느리며, 다 로드되기 전까진 흰 화면만 뜬다. (필요한 JavaScript와 CSS를 다 불러와야 하기 때문이다.)</li>\n</ul>\n<p>이러한 단점들을 극복하려면 어떻게 해야할까?</p>\n<h2 id=\"with-react-hydration\">with React Hydration</h2>\n<p>빌드시에 초기 HTML을 생성하고, 진입 스크립트을 hydration을 하는 방식으로 수정하면 된다. 여기서 hydration이란 ReactDOMServer에 의해 렌더링된 초기 마크업 코드에 이벤트 리스너를 연결(즉, 요약하자면 재활용)하는 것이다.</p>\n<p>이 방식을 이용하면 HTML 마크업 코드는 빌드 단계에서 생성되고, 클라이언트단에서는 React가 이미 생성된 HTML 코드에 부착(attach)하여 동작한다. 이 방식의 장점은 다음과 같다.</p>\n<ul>\n<li>SEO(검색 엔진 최적화)에 유리하다.</li>\n<li>JavaScript와 CSS가 다 불려와지기 전까지 흰화면만 뜨는 현상을 수정할 수 있다.</li>\n</ul>\n<p>이 방식을 채택하기 전에 먼지 어떤 사항을 확인해야 하는지 한 번 알아보자.</p>\n<h3 id=\"유효한-html코드-작성\">유효한 HTML코드 작성</h3>\n<p>모든 HTML 코드는 유효하게 작성되어야 한다. 예시를 들자면, p태그 안에는 p태그가 들어갈 수 없다.</p>\n<p>React hydration을 하기 위해서는, 빌드단에서 생성된 HTML 코드와 React Component가 생성하는 UI 코드가 일치해야 한다. 만약 초기 UI 불일치 오류가 나타난다면, 유효하지 않은 HTML 코드를 작성한 건 아닌지 한 번 확인해봐야 한다.</p>\n<h3 id=\"클라이언트단에서만-작동하는-코드-수정\">클라이언트단에서만 작동하는 코드 수정</h3>\n<p>Node.js 환경에서 실행되면 오류가 나는 코드가 있다. 이런 코드들은 브라우저 환경에서만 실행되도록 수정해야 한다.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// 예시</span>\n\n<span class=\"hljs-keyword\">const</span> isBrowser = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">window</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">document</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span>\n\n<span class=\"hljs-keyword\">if</span> (isBrowser())\n    <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;../some_module_that_works_only_on_browser&#x27;</span>);</code></pre>\n<p>또한, 브라우저단에서 결과가 결정되거나 항상 일정하지 않은 코드는 <code>useEffect</code> 등을 이용해 UI가 렌더링된 이후에 실행되도록 수정해야 한다. \n<code>useState</code>와 <code>useEffect</code> 등은 브라우저단에서만 렌더링된다.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> { useState, useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-comment\">// 예시</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">AreYouKorean</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// const isKorean = navigator.language === &#x27;ko&#x27;;</span>\n    <span class=\"hljs-keyword\">const</span> [isKorean, setIsKorean] = useState&lt;<span class=\"hljs-built_in\">boolean</span> | <span class=\"hljs-literal\">null</span>&gt;(<span class=\"hljs-literal\">null</span>);\n    useEffect(<span class=\"hljs-function\">() =&gt;</span> {\n        setIsKorean(navigator.language === <span class=\"hljs-string\">&#x27;ko&#x27;</span>);\n    });\n\n    <span class=\"hljs-keyword\">let</span> message: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;...&#x27;</span>;\n    <span class=\"hljs-keyword\">if</span> (isKorean !== <span class=\"hljs-literal\">null</span>)\n        message = isKorean ? <span class=\"hljs-string\">&#x27;한국인이시군요.&#x27;</span> : <span class=\"hljs-string\">&quot;You&#x27;re not Korean!&quot;</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{ message }<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n}</code></pre>\n<h3 id=\"결과가-불명확한-코드-수정\">결과가 불명확한 코드 수정</h3>\n<p>이런 코드는 당연히 빌드할 때 생긴 초기 UI와 클라이언트 렌더링시의 초기 UI가 서로 다르게 한다. 빌드시 시간의 초 단위가 짝수면 결과는 *Yes!*가 렌더링될텐데, 사용자가 로드할 때 시간이 홀수면 *No!*가 렌더링되니 서로 불일치하다. 이런 코드가 있다면 수정해야 한다.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isTimeEven</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">const</span> time = (<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()).getSeconds() % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">return</span> time ? <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> Yes! <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span> : <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> No! <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n}</code></pre>\n<h2 id=\"hydration-적용\">hydration 적용</h2>\n<p>위에서 언급한 문제를 모두 수정했다면 hydration시 초기 UI 불일치 오류는 없을 것이다. 이제 hydration을 적용해보자.</p>\n<h3 id=\"진입-스크립트-수정\">진입 스크립트 수정</h3>\n<p>먼저, hydrate하도록 <code>src/index.tsx</code>를 수정하자.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/index.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom/client&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;../styles/index.css&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> isBrowser <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./isBrowser&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Index</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;bg-gray-400&quot;</span>&gt;</span>\n      Hello, World!\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n}\n\n<span class=\"hljs-comment\">// 만약 브라우저라면</span>\n<span class=\"hljs-keyword\">if</span> (isBrowser()) {\n    <span class=\"hljs-comment\">// body &gt; #root 태그에</span>\n    <span class=\"hljs-keyword\">const</span> rootDiv = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;body &gt; #root&#x27;</span>)!;\n    <span class=\"hljs-comment\">// hydration이 필요하다면 (빌드 결과물)</span>\n    <span class=\"hljs-keyword\">if</span> (rootDiv.classList.contains(<span class=\"hljs-string\">&#x27;hydrate&#x27;</span>)) {\n        <span class=\"hljs-comment\">// Index 컴포넌트를 hydrate한다.</span>\n        ReactDOM.hydrateRoot(rootDiv, <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Index</span> /&gt;</span></span>);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-comment\">/* 만약 hydration이 필요없다면 (webpack serve) */</span> {\n        <span class=\"hljs-comment\">// 그냥 렌더링 한다.</span>\n        <span class=\"hljs-keyword\">const</span> root = ReactDOM.createRoot(rootDiv);\n        root.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Index</span> /&gt;</span></span>)\n    }\n}</code></pre>\n<p>브라우저 환경 여부를 판단하는 <code>src/isBrowser.ts</code>도 간단하게 작성한다.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// src/isBrowser.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isBrowser</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">window</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">document</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span>;\n}</code></pre>\n<p><code>src/index.tsx</code>는 빌드 스크립트에서도 import된다. 따라서 브라우저단에서만 실행되야 하는 코드는 브라우저단에서만 실행되도록 수정해야 한다.</p>\n<h3 id=\"html-템플릿-생성\">HTML 템플릿 생성</h3>\n<p>그 다음으로, 간단한 HTML 템플릿을 생성한다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- src/index.html --&gt;</span>\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;ko&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf8&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Lorem ipsum<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;root&quot;</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n<h3 id=\"html-생성-스크립트-추가\">HTML 생성 스크립트 추가</h3>\n<p>초기 HTML 코드를 생성하는 스크립트를 작성해야 한다. 먼저 스크립트 작성 전에 의존성을 몇가지 설치하자.</p>\n<pre><code class=\"hljs language-bash\">yarn add cheerio tmp-promise</code></pre>\n<p>그 다음으로, 다음과 같이 스크립트를 작성한다.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/generate.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> { load <span class=\"hljs-keyword\">as</span> loadHTML } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;cheerio&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { createWriteStream, promises <span class=\"hljs-keyword\">as</span> fs } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;fs&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> server <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom/server&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> tmp <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;tmp-promise&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> Index <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./index&#x27;</span>;\n\n(<span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-comment\">// 임시 파일을 생성한다.</span>\n    <span class=\"hljs-keyword\">const</span> tmpFile = <span class=\"hljs-keyword\">await</span> tmp.file();\n\n    <span class=\"hljs-comment\">// Webpack 번들러에 의해 생성된 HTML 파일의 위치이다.</span>\n    <span class=\"hljs-keyword\">const</span> filename = <span class=\"hljs-string\">&#x27;./dist/index.html&#x27;</span>;\n\n    <span class=\"hljs-comment\">// 초기 UI 코드를 생성하는 ReactDOMServer의 스트림이다.</span>\n    <span class=\"hljs-keyword\">const</span> reactStream = server.renderToPipeableStream(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Index</span> /&gt;</span></span>);\n\n    <span class=\"hljs-comment\">// 스트림을 임시 파일에 쓴다.</span>\n    <span class=\"hljs-keyword\">const</span> fileStream = createWriteStream(tmpFile.path);\n\n    <span class=\"hljs-comment\">// 초기 UI 코드가 임시 파일에 모두 써졌으면</span>\n    reactStream.pipe(fileStream).on(<span class=\"hljs-string\">&#x27;finish&#x27;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n        <span class=\"hljs-comment\">// 웹팩에 의해 번들링된 HTML 파일을 읽는다.</span>\n        <span class=\"hljs-keyword\">const</span> htmlText = <span class=\"hljs-keyword\">await</span> fs.readFile(filename, { <span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">&#x27;utf8&#x27;</span> });\n\n        <span class=\"hljs-comment\">// HTML 파일의 id가 root인 태그에 초기 UI 코드를 넣는다.</span>\n        <span class=\"hljs-keyword\">const</span> dom = loadHTML(htmlText);\n        dom(<span class=\"hljs-string\">&#x27;body &gt; #root&#x27;</span>).html(<span class=\"hljs-keyword\">await</span> fs.readFile(tmpFile.path, { <span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">&#x27;utf8&#x27;</span> }));\n        dom(<span class=\"hljs-string\">&#x27;body &gt; #root&#x27;</span>).addClass(<span class=\"hljs-string\">&#x27;hydrate&#x27;</span>);\n        dom(<span class=\"hljs-string\">&#x27;body &gt; #root&#x27;</span>);\n\n        <span class=\"hljs-comment\">// HTML 코드를 저장한다.</span>\n        <span class=\"hljs-keyword\">await</span> fs.writeFile(filename, dom.html());\n    });\n})();</code></pre>\n<h3 id=\"webpack-설정-수정\">Webpack 설정 수정</h3>\n<p>Webpack 설정 파일에 생성 스크립트로 번들링하는 설정을 추가한다.\nNode.js를 타켓팅할 시 일부 모듈은 C/C++ 에드온을 이용할 수 있다. 따라서 해당 경우에 대응할 수 있도록 <a href=\"https://www.npmjs.com/package/node-loader\">node-loader</a> 의존성을 같이 설치한다. (만약 그러한 모듈이 없다면 이 문단에서 <code>.node</code> 관련 내용은 무시해도 된다.) <a href=\"https://www.npmjs.com/package/empty-loader\">empty-loader</a> 모듈은 빌드 스크립트에서 CSS 파일을 무시하는 데 이용된다.</p>\n<pre><code class=\"hljs language-bash\">yarn add --dev node-loader empty-loader</code></pre>\n<p>그리고 다음과 같이 <code>webpack.config.js</code>를 수정한다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack.config.js</span>\n\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> HtmlWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;html-webpack-plugin&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> { CleanWebpackPlugin } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;clean-webpack-plugin&#x27;</span>);\n\n<span class=\"hljs-keyword\">const</span> dev = process.env.NODE_ENV === <span class=\"hljs-string\">&#x27;development&#x27;</span>;\n\n<span class=\"hljs-comment\">// src/index.tsx 설정과 src/generate.ts 설정에 공통적으로 들어가는 항목들이다.</span>\n<span class=\"hljs-keyword\">const</span> commons = {\n    <span class=\"hljs-attr\">mode</span>: dev ? <span class=\"hljs-string\">&quot;development&quot;</span> : <span class=\"hljs-string\">&quot;production&quot;</span>,\n    <span class=\"hljs-attr\">resolve</span>: {\n        <span class=\"hljs-comment\">// .node가 추가되었다.</span>\n        <span class=\"hljs-attr\">extensions</span>: [<span class=\"hljs-string\">&#x27;.tsx&#x27;</span>, <span class=\"hljs-string\">&#x27;.ts&#x27;</span>, <span class=\"hljs-string\">&#x27;.js&#x27;</span>, <span class=\"hljs-string\">&#x27;.css&#x27;</span>, <span class=\"hljs-string\">&#x27;.node&#x27;</span>]\n    },\n    <span class=\"hljs-attr\">module</span>: {\n        <span class=\"hljs-attr\">rules</span>: [\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.tsx?$/</span>,\n                exclude: <span class=\"hljs-regexp\">/node_modules/</span>,\n                use: [\n                    {\n                        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;babel-loader&#x27;</span>,\n                        <span class=\"hljs-attr\">options</span>: {\n                            <span class=\"hljs-attr\">presets</span>: [<span class=\"hljs-string\">&#x27;@babel/preset-react&#x27;</span>, <span class=\"hljs-string\">&#x27;@babel/preset-env&#x27;</span>]\n                        }\n                    },\n                    <span class=\"hljs-string\">&#x27;ts-loader&#x27;</span>\n                ]\n            },\n            {\n                <span class=\"hljs-comment\">// .node 파일을 로드한다.</span>\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.node$/</span>,\n                use: <span class=\"hljs-string\">&#x27;node-loader&#x27;</span>\n            }\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-keyword\">new</span> CleanWebpackPlugin()]\n};\n\n<span class=\"hljs-built_in\">module</span>.exports = [<span class=\"hljs-comment\">/* src/index.tsx 설정 */</span>{\n    ...commons,\n    <span class=\"hljs-attr\">optimization</span>: {\n      <span class=\"hljs-attr\">splitChunks</span>: {\n        <span class=\"hljs-attr\">chunks</span>: <span class=\"hljs-string\">&#x27;all&#x27;</span>\n      },\n      <span class=\"hljs-attr\">minimize</span>: !dev\n    },\n    <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&#x27;./src/index.tsx&#x27;</span>,\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.resolve(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;[name].js&#x27;</span>\n    },\n    <span class=\"hljs-attr\">module</span>: {\n        ...commons.module,\n        <span class=\"hljs-attr\">rules</span>: [\n            ...commons.module.rules,\n            <span class=\"hljs-comment\">// CSS를 빌드시 로드하도록 하면 오류가 발생한다. (Node.js 환경은 웹브라우저가 아니므로 스타일 주입 시도가 당연히 실패하기 때문이다.)</span>\n            <span class=\"hljs-comment\">// 따라서 css파일은 웹브라우저단에서 로드되는 번들 스크립트에서만 주입되도록 </span>\n            <span class=\"hljs-comment\">// src/index.tsx Webpack 설정에만 추가한다.</span>\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n                use: [<span class=\"hljs-string\">&#x27;style-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>, <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>]\n            },\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        ...commons.plugins,\n        <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>,\n        <span class=\"hljs-comment\">// template 속성을 추가한다.</span>\n        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;./src/index.html&#x27;</span>\n    })],\n    <span class=\"hljs-attr\">devServer</span>: {\n        <span class=\"hljs-attr\">static</span>: {<span class=\"hljs-attr\">directory</span>: path.join(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>)},\n        <span class=\"hljs-attr\">open</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">port</span>: <span class=\"hljs-string\">&#x27;auto&#x27;</span>,\n    },\n    <span class=\"hljs-attr\">watchOptions</span>: {\n        <span class=\"hljs-attr\">ignored</span>: <span class=\"hljs-regexp\">/node_modules/</span>\n    }\n}, <span class=\"hljs-comment\">/* src/generate.tsx 설정 */</span> {\n    ...commons,\n    <span class=\"hljs-comment\">// node로 실행할 스크립트이기 때문에 target을 node로 한다.</span>\n    <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;node&#x27;</span>,\n    <span class=\"hljs-comment\">// entry는 src/generate.tsx로 한다.</span>\n    <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&#x27;./src/generate.tsx&#x27;</span>,\n    <span class=\"hljs-attr\">module</span>: {\n        ...commons.module,\n        <span class=\"hljs-attr\">rules</span>: [\n            ...commons.module.rules,\n            {\n                <span class=\"hljs-comment\">// css파일은 무시한다.</span>\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n                use: [<span class=\"hljs-string\">&#x27;empty-loader&#x27;</span>]\n            },\n        ]\n    },\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.resolve(__dirname, <span class=\"hljs-string\">&#x27;dist-builder&#x27;</span>),\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.js&#x27;</span>\n    }\n}]</code></pre>\n<h2 id=\"빌드-스크립트-실행\">빌드 스크립트 실행</h2>\n<p>이제 거의 다 됐다. 다음 명령어로 빌드해보자.</p>\n<pre><code class=\"hljs language-bash\">npx webpack build\nnode ./dist-builder</code></pre>\n<p>별 다른 오류없이 잘 될 것이다. 축하한다. 이제 앞으로 위 명령어로 빌드하면 초기 HTML 코드가 들어가있는 파일이 빌드될 것이다. 해당 빌드의 결과는 다음과 같다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- dist/index.html --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 참고로 이 예시는 예시일뿐이며, 세부사항은 개개인의 상황에 따라 다를 수 있다. --&gt;</span>\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;ko&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf8&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Lorem ipsum<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">defer</span>=<span class=\"hljs-string\">&quot;defer&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;166.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">defer</span>=<span class=\"hljs-string\">&quot;defer&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;main.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;root&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bg-gray-400&quot;</span>&gt;</span>Hello, World!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n"}},"__N_SSG":true}